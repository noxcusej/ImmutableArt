{
  "version": 3,
  "sources": ["../../../node_modules/vue-composable/dist/vue-composable.esm-bundler.js"],
  "sourcesContent": ["import { isRef, ref, watch, onMounted, toRaw, getCurrentInstance, onUnmounted, computed, inject, reactive, unref, onActivated, onDeactivated, onBeforeUnmount, customRef, provide, watchEffect, readonly } from 'vue';\n\nfunction unwrap(o) {\r\n    return isRef(o) ? o.value : o;\r\n    // return unref(o) as T;\r\n}\r\nfunction wrap(o) {\r\n    return isRef(o) ? o : ref(o); // NOTE in v3 this is not necessary\r\n}\r\nconst isArray = Array.isArray;\r\nconst isFunction = (val) => typeof val === \"function\";\r\nconst isString = (val) => typeof val === \"string\";\r\nconst isSymbol = (val) => typeof val === \"symbol\";\r\nconst isBoolean = (val) => typeof val === \"boolean\";\r\nconst isUndefined = (val) => typeof val === \"undefined\";\r\nconst isNull = (val) => val === null;\r\nconst isDate = (val) => isObject(val) && isFunction(val.getTime);\r\nconst isNumber = (val) => typeof val === \"number\";\r\nconst isObject = (val) => val !== null && typeof val === \"object\";\r\nconst isElement = (val) => isObject(val) && !!val.tagName;\r\nfunction isPromise(val) {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n}\r\nconst NO_OP = () => { };\r\nconst FALSE_OP = () => false;\r\nconst PASSIVE_EV = { passive: true };\r\nfunction promisedTimeout(timeout) {\r\n    return new Promise((res) => {\r\n        setTimeout(res, timeout);\r\n    });\r\n}\r\n// https://v8.dev/blog/react-cliff\r\nconst MAX_ARRAY_SIZE = 2 ** 32 - 2;\r\nfunction minMax(val, min, max) {\r\n    if (val < min)\r\n        return min;\r\n    if (val > max)\r\n        return max;\r\n    return val;\r\n}\r\nconst isClient = typeof window != \"undefined\";\r\nfunction deepClone(result, ...sources) {\r\n    for (let i = 0; i < sources.length; i++) {\r\n        const source = sources[i];\r\n        if (source === undefined || !isObject(source))\r\n            continue;\r\n        const keys = Object.keys(source);\r\n        for (let j = 0; j < keys.length; j++) {\r\n            const k = keys[j];\r\n            const v = unwrap(source[k]);\r\n            const sourceType = typeof v;\r\n            const type = typeof result[k];\r\n            if (result[k] === undefined || sourceType === type) {\r\n                result[k] = isObject(v)\r\n                    ? deepClone(result[k] || {}, v)\r\n                    : source[k]; // source[k] is assigned because if is ref we want to override to this ref\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n// compact version: https://stackoverflow.com/a/33146982/1209882\r\n/**\r\n * returns a random string\r\n * @param len length of the string max: 36\r\n */\r\n// export function randomString(len: number) {\r\n//   return (+new Date).toString(36).slice(-len);\r\n// }\n\nfunction useEvent(el, name, listener, options) {\r\n    let remove = NO_OP;\r\n    if (el) {\r\n        const element = wrap(el);\r\n        const removeEventListener = (e) => e.removeEventListener(name, listener);\r\n        const addEventListener = (e) => e.addEventListener(name, listener, options);\r\n        const removeWatch = watch(element, (n, _, cleanUp) => {\r\n            if (n) {\r\n                addEventListener(n);\r\n                cleanUp(() => removeEventListener(n));\r\n            }\r\n        }, { immediate: true });\r\n        remove = () => {\r\n            removeEventListener(element.value);\r\n            removeWatch();\r\n        };\r\n    }\r\n    return remove;\r\n}\n\n/**\r\n * Create `debounced` function, options object can be changed after creation to update behaviour\r\n * @param handler - function to be debounced\r\n * @param wait - debounce ms\r\n * @param options - debounce options\r\n */\r\nfunction useDebounce(handler, wait, options) {\r\n    return debounce(handler, wait, options);\r\n}\r\nfunction debounce(func, waitMilliseconds = 50, options = {\r\n    isImmediate: false\r\n}) {\r\n    let timeoutId;\r\n    return function (...args) {\r\n        const context = this;\r\n        const doLater = function () {\r\n            timeoutId = undefined;\r\n            if (!options.isImmediate) {\r\n                func.apply(context, args);\r\n            }\r\n        };\r\n        const shouldCallNow = options.isImmediate && timeoutId === undefined;\r\n        if (timeoutId !== undefined) {\r\n            clearTimeout(timeoutId);\r\n        }\r\n        timeoutId = setTimeout(doLater, waitMilliseconds);\r\n        if (shouldCallNow) {\r\n            func.apply(context, args);\r\n        }\r\n    };\r\n}\n\nfunction useOnMouseMove(el, options, wait) {\r\n    const mouseX = ref(0);\r\n    const mouseY = ref(0);\r\n    const pageX = ref(0);\r\n    const pageY = ref(0);\r\n    let handler = (ev) => {\r\n        mouseX.value = ev.x;\r\n        mouseY.value = ev.y;\r\n        pageX.value = ev.pageX;\r\n        pageY.value = ev.pageY;\r\n    };\r\n    const [eventOptions, ms] = isNumber(options)\r\n        ? [undefined, options]\r\n        : [options, wait];\r\n    if (ms) {\r\n        handler = useDebounce(handler, wait);\r\n    }\r\n    const remove = useEvent(el, \"mousemove\", handler, eventOptions);\r\n    return {\r\n        mouseX,\r\n        mouseY,\r\n        pageX,\r\n        pageY,\r\n        remove,\r\n    };\r\n}\n\nfunction useOnResize(el, options, wait) {\r\n    const element = wrap(el);\r\n    const height = ref(element.value && element.value.clientHeight);\r\n    const width = ref(element.value && element.value.clientWidth);\r\n    let handler = () => {\r\n        height.value = element.value.clientHeight;\r\n        width.value = element.value.clientWidth;\r\n    };\r\n    const [eventOptions, ms] = isNumber(options)\r\n        ? [undefined, options]\r\n        : [options, wait];\r\n    if (ms) {\r\n        handler = useDebounce(handler, wait);\r\n    }\r\n    // resize seems only to be fired against the window\r\n    const remove = isClient\r\n        ? useEvent(window, \"resize\", handler, eventOptions || PASSIVE_EV)\r\n        : /* istanbul ignore next */ NO_OP;\r\n    if (isRef(el) && !el.value) {\r\n        onMounted(handler);\r\n    }\r\n    return {\r\n        height,\r\n        width,\r\n        remove\r\n    };\r\n}\n\nconst SCROLL_METHODS = [\"scrollBy\", \"scrollTo\", \"scrollIntoView\"];\r\nfunction useOnScroll(el, options, wait) {\r\n    const isValidElement = (el) => isNumber(el) || isBoolean(el) || !(isElement(el) || isRef(el)) || !el\r\n        ? false\r\n        : true;\r\n    const element = isValidElement(el)\r\n        ? wrap(el)\r\n        : ref((isClient && window) || undefined);\r\n    const scrollableElement = isValidElement(el)\r\n        ? element\r\n        : ref((isClient && window.document.scrollingElement) || undefined);\r\n    const scrollTop = ref((scrollableElement.value && scrollableElement.value.scrollTop) || 0);\r\n    const scrollLeft = ref((scrollableElement.value && scrollableElement.value.scrollLeft) || 0);\r\n    let handler = () => {\r\n        scrollTop.value = scrollableElement.value.scrollTop;\r\n        scrollLeft.value = scrollableElement.value.scrollLeft;\r\n    };\r\n    const methods = SCROLL_METHODS.reduce((p, c) => {\r\n        //@ts-ignore\r\n        p[c] = (...args) => \r\n        //@ts-ignore\r\n        scrollableElement.value &&\r\n            //@ts-ignore\r\n            scrollableElement.value[c] &&\r\n            //@ts-ignore\r\n            scrollableElement.value[c].apply(scrollableElement.value, args);\r\n        return p;\r\n    }, {});\r\n    const scrollTopTo = (top) => methods.scrollTo({ top });\r\n    const scrollLeftTo = (left) => methods.scrollTo({ left });\r\n    const [eventOptions, ms] = isNumber(el) || !el\r\n        ? [PASSIVE_EV, el]\r\n        : isNumber(options)\r\n            ? [PASSIVE_EV, options]\r\n            : [options, wait];\r\n    if (ms) {\r\n        handler = useDebounce(handler, wait);\r\n    }\r\n    const eventRemove = useEvent(element, \"scroll\", handler, eventOptions);\r\n    const watchRemoveTop = watch(scrollTop, scrollTopTo, { immediate: false });\r\n    const watchRemoveLeft = watch(scrollLeft, scrollLeftTo, { immediate: false });\r\n    const remove = () => {\r\n        eventRemove();\r\n        watchRemoveLeft();\r\n        watchRemoveTop();\r\n    };\r\n    return {\r\n        scrollTop,\r\n        scrollLeft,\r\n        remove,\r\n        scrollTopTo,\r\n        scrollLeftTo,\r\n        ...methods,\r\n    };\r\n}\n\nconst events = [\"mousedown\", \"touchstart\"];\r\nfunction useOnOutsidePress(el, onOutsidePressCallback) {\r\n    if (!isClient) {\r\n        return () => { };\r\n    }\r\n    const element = wrap(el);\r\n    const handler = (e) => element.value &&\r\n        !element.value.contains(e.target) &&\r\n        onOutsidePressCallback(e);\r\n    const event = events.find(x => `on${x}` in document.documentElement);\r\n    return useEvent(document, event, handler, { passive: true });\r\n}\n\nfunction usePromise(fn, lazyOptions) {\r\n    if (!fn) {\r\n        throw new Error(`[usePromise] argument can't be '${fn}'`);\r\n    }\r\n    if (typeof fn !== \"function\") {\r\n        throw new Error(`[usePromise] expects function, but received ${typeof fn}`);\r\n    }\r\n    const [lazy, throwException] = isBoolean(lazyOptions)\r\n        ? [lazyOptions, false]\r\n        : isObject(lazyOptions)\r\n            ? [lazyOptions.lazy, lazyOptions.throwException]\r\n            : [false, false];\r\n    const loading = ref(false);\r\n    const error = ref(null);\r\n    const result = ref(null);\r\n    const promise = ref();\r\n    const exec = async (...args) => {\r\n        loading.value = true;\r\n        error.value = null;\r\n        const throwExp = args &&\r\n            fn.length !== args.length &&\r\n            args.length > 0 &&\r\n            isBoolean(args[args.length - 1])\r\n            ? args[args.length - 1]\r\n            : throwException;\r\n        const currentPromise = (promise.value = fn(...args));\r\n        try {\r\n            const r = await currentPromise;\r\n            if (promise.value === currentPromise) {\r\n                result.value = r;\r\n            }\r\n            return r;\r\n        }\r\n        catch (er) {\r\n            if (toRaw(promise.value) === toRaw(currentPromise)) {\r\n                error.value = er;\r\n                result.value = null;\r\n            }\r\n            return throwExp ? currentPromise : undefined;\r\n        }\r\n        finally {\r\n            if (promise.value === currentPromise) {\r\n                loading.value = false;\r\n            }\r\n        }\r\n    };\r\n    if (!lazy) {\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            if (fn.length > 0 &&\r\n                !isBoolean(isObject(lazyOptions) ? lazyOptions.lazy : lazyOptions)) {\r\n                console.warn(\"[usePromise] parameters detected on `fn` factory. Executing promise without arguments.\");\r\n            }\r\n        }\r\n        // @ts-ignore\r\n        exec();\r\n    }\r\n    return {\r\n        exec,\r\n        result,\r\n        promise,\r\n        loading,\r\n        error,\r\n    };\r\n}\n\nfunction useCancellablePromise(fn, lazyOptions) {\r\n    const cancelled = ref(false);\r\n    let _cancel = undefined;\r\n    const cancel = (result) => {\r\n        if (!_cancel) {\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                console.warn(\"[useCancellablePromise] There's no promise to cancel. Please make sure to call `exec`\");\r\n            }\r\n            return;\r\n        }\r\n        _cancel(result);\r\n    };\r\n    const promise = (p) => new Promise((res, rej) => {\r\n        cancelled.value = false;\r\n        _cancel = (result) => {\r\n            cancelled.value = true;\r\n            rej(result);\r\n        };\r\n        p.then(res).catch(rej);\r\n    });\r\n    const use = usePromise((...args) => promise(fn(...args)), lazyOptions);\r\n    if (getCurrentInstance() &&\r\n        (!isObject(lazyOptions) || lazyOptions.unmountCancel !== false)) {\r\n        onUnmounted(() => _cancel && _cancel());\r\n    }\r\n    return {\r\n        ...use,\r\n        cancel,\r\n        cancelled,\r\n    };\r\n}\n\nconst MAX_RETRIES = 9000;\r\n/* istanbul ignore next */\r\nconst ExecutionId = /*#__PURE__*/ Symbol(((process.env.NODE_ENV !== 'production') && \"RetryId\") || ``);\r\n/* istanbul ignore next */\r\nconst CancellationToken = /*#__PURE__*/ Symbol(((process.env.NODE_ENV !== 'production') && \"CancellationToken\") || ``);\r\nconst defaultStrategy = async (options, context, factory, args) => {\r\n    const retryId = context[ExecutionId].value;\r\n    let i = -1;\r\n    const maxRetries = options.maxRetries || MAX_RETRIES + 1;\r\n    const delay = options.retryDelay || noDelay;\r\n    context.retryErrors.value = [];\r\n    context.isRetrying.value = false;\r\n    context.nextRetry.value = undefined;\r\n    let nextRetry = undefined;\r\n    do {\r\n        let success = false;\r\n        let result = null;\r\n        try {\r\n            ++i;\r\n            if (args) {\r\n                result = factory(...args);\r\n            }\r\n            else {\r\n                result = factory();\r\n            }\r\n            if (isPromise(result)) {\r\n                result = await result;\r\n            }\r\n            // is cancelled?\r\n            if (context[CancellationToken].value) {\r\n                return null;\r\n            }\r\n            success = true;\r\n        }\r\n        catch (error) {\r\n            result = null;\r\n            context.retryErrors.value.push(error);\r\n        }\r\n        // is our retry current one?\r\n        if (retryId !== context[ExecutionId].value) {\r\n            return result;\r\n        }\r\n        if (success) {\r\n            context.isRetrying.value = false;\r\n            context.nextRetry.value = undefined;\r\n            return result;\r\n        }\r\n        if (i >= maxRetries) {\r\n            context.isRetrying.value = false;\r\n            context.nextRetry.value = undefined;\r\n            return Promise.reject(new Error(`[useRetry] max retries reached ${maxRetries}`));\r\n        }\r\n        context.isRetrying.value = true;\r\n        const now = Date.now();\r\n        const pDelayBy = delay(i); // wrapped\r\n        const delayBy = isPromise(pDelayBy) ? await pDelayBy : pDelayBy; // unwrap promise\r\n        if (!isPromise(pDelayBy) || !!delayBy) {\r\n            if (isNumber(delayBy)) {\r\n                nextRetry = delayBy;\r\n            }\r\n            else if (isDate(delayBy)) {\r\n                nextRetry = delayBy.getTime();\r\n            }\r\n            else {\r\n                throw new Error(`[useRetry] invalid value received from options.retryDelay '${typeof delayBy}'`);\r\n            }\r\n            // if the retry is in the past, means we need to await that amount\r\n            if (nextRetry < now) {\r\n                context.nextRetry.value = now + nextRetry;\r\n            }\r\n            else {\r\n                context.nextRetry.value = nextRetry;\r\n                nextRetry = nextRetry - now;\r\n            }\r\n            if (nextRetry > 0) {\r\n                await promisedTimeout(nextRetry);\r\n            }\r\n        }\r\n        // is cancelled?\r\n        if (context[CancellationToken].value) {\r\n            return null;\r\n        }\r\n        // is our retry current one?\r\n        if (retryId !== context[ExecutionId].value) {\r\n            return result;\r\n        }\r\n    } while (i < MAX_RETRIES);\r\n    return null;\r\n};\r\nfunction useRetry(options, factory) {\r\n    const opt = !options || isFunction(options) ? {} : options;\r\n    const fn = isFunction(options) ? options : factory;\r\n    if (!isFunction(options) && !isObject(options)) {\r\n        throw new Error(\"[useRetry] options needs to be 'object'\");\r\n    }\r\n    if (!!fn && !isFunction(fn)) {\r\n        throw new Error(\"[useRetry] factory needs to be 'function'\");\r\n    }\r\n    const isRetrying = ref(false);\r\n    const nextRetry = ref();\r\n    const retryErrors = ref([]);\r\n    const cancellationToken = { value: false };\r\n    const retryId = { value: 0 };\r\n    const retryCount = computed(() => retryErrors.value.length);\r\n    const context = {\r\n        isRetrying,\r\n        retryCount,\r\n        nextRetry,\r\n        retryErrors,\r\n        [ExecutionId]: retryId,\r\n        [CancellationToken]: cancellationToken\r\n    };\r\n    const exec = fn\r\n        ? (...args) => {\r\n            ++context[ExecutionId].value;\r\n            return defaultStrategy(opt, context, fn, args);\r\n        }\r\n        : (f) => {\r\n            ++context[ExecutionId].value;\r\n            return defaultStrategy(opt, context, f, undefined);\r\n        };\r\n    const cancel = () => {\r\n        context.isRetrying.value = false;\r\n        context.retryErrors.value.push(new Error(\"[useRetry] cancelled\"));\r\n        context.nextRetry.value = undefined;\r\n        cancellationToken.value = true;\r\n    };\r\n    return {\r\n        ...context,\r\n        cancel,\r\n        exec\r\n    };\r\n}\r\nconst exponentialDelay = retryNumber => {\r\n    const delay = Math.pow(2, retryNumber) * 100;\r\n    const randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\r\n    return delay + randomSum;\r\n};\r\nconst noDelay = () => 0;\n\nfunction usePromiseLazy(fn, throwException = false) {\r\n    // @ts-ignore\r\n    return usePromise(fn, {\r\n        lazy: true,\r\n        throwException\r\n    });\r\n}\n\n// istanbul ignore next\r\nconst DEVTOOLS_KEY = Symbol(((process.env.NODE_ENV !== 'production') && \"DEVTOOLS_KEY\") || ``);\r\n/**\r\n * provide devtools api instance to the app\r\n * @param app\r\n * @param api\r\n */\r\nfunction setDevtools(app, api) {\r\n    if (!isFunction(app.provide)) {\r\n        console.warn(\"[vue-composable] devtools is not supported for vue 2\");\r\n        return;\r\n    }\r\n    app.provide(DEVTOOLS_KEY, api);\r\n}\r\n/**\r\n * Exposes the internal devtools api instance\r\n */\r\nfunction getDevtools() {\r\n    const empty = {};\r\n    const devtools = inject(DEVTOOLS_KEY, empty);\r\n    if (devtools === empty) {\r\n        console.warn(`[vue-composable] devtools not found, please run app.use(VueComposableDevtools)`);\r\n        return undefined;\r\n    }\r\n    return devtools;\r\n}\n\nlet apiProxyFactory = undefined;\r\nasync function pushEventsToApi(api, EventQueue, ApiQueue) {\r\n    setTimeout(async () => {\r\n        const priority = [\r\n            \"addTimelineLayer\",\r\n            \"addInspector\",\r\n            \"sendInspectorTree\",\r\n            \"sendInspectorState\",\r\n            \"addTimelineEvent\"\r\n        ];\r\n        for (const k of priority) {\r\n            for (const it of ApiQueue.filter(x => x.type === k)) {\r\n                // @ts-ignore\r\n                api[k](...it.args);\r\n            }\r\n            await promisedTimeout(20);\r\n        }\r\n        new Set(ApiQueue.filter(x => x.type === \"notifyComponentUpdate\").map(x => x.args[0])).forEach(x => api.notifyComponentUpdate(x));\r\n        // @ts-ignore\r\n        EventQueue.forEach(x => api.on[x.type](...x.args));\r\n        EventQueue.length = 0;\r\n        ApiQueue.length = 0;\r\n    }, 100);\r\n}\r\n{\r\n    apiProxyFactory = promiseApi => {\r\n        let api;\r\n        const EventQueue = [];\r\n        const ApiQueue = [];\r\n        const onProxy = new Proxy({}, {\r\n            get: (target, prop) => {\r\n                if (api) {\r\n                    //@ts-expect-error\r\n                    return api.on[prop];\r\n                }\r\n                else if (prop in target) {\r\n                    // @ts-ignore\r\n                    return target[prop];\r\n                }\r\n                else {\r\n                    //@ts-ignore\r\n                    return (target[prop] = (...args) => {\r\n                        EventQueue.push({\r\n                            type: prop,\r\n                            args\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n        });\r\n        const proxy = new Proxy({\r\n            on: onProxy\r\n        }, {\r\n            get: (target, prop) => {\r\n                if (prop === \"on\") {\r\n                    return target.on;\r\n                }\r\n                if (api) {\r\n                    return api[prop];\r\n                }\r\n                if (prop in target) {\r\n                    // @ts-ignore\r\n                    return target[prop];\r\n                }\r\n                // @ts-ignore\r\n                return (target[prop] = (...args) => {\r\n                    ApiQueue.push({\r\n                        type: prop,\r\n                        args\r\n                    });\r\n                });\r\n            }\r\n        });\r\n        promiseApi.then(x => {\r\n            api = x;\r\n            pushEventsToApi(api, EventQueue, ApiQueue);\r\n        });\r\n        return proxy;\r\n    };\r\n}\r\nvar ProxyApi = apiProxyFactory;\n\nlet setupDevtoolsPlugin = NO_OP;\r\n// NOTE maybe change this to other flag\r\nif ((process.env.NODE_ENV !== 'production')) {\r\n    try {\r\n        setupDevtoolsPlugin = require(\"@vue/devtools-api\").setupDevtoolsPlugin;\r\n    }\r\n    catch { }\r\n}\r\nconst UseDevtoolsApp = (app, id = \"vue-composable\", label = \"Vue-composable devtools plugin\") => {\r\n    const promise = new Promise(res => {\r\n        setupDevtoolsPlugin({\r\n            id,\r\n            label,\r\n            app\r\n        }, res);\r\n    });\r\n    setDevtools(app, ProxyApi(promise));\r\n};\n\nconst VueComposableDevtools = {\r\n    install(app, options = {\r\n        id: \"vue-composable\",\r\n        label: \"Vue-composable devtools plugin\"\r\n    }) {\r\n        return UseDevtoolsApp(app, options.id, options.label);\r\n    }\r\n};\n\nfunction useDevtoolsInspector(options, nodeList = []) {\r\n    const api = getDevtools();\r\n    const nodes = ref(nodeList);\r\n    const byId = computed(() => {\r\n        if (!nodes.value)\r\n            return new Map();\r\n        const r = toRaw(nodes.value);\r\n        const m = new Map();\r\n        for (const i of r) {\r\n            m.set(i.id, i);\r\n        }\r\n        return m;\r\n    });\r\n    if (api) {\r\n        const id = options.id;\r\n        api.addInspector(options);\r\n        // api.on.getInspectorState();\r\n        api.on.getInspectorTree((payload) => {\r\n            if (payload.inspectorId != id)\r\n                return;\r\n            if (!nodes.value)\r\n                return;\r\n            const filter = payload.filter;\r\n            let m = toRaw(nodes.value);\r\n            if (payload.filter) {\r\n                if (options.nodeFilter) {\r\n                    m = options.nodeFilter(payload.filter, m);\r\n                }\r\n                else {\r\n                    // TODO better filtering, only currently filtering root nodes\r\n                    m = m.filter((x) => x.id.indexOf(filter) >= 0 || x.label.indexOf(filter) >= 0);\r\n                }\r\n            }\r\n            payload.rootNodes = m;\r\n        });\r\n        api.on.getInspectorState((payload) => {\r\n            if (payload.inspectorId != id)\r\n                return;\r\n            const node = byId.value.get(payload.nodeId);\r\n            if (node) {\r\n                const s = reactive(node.state); // unwrap\r\n                payload.state = options.stateFilter ? options.stateFilter(\"\", s) : s;\r\n            }\r\n        });\r\n        watch(nodes, () => {\r\n            api.sendInspectorTree(id);\r\n            api.sendInspectorState(id);\r\n        }, {\r\n            immediate: true,\r\n            deep: true,\r\n        });\r\n    }\r\n    return {\r\n        nodes,\r\n    };\r\n}\n\nfunction useDevtoolsTimelineLayer(id, label, color) {\r\n    const api = getDevtools();\r\n    let addEvent = NO_OP;\r\n    let pushEvent = NO_OP;\r\n    if (api) {\r\n        api.addTimelineLayer({\r\n            id,\r\n            label,\r\n            color,\r\n        });\r\n        addEvent = (event, all) => api.addTimelineEvent({ layerId: id, event, all });\r\n        pushEvent = (event) => addEvent({ ...event, time: Date.now() });\r\n    }\r\n    return {\r\n        id,\r\n        addEvent,\r\n        pushEvent,\r\n    };\r\n}\n\nfunction getSetupStateExtra(raw) {\r\n    if (!raw)\r\n        return {};\r\n    // NOTE vue3!\r\n    const isRef = !!raw.__v_isRef;\r\n    const isComputed = isRef && !!raw.effect;\r\n    const isReactive = !!raw.__v_reactive;\r\n    const objectType = isComputed\r\n        ? \"Computed\"\r\n        : isRef\r\n            ? \"Ref\"\r\n            : isReactive\r\n                ? \"Reactive\"\r\n                : null;\r\n    return {\r\n        ...(objectType ? { objectType } : {}),\r\n        ...(raw.effect ? { raw: raw.effect.raw.toString() } : {}),\r\n    };\r\n}\r\nfunction useDevtoolsComponentState(state, options) {\r\n    const instance = getCurrentInstance();\r\n    const api = getDevtools();\r\n    if (api && instance) {\r\n        api.on.inspectComponent((payload, ctx) => {\r\n            if (payload.componentInstance !== instance)\r\n                return;\r\n            const [type, multiple] = isObject(options)\r\n                ? [options.type, options.multiple]\r\n                : [\"setup\", false];\r\n            if (isFunction(state)) {\r\n                state(payload.instanceData, ctx);\r\n                return;\r\n            }\r\n            let data = isArray(state)\r\n                ? state\r\n                : Object.keys(state).map((key) => ({\r\n                    type,\r\n                    key,\r\n                    value: unwrap(state[key]),\r\n                    ...getSetupStateExtra(state[key]),\r\n                }));\r\n            if (!multiple) {\r\n                const inserted = new Set(payload.instanceData.state.map((x) => x.key));\r\n                data = data.filter((x) => !inserted.has(x.key));\r\n            }\r\n            payload.instanceData.state.push(...data);\r\n        });\r\n    }\r\n}\n\nfunction isFetchOptions(v) {\r\n    return (v &&\r\n        (isBoolean(v.isJson) ||\r\n            isBoolean(v.parseImmediate) ||\r\n            isBoolean(v.unmountCancel)));\r\n}\r\nfunction useFetch(options, requestInitOptions) {\r\n    // TODO move to computeAsync\r\n    const json = ref(null);\r\n    const text = ref(\"\");\r\n    const blob = ref();\r\n    const jsonError = ref(null);\r\n    const [isJson, parseImmediate, unmountCancel] = isFetchOptions(options)\r\n        ? [\r\n            options.isJson !== false,\r\n            options.parseImmediate !== false,\r\n            options.unmountCancel !== false,\r\n        ]\r\n        : isFetchOptions(requestInitOptions)\r\n            ? [\r\n                requestInitOptions.isJson !== false,\r\n                requestInitOptions.parseImmediate !== false,\r\n                requestInitOptions.unmountCancel !== false,\r\n            ]\r\n            : [true, true, true];\r\n    const requestInit = options\r\n        ? isString(options)\r\n            ? requestInitOptions\r\n            : isFetchOptions(options)\r\n                ? options\r\n                : isString(options.url)\r\n                    ? requestInitOptions\r\n                    : options\r\n        : undefined;\r\n    let addTimelineEvent = undefined;\r\n    let devtoolId = (process.env.NODE_ENV !== 'production')\r\n        ? isString(options)\r\n            ? options\r\n            : options && isString(options.url)\r\n                ? options.url\r\n                : \"useFetch\"\r\n        : undefined;\r\n    if ((process.env.NODE_ENV !== 'production') && devtoolId) {\r\n        const layer = useDevtoolsTimelineLayer(`useFetch:${devtoolId}`, devtoolId, 0x32a2bf);\r\n        addTimelineEvent = (time, request, extra) => layer.addEvent({\r\n            time,\r\n            data: {\r\n                ...request,\r\n                ...extra,\r\n            },\r\n            meta: {},\r\n        });\r\n    }\r\n    const isCancelled = ref(false);\r\n    const cancelledMessage = ref();\r\n    let abortController = undefined;\r\n    const cancel = (message) => {\r\n        if (!abortController) {\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (addTimelineEvent) {\r\n                    addTimelineEvent(Date.now(), { message }, {\r\n                        type: \"cancel_error\",\r\n                        error: \"No request has been made yet\",\r\n                    });\r\n                }\r\n                throw new Error(\"Cannot cancel because no request has been made\");\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n        }\r\n        abortController.abort();\r\n        isCancelled.value = true;\r\n        cancelledMessage.value = message;\r\n        if (addTimelineEvent) {\r\n            addTimelineEvent(Date.now(), { message }, {\r\n                type: \"cancel\",\r\n            });\r\n        }\r\n    };\r\n    const use = usePromise(async (request, init) => {\r\n        abortController = new AbortController();\r\n        if (addTimelineEvent) {\r\n            addTimelineEvent(Date.now(), isString(request) ? { url: request } : request, { type: \"request\", init });\r\n        }\r\n        const response = await fetch(request, {\r\n            signal: abortController.signal,\r\n            ...requestInit,\r\n            ...init,\r\n        });\r\n        if (addTimelineEvent) {\r\n            addTimelineEvent(Date.now(), response, {\r\n                type: \"response\",\r\n                init,\r\n                request,\r\n            });\r\n        }\r\n        if (response) {\r\n            const promises = [\r\n                // JSON\r\n                isJson\r\n                    ? response\r\n                        .clone()\r\n                        .json()\r\n                        .then((x) => (json.value = x))\r\n                        .catch((x) => {\r\n                        json.value = null;\r\n                        jsonError.value = x;\r\n                    })\r\n                    : Promise.resolve(),\r\n                // BLOB\r\n                response\r\n                    .clone()\r\n                    .blob()\r\n                    .then((x) => {\r\n                    blob.value = x;\r\n                }),\r\n                // TEXT\r\n                response\r\n                    .clone()\r\n                    .text()\r\n                    .then((x) => {\r\n                    text.value = x;\r\n                }),\r\n            ];\r\n            if (parseImmediate) {\r\n                await Promise.all(promises);\r\n                if (addTimelineEvent) {\r\n                    addTimelineEvent(Date.now(), {}, {\r\n                        type: \"parsed\",\r\n                        json: json.value,\r\n                        blob: blob.value,\r\n                        text: text.value,\r\n                        request,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return response;\r\n    }, true);\r\n    const status = computed(() => (use.result.value && use.result.value.status) || null);\r\n    const statusText = computed(() => (use.result.value && use.result.value.statusText) || null);\r\n    // if not options are provided in the config, execute it straight away\r\n    // NOTE: `false` is passed to the `exec` to prevent the exception to be thrown\r\n    if (options) {\r\n        if (isString(options) || isString(options.url)) {\r\n            use.exec(options, undefined, false);\r\n        }\r\n    }\r\n    if (unmountCancel && getCurrentInstance()) {\r\n        onUnmounted(() => {\r\n            if (abortController) {\r\n                cancel(\"unmounted\");\r\n            }\r\n        });\r\n    }\r\n    return {\r\n        ...use,\r\n        cancel,\r\n        isCancelled,\r\n        cancelledMessage,\r\n        text,\r\n        blob,\r\n        json,\r\n        jsonError,\r\n        status,\r\n        statusText,\r\n    };\r\n}\n\nfunction useWebSocket(url, protocols) {\r\n    const supported = isClient && \"WebSocket\" in window;\r\n    let ws = null;\r\n    const messageEvent = ref(null);\r\n    const errorEvent = ref(null);\r\n    const data = ref(null);\r\n    const isOpen = ref(false);\r\n    const isClosed = ref(false);\r\n    const errored = ref(false);\r\n    /* istanbul ignore next  */\r\n    let lastMessage = ((process.env.NODE_ENV !== 'production') && Date.now()) || undefined;\r\n    let send = NO_OP;\r\n    let close = NO_OP;\r\n    if (supported) {\r\n        ws = new WebSocket(url, protocols);\r\n        ws.addEventListener(\"message\", x => {\r\n            messageEvent.value = x;\r\n            data.value = x.data;\r\n            // if the messages are to quick, we need to warn\r\n            /* istanbul ignore else  */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (Date.now() - lastMessage < 2) {\r\n                    console.warn('[useWebSocket] message rate is too high, if you are using \"data\" or \"messageEvent\"' +\r\n                        \" you might not get updated of all the messages.\" +\r\n                        ' Use \"ws.addEventListener(\"message\", handler)\" instead');\r\n                }\r\n                lastMessage = Date.now();\r\n            }\r\n        });\r\n        ws.addEventListener(\"error\", error => {\r\n            errorEvent.value = error;\r\n            errored.value = true;\r\n        });\r\n        ws.addEventListener(\"close\", () => {\r\n            isOpen.value = false;\r\n            isClosed.value = true;\r\n        });\r\n        ws.addEventListener(\"open\", () => {\r\n            isOpen.value = true;\r\n            isClosed.value = false;\r\n        });\r\n        send = (data) => ws.send(data);\r\n        close = (code, reason) => {\r\n            ws.close(code, reason);\r\n        };\r\n    }\r\n    return {\r\n        supported,\r\n        ws,\r\n        send,\r\n        close,\r\n        messageEvent,\r\n        errorEvent,\r\n        data,\r\n        isOpen,\r\n        isClosed,\r\n        errored\r\n    };\r\n}\n\nfunction useIntersectionObserver(refEl, refOptions) {\r\n    const supported = isClient && \"IntersectionObserver\" in window;\r\n    const wrappedElement = refEl ? wrap(refEl) : undefined;\r\n    const element = wrappedElement && (isElement(wrappedElement.value) || !wrappedElement.value)\r\n        ? wrappedElement\r\n        : undefined;\r\n    const options = computed(() => refOptions\r\n        ? unwrap(refOptions)\r\n        : !element\r\n            ? unwrap(refEl)\r\n            : undefined);\r\n    const elements = ref([]);\r\n    const isIntersecting = computed(() => elements.value.length > 0 && elements.value.every(x => x.isIntersecting));\r\n    const handling = (entries) => {\r\n        elements.value = entries;\r\n    };\r\n    let observer = ref();\r\n    if (supported) {\r\n        watch(options, options => {\r\n            if (observer.value) {\r\n                observer.value.disconnect();\r\n            }\r\n            const opts = (options &&\r\n                options && {\r\n                root: unwrap(options.root),\r\n                rootMargin: unwrap(options.rootMargin),\r\n                threshold: unwrap(options.threshold)\r\n            }) ||\r\n                undefined;\r\n            observer.value = new IntersectionObserver(handling, opts);\r\n            const targets = elements.value.map(x => x.target);\r\n            targets.forEach(observer.value.observe);\r\n        }, { deep: true, immediate: true });\r\n    }\r\n    const observe = supported\r\n        ? (element) => {\r\n            const e = unwrap(element);\r\n            observer.value.observe(e);\r\n        }\r\n        : NO_OP;\r\n    const unobserve = supported\r\n        ? (element) => {\r\n            const e = unwrap(element);\r\n            observer.value.unobserve(e);\r\n        }\r\n        : NO_OP;\r\n    const disconnect = () => observer.value.disconnect();\r\n    // if the element is passed we should add hooks\r\n    if (element) {\r\n        // if value is defined it is already being observed\r\n        // if (!element.value) {\r\n        onMounted(() => {\r\n            if (element.value) {\r\n                observe(element);\r\n            }\r\n        });\r\n        // }\r\n        onUnmounted(() => {\r\n            disconnect();\r\n        });\r\n    }\r\n    // // debug is still work in progress, would be nice to provide some\r\n    // // information about the target\r\n    // /* istanbul ignore next */\r\n    // const debug = () => {\r\n    //   if (elements.value.length === 0) {\r\n    //     (process.env.NODE_ENV !== 'production') && console.warn('[IntersectionObserver] no elements provided, did you mount the component?')\r\n    //     return;\r\n    //   }\r\n    //   // TODO: add border to the elements\r\n    // };\r\n    return {\r\n        supported,\r\n        elements,\r\n        observe,\r\n        unobserve,\r\n        disconnect,\r\n        isIntersecting\r\n    };\r\n}\n\nfunction useNetworkInformation() {\r\n    const connection = isClient\r\n        ? navigator.connection ||\r\n            navigator.mozConnection ||\r\n            navigator.webkitConnection\r\n        : false;\r\n    const supported = !!connection;\r\n    const downlink = ref(0);\r\n    const downlinkMax = ref(0);\r\n    const effectiveType = ref(\"none\");\r\n    const rtt = ref(0);\r\n    const saveData = ref(false);\r\n    const type = ref(\"none\");\r\n    let handler = NO_OP;\r\n    let remove = NO_OP;\r\n    /* istanbul ignore else  */\r\n    if (connection) {\r\n        handler = () => {\r\n            downlink.value = connection.downlink;\r\n            downlinkMax.value = connection.downlinkMax;\r\n            effectiveType.value = connection.effectiveType;\r\n            rtt.value = connection.rtt;\r\n            saveData.value = connection.saveData;\r\n            type.value = connection.type;\r\n        };\r\n        remove = useEvent(connection, \"change\", handler, PASSIVE_EV);\r\n        handler();\r\n    }\r\n    else {\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(\"[navigator.connection] not found, networkInformation not available.\");\r\n        }\r\n    }\r\n    return {\r\n        supported,\r\n        downlink,\r\n        downlinkMax,\r\n        effectiveType,\r\n        rtt,\r\n        saveData,\r\n        type,\r\n        remove\r\n    };\r\n}\n\nlet online = undefined;\r\nfunction useOnline() {\r\n    const supported = isClient && \"onLine\" in navigator;\r\n    // not sure how to test this :/\r\n    if (!supported) {\r\n        online = ref(false);\r\n    }\r\n    if (!online) {\r\n        online = ref(navigator.onLine);\r\n        window.addEventListener(\"offline\", () => (online.value = false), PASSIVE_EV);\r\n        window.addEventListener(\"online\", () => (online.value = true), PASSIVE_EV);\r\n    }\r\n    return {\r\n        supported,\r\n        online\r\n    };\r\n}\n\nlet visibility = undefined;\r\nlet hidden = undefined;\r\nfunction usePageVisibility() {\r\n    if (!hidden) {\r\n        hidden = ref(isClient && document.hidden);\r\n    }\r\n    if (!visibility) {\r\n        if (isClient) {\r\n            visibility = ref(document.visibilityState);\r\n            document.addEventListener(\"visibilitychange\", () => {\r\n                visibility.value = document.visibilityState;\r\n                hidden.value = document.hidden;\r\n            }, PASSIVE_EV);\r\n        }\r\n        else {\r\n            visibility = ref(\"visible\");\r\n        }\r\n    }\r\n    return {\r\n        visibility,\r\n        hidden\r\n    };\r\n}\n\nlet language = undefined;\r\nlet languages = undefined;\r\nfunction useLanguage() {\r\n    if (!language) {\r\n        language = isClient ? ref(navigator.language) : ref(\"\");\r\n    }\r\n    if (!languages) {\r\n        if (isClient) {\r\n            languages = ref(navigator.languages);\r\n            const change = () => {\r\n                language.value = navigator.language;\r\n                languages.value = navigator.languages;\r\n            };\r\n            window.addEventListener(\"languagechange\", change, PASSIVE_EV);\r\n        }\r\n        else {\r\n            languages = ref([]);\r\n        }\r\n    }\r\n    return {\r\n        language,\r\n        languages\r\n    };\r\n}\n\nfunction useBroadcastChannel(name, onBeforeClose) {\r\n    const supported = isClient && \"BroadcastChannel\" in self;\r\n    const data = ref(null);\r\n    const messageEvent = ref(null);\r\n    const errorEvent = ref(null);\r\n    const errored = ref(false);\r\n    const isClosed = ref(false);\r\n    let send = NO_OP;\r\n    let close = NO_OP;\r\n    let addListener = NO_OP;\r\n    /* istanbul ignore else  */\r\n    if (supported) {\r\n        const bc = new BroadcastChannel(name);\r\n        bc.addEventListener(\"messageerror\", e => {\r\n            errorEvent.value = e;\r\n            errored.value = true;\r\n        }, PASSIVE_EV);\r\n        bc.addEventListener(\"message\", ev => {\r\n            messageEvent.value = ev;\r\n            data.value = ev.data;\r\n        }, PASSIVE_EV);\r\n        send = d => bc.postMessage(d);\r\n        close = () => {\r\n            bc.close();\r\n            isClosed.value = true;\r\n        };\r\n        addListener = (cb, o) => {\r\n            bc.addEventListener(\"message\", cb, o);\r\n            onUnmounted(() => bc.removeEventListener(\"message\", cb));\r\n        };\r\n        onUnmounted(() => {\r\n            onBeforeClose && onBeforeClose();\r\n            close();\r\n        });\r\n    }\r\n    else {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(\"[BroadcastChannel] is not supported\");\r\n        }\r\n    }\r\n    return {\r\n        supported,\r\n        data,\r\n        messageEvent,\r\n        errorEvent,\r\n        errored,\r\n        isClosed,\r\n        send,\r\n        close,\r\n        addListener\r\n    };\r\n}\n\nfunction useGeolocation(options) {\r\n    const supported = isClient && !!navigator.geolocation;\r\n    // used to check if the execution is lazy\r\n    const lazy = ref(options ? options.immediate === false : undefined);\r\n    const error = ref(null);\r\n    const timestamp = ref(null);\r\n    const coords = ref(null);\r\n    const highAccuracy = ref((options && options.enableHighAccuracy) || null);\r\n    // allow manual control on when the geolocation is requested\r\n    let refresh = NO_OP;\r\n    if (supported) {\r\n        const setPosition = (pos) => {\r\n            timestamp.value = pos.timestamp;\r\n            coords.value = pos.coords;\r\n            error.value = null;\r\n        };\r\n        const setError = (err) => {\r\n            timestamp.value = Date.now();\r\n            coords.value = null;\r\n            error.value = err;\r\n        };\r\n        const clearWatch = () => lazy.value !== true &&\r\n            watchId &&\r\n            navigator.geolocation.clearWatch(watchId);\r\n        let _currentPositionRefresh = () => navigator.geolocation.getCurrentPosition(setPosition, setError, options);\r\n        if (lazy.value) {\r\n            refresh = () => {\r\n                if (lazy.value) {\r\n                    lazy.value = false;\r\n                }\r\n                else {\r\n                    _currentPositionRefresh();\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            // NOTE probably useless??\r\n            refresh = _currentPositionRefresh;\r\n        }\r\n        let watchId = 0;\r\n        onMounted(() => watch([highAccuracy, lazy], (a) => {\r\n            clearWatch();\r\n            const enableHighAccuracy = isBoolean(a[0])\r\n                ? a[0]\r\n                : options\r\n                    ? options.enableHighAccuracy\r\n                    : undefined;\r\n            watchId = navigator.geolocation.watchPosition(setPosition, setError, options\r\n                ? { ...options, enableHighAccuracy }\r\n                : { enableHighAccuracy });\r\n        }, {\r\n            immediate: !lazy.value,\r\n        }));\r\n        onUnmounted(clearWatch);\r\n    }\r\n    return {\r\n        supported,\r\n        refresh,\r\n        error,\r\n        timestamp,\r\n        coords,\r\n        highAccuracy,\r\n    };\r\n}\n\n/**\r\n * Gets the current value of the given CSS variable name for the given element.\r\n *\r\n * @param element The element to get the variable for.\r\n * @param name The CSS variable name.\r\n */\r\nfunction getCssVariableFor(element, name) {\r\n    const result = getComputedStyle(element).getPropertyValue(name);\r\n    return result ? result.trim() : null;\r\n}\r\n/**\r\n * Sets the value of the given CSS variable for the given element.\r\n *\r\n * @param element The element to set the variable for.\r\n * @param name The CSS variable name without dashes.\r\n * @param value The CSS variable value.\r\n */\r\nfunction setCssVariableFor(element, name, value) {\r\n    element.style.setProperty(name, value);\r\n}\r\nconst defaultOptions = {\r\n    attributes: true,\r\n    childList: true,\r\n    subtree: true\r\n};\r\nconst sanitizeCssVarName = (name) => {\r\n    if (name.length <= 2 || name[0] !== \"-\" || name[1] !== \"-\") {\r\n        return `--${name}`;\r\n    }\r\n    return name;\r\n};\r\nfunction useCssVariables(variables, elementOrOptions, optionsConfig) {\r\n    const supported = isClient && \"MutationObserver\" in self;\r\n    const [element, options] = isRef(elementOrOptions) || isElement(elementOrOptions)\r\n        ? [elementOrOptions, optionsConfig || defaultOptions]\r\n        : [\r\n            (supported && document.documentElement) || {},\r\n            elementOrOptions || defaultOptions\r\n        ];\r\n    // Reactive property to tell if the observer is listening\r\n    const observing = ref(true);\r\n    // Stores the results by reference.\r\n    const result = {};\r\n    // If the element is ref, we should only update the variable on mount\r\n    const updateValues = [];\r\n    // extract name\r\n    const defEntries = Object.entries(variables).map((x) => {\r\n        const [name, value] = isString(x[1]) ? [x[1]] : [x[1].name, x[1].value];\r\n        if (value) {\r\n            updateValues.push(() => setCssVariableFor(unwrap(element), name, unwrap(value)));\r\n            // if is ref, use provided ref instead\r\n            result[x[0]] = wrap(value);\r\n        }\r\n        return [x[0], sanitizeCssVarName(name)];\r\n    });\r\n    for (let i = 0; i < defEntries.length; i++) {\r\n        const [key, name] = defEntries[i];\r\n        if (!result[key]) {\r\n            // if is ref set null, onMount we will update\r\n            result[key] = ref((isRef(element) && !element.value) || !supported\r\n                ? null\r\n                : getCssVariableFor(unwrap(element), name));\r\n        }\r\n        if (supported) {\r\n            // keep track of changes\r\n            watch([result[key], wrap(element)], (val) => {\r\n                if (!observing)\r\n                    return;\r\n                // don't force if the current value is the same as the given one\r\n                // or if the given one is empty\r\n                if (val[1] && val[0] !== getCssVariableFor(val[1], name)) {\r\n                    setCssVariableFor(val[1], name, val[0]);\r\n                }\r\n            }, { immediate: !isRef(element) });\r\n        }\r\n    }\r\n    if (!supported) {\r\n        return {\r\n            ...result,\r\n            stop: NO_OP,\r\n            resume: NO_OP,\r\n            supported,\r\n            observing\r\n        };\r\n    }\r\n    const update = () => {\r\n        // Each time an observation has been made,\r\n        // we look up for each CSS variable and update their values.\r\n        for (let i = 0; i < defEntries.length; i++) {\r\n            const [key, value] = defEntries[i];\r\n            result[key].value = getCssVariableFor(unwrap(element), value);\r\n        }\r\n    };\r\n    // Sets up the observer.\r\n    const observer = new MutationObserver(update);\r\n    // Sets the `stop` method.\r\n    const stop = () => {\r\n        observer.disconnect();\r\n        observing.value = false;\r\n    };\r\n    // Sets the `start` method.\r\n    const resume = () => {\r\n        // if it was stopped we will update the variables to the current value\r\n        if (!observing.value) {\r\n            update();\r\n        }\r\n        observer.observe(unwrap(element), options);\r\n        observing.value = true;\r\n    };\r\n    // Stops on destroy\r\n    onUnmounted(stop);\r\n    if (isRef(element)) {\r\n        onMounted(() => {\r\n            updateValues.forEach(x => x());\r\n            watch(element, (n, o) => {\r\n                if (o) {\r\n                    stop();\r\n                }\r\n                if (n) {\r\n                    resume();\r\n                }\r\n            });\r\n        });\r\n    }\r\n    else if (isClient || element) {\r\n        updateValues.forEach(x => x());\r\n        // Starts observe\r\n        resume();\r\n    }\r\n    return {\r\n        ...result,\r\n        supported,\r\n        resume,\r\n        stop,\r\n        observing\r\n    };\r\n}\n\n// from https://github.com/dai-shi/react-hooks-worker/blob/1e842ad15c558fc04dd7339a62aaa43f46d1c7cd/src/exposeWorker.js\r\n// export function exposeWorker(func: (...args: any[]) => any): void;\r\nfunction exposeWorker(func) {\r\n    this.onmessage = async (e) => {\r\n        const r = func(e.data);\r\n        if (r === undefined) {\r\n            // istanbul ignore else\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                console.warn(`[exposeWorker] returned \\`${r}\\`, this might cause unexpected behaviour`);\r\n            }\r\n            this.postMessage(r);\r\n        }\r\n        else if (r === null) {\r\n            this.postMessage(r);\r\n        }\r\n        else if (isArray(r)) {\r\n            this.postMessage(r);\r\n        }\r\n        else if (r[Symbol.asyncIterator]) {\r\n            for await (const i of r)\r\n                this.postMessage(i);\r\n        }\r\n        else if (r[Symbol.iterator]) {\r\n            for (const i of r)\r\n                this.postMessage(i);\r\n        }\r\n        else {\r\n            this.postMessage(await r);\r\n        }\r\n    };\r\n}\r\nfunction useWorker(stringUrl, args, options) {\r\n    const supported = isClient && \"Worker\" in self;\r\n    const errorEvent = ref();\r\n    const data = ref();\r\n    const terminated = ref(!supported);\r\n    const errored = ref(!supported);\r\n    if (!supported) {\r\n        terminated.value = true;\r\n        return {\r\n            worker: undefined,\r\n            data,\r\n            postMessage: NO_OP,\r\n            terminate: NO_OP,\r\n            errorEvent,\r\n            errored,\r\n            terminated\r\n        };\r\n    }\r\n    const worker = new Worker(stringUrl, options);\r\n    /* istanbul ignore next  */\r\n    let lastMessage = ((process.env.NODE_ENV !== 'production') && Date.now() - 20) || undefined;\r\n    const postMessage = data => worker.postMessage(data);\r\n    function terminate() {\r\n        worker.terminate();\r\n        terminated.value = true;\r\n    }\r\n    worker.addEventListener(\"message\", x => {\r\n        data.value = x.data;\r\n        // if the messages are to quick, we need to warn\r\n        /* istanbul ignore else  */\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            if (Date.now() - lastMessage < 2) {\r\n                console.warn(\"[useWorker] message rate is too high, you might not get updated of all the messages.\");\r\n            }\r\n            lastMessage = Date.now();\r\n        }\r\n    }, PASSIVE_EV);\r\n    worker.addEventListener(\"error\", error => {\r\n        errorEvent.value = error;\r\n        errored.value = true;\r\n    }, PASSIVE_EV);\r\n    onUnmounted(terminate);\r\n    if (args) {\r\n        postMessage(args);\r\n    }\r\n    return {\r\n        worker,\r\n        data,\r\n        postMessage,\r\n        terminate,\r\n        errorEvent,\r\n        errored,\r\n        terminated\r\n    };\r\n}\n\n/**\r\n * Invokes the native sharing mechanism of the device\r\n * [compatibility](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share)\r\n * @param data - if provided it will automatically try to share it\r\n */\r\nfunction useShare(data) {\r\n    const supported = isClient && \"share\" in navigator;\r\n    let share = () => Promise.resolve(false);\r\n    let canShare = FALSE_OP;\r\n    let shared = ref(false);\r\n    let cancelled = ref(false);\r\n    if (supported) {\r\n        share = data => {\r\n            shared.value = false;\r\n            cancelled.value = false;\r\n            return navigator\r\n                .share(data)\r\n                .then(x => {\r\n                shared.value = true;\r\n                return x;\r\n            })\r\n                .catch(e => {\r\n                shared.value = false;\r\n                cancelled.value = true;\r\n                return false;\r\n            });\r\n        };\r\n        canShare = data => navigator.canShare(data);\r\n        if (data) {\r\n            if (canShare(data)) {\r\n                share(data);\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        supported,\r\n        share,\r\n        canShare,\r\n        shared,\r\n        cancelled\r\n    };\r\n}\n\nfunction useClipboard() {\r\n    const supported = isClient && \"clipboard\" in navigator;\r\n    const text = ref();\r\n    const data = ref();\r\n    const writeText = (data) => {\r\n        text.value = data;\r\n        if (!supported)\r\n            return Promise.resolve();\r\n        // TOOD check for permissions\r\n        return navigator.clipboard.writeText(data);\r\n    };\r\n    const write = (data) => {\r\n        if (!supported)\r\n            return Promise.resolve();\r\n        // TOOD check for permissions\r\n        // @ts-ignore\r\n        return navigator.clipboard.write(data);\r\n    };\r\n    let readText = () => Promise.resolve(undefined);\r\n    // @ts-ignore\r\n    let read = readText;\r\n    if (supported) {\r\n        let updating = false;\r\n        const update = () => readText().then((x) => (text.value = x));\r\n        [\"copy\", \"cut\", \"focus\"].map((event) => useEvent(window, event, () => update()));\r\n        readText = () => navigator.clipboard.readText().then((x) => {\r\n            try {\r\n                updating = true;\r\n                return (text.value = x);\r\n            }\r\n            finally {\r\n                // case of a sync watch it might throw\r\n                updating = false;\r\n            }\r\n        });\r\n        // @ts-ignore this should work\r\n        read = () => navigator.clipboard.read().then((x) => (data.value = x));\r\n        watch(text, debounce((s) => {\r\n            if (updating || !isString(s))\r\n                return;\r\n            writeText(s);\r\n        }, 100));\r\n    }\r\n    return {\r\n        supported,\r\n        text,\r\n        data,\r\n        writeText,\r\n        readText,\r\n        write,\r\n        read,\r\n    };\r\n}\n\n/**\r\n * @param fn setTimeout callback\r\n * @param delay If this parameter is omitted, a value of 0 is used\r\n * (https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)\r\n */\r\nfunction useTimeout(fn, delay = 0) {\r\n    let ready = ref(false);\r\n    const timeoutId = setTimeout(() => {\r\n        ready.value = true;\r\n        fn();\r\n    }, delay);\r\n    const cancel = () => {\r\n        ready.value = null;\r\n        clearTimeout(timeoutId);\r\n    };\r\n    onUnmounted(cancel);\r\n    return {\r\n        ready,\r\n        cancel,\r\n    };\r\n}\n\nconst inlineWorkExecution = (f) => function (e) {\r\n    const args = e.data || [];\r\n    return new Promise((res) => {\r\n        try {\r\n            Promise.resolve(f.apply(f, args))\r\n                // @ts-ignore\r\n                .then((x) => res(postMessage([true, x])))\r\n                // @ts-ignore\r\n                .catch((x) => res(postMessage([false, x])));\r\n        }\r\n        catch (e) {\r\n            // @ts-ignore\r\n            res(postMessage([false, e]));\r\n        }\r\n    });\r\n};\r\nfunction createBlobUrl(fn, dependencies) {\r\n    const scripts = dependencies.length > 0\r\n        ? `importScripts(\"${dependencies.join('\",\"')}\");`\r\n        : \"\";\r\n    const blobScript = [\r\n        scripts,\r\n        \"onmessage=\",\r\n        `(${inlineWorkExecution.toString()})(${fn.toString()})`,\r\n    ];\r\n    const blob = new Blob(blobScript, { type: \"text/javascript\" });\r\n    return URL.createObjectURL(blob);\r\n}\r\nfunction useWorkerFunction(fn, options) {\r\n    const supported = isClient && \"Worker\" in self;\r\n    // reactive\r\n    const dependencies = computed(() => (options && unwrap(options.dependencies)) || []);\r\n    const timeoutRef = computed(() => options && unwrap(options.timeout));\r\n    if (!supported) {\r\n        return useCancellablePromise(fn, { lazy: true, throwException: true });\r\n    }\r\n    const promise = useCancellablePromise((...args) => new Promise((res, rej) => {\r\n        const blobUrl = createBlobUrl(fn, dependencies.value);\r\n        const worker = new Worker(blobUrl);\r\n        let timeoutId = -1;\r\n        const timeout = timeoutRef.value;\r\n        const terminate = () => {\r\n            worker.terminate();\r\n            URL.revokeObjectURL(blobUrl);\r\n            clearTimeout(timeoutId);\r\n            removeWatch();\r\n        };\r\n        // if the last argument is ref(false) we should also track it\r\n        const watchCancel = args.length === fn.length + 1 &&\r\n            isRef(args[args.length - 1]) &&\r\n            args[args.length - 1].value === false\r\n            ? computed(() => promise.cancelled.value || args[args.length - 1].value)\r\n            : promise.cancelled;\r\n        const removeWatch = watchCancel\r\n            ? watch(watchCancel, () => {\r\n                terminate();\r\n                res(undefined);\r\n            }, { immediate: false })\r\n            : NO_OP;\r\n        worker.addEventListener(\"message\", (e) => {\r\n            if (e.data[0]) {\r\n                res(e.data[1]);\r\n            }\r\n            else {\r\n                rej(e.data[1]);\r\n            }\r\n            terminate();\r\n        }, PASSIVE_EV);\r\n        worker.addEventListener(\"error\", (e) => {\r\n            terminate();\r\n            rej(e);\r\n        }, PASSIVE_EV);\r\n        worker.postMessage([...args]);\r\n        if (timeout) {\r\n            timeoutId = setTimeout(() => {\r\n                promise.cancel(`[WebWorker] timeout after ${timeout}ms`);\r\n            }, timeout);\r\n        }\r\n    }), {\r\n        lazy: true,\r\n        throwException: true,\r\n    });\r\n    return promise;\r\n}\n\nfunction useMatchMedia(query) {\r\n    const supported = isClient ? \"matchMedia\" in window : false;\r\n    let mediaQueryList = undefined;\r\n    let matches = undefined;\r\n    let remove = NO_OP;\r\n    if (supported) {\r\n        mediaQueryList = ref(matchMedia(query));\r\n        matches = ref(mediaQueryList.value.matches);\r\n        const process = (e) => {\r\n            matches.value = e.matches;\r\n        };\r\n        mediaQueryList.value.addEventListener(\"change\", process, PASSIVE_EV);\r\n        const remove = () => mediaQueryList.value.removeEventListener(\"change\", process);\r\n        onUnmounted(remove);\r\n    }\r\n    else {\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(\"[matchMedia] not supported\");\r\n        }\r\n        mediaQueryList = ref({});\r\n        matches = ref(false);\r\n    }\r\n    return {\r\n        supported,\r\n        mediaQueryList,\r\n        matches,\r\n        remove\r\n    };\r\n}\n\nfunction useSharedRef(name, defaultValue) {\r\n    const { addListener, send, close, supported } = useBroadcastChannel(name, () => disconnect());\r\n    const id = Date.now();\r\n    const master = ref(false);\r\n    const mind = ref(0 /* HIVE */);\r\n    const editable = computed(() => mind.value === 1 /* MASTER */ ? master.value : true);\r\n    // who's listening to this broadcast\r\n    const targets = ref([]);\r\n    const data = ref(defaultValue);\r\n    // if the state was updated by an event it sets to true\r\n    let updateState = false;\r\n    let masterId = undefined;\r\n    send({ type: 0 /* INIT */ });\r\n    const ping = () => send({ type: 5 /* PING */, id });\r\n    const disconnect = () => {\r\n        if (targets.value.length === 0)\r\n            return;\r\n        if (master.value) {\r\n            send({\r\n                type: 3 /* SET_MIND */,\r\n                mind: 1 /* MASTER */,\r\n                id: Math.min(...targets.value),\r\n            });\r\n        }\r\n        send({\r\n            type: 4 /* LEAVE */,\r\n            id,\r\n        });\r\n    };\r\n    const setMind = (t) => {\r\n        switch (t) {\r\n            case 1 /* MASTER */: {\r\n                master.value = true;\r\n                break;\r\n            }\r\n            case 0 /* HIVE */: {\r\n                master.value = false;\r\n                break;\r\n            }\r\n        }\r\n        mind.value = t;\r\n        send({\r\n            type: 3 /* SET_MIND */,\r\n            id: id,\r\n            mind: mind.value,\r\n        });\r\n    };\r\n    addListener((e) => {\r\n        switch (e.data.type) {\r\n            case 0 /* INIT */: {\r\n                send({\r\n                    type: 2 /* UPDATE */,\r\n                    value: data.value,\r\n                    mind: mind.value,\r\n                });\r\n                break;\r\n            }\r\n            case 4 /* LEAVE */: {\r\n                const index = targets.value.indexOf(e.data.id);\r\n                if (index >= 0) {\r\n                    targets.value.splice(index, 1);\r\n                }\r\n                // if master disconnects\r\n                if (masterId === e.data.id && targets.value.length > 0) {\r\n                    send({\r\n                        type: 3 /* SET_MIND */,\r\n                        mind: 1 /* MASTER */,\r\n                        id: Math.min(id, ...targets.value),\r\n                    });\r\n                }\r\n                break;\r\n            }\r\n            case 2 /* UPDATE */: {\r\n                updateState = true;\r\n                data.value = e.data.value;\r\n                mind.value = e.data.mind;\r\n                break;\r\n            }\r\n            case 3 /* SET_MIND */: {\r\n                mind.value = e.data.mind;\r\n                masterId =\r\n                    (e.data.mind === 1 /* MASTER */ && e.data.id) || undefined;\r\n                master.value = masterId === id;\r\n                if (master.value) {\r\n                    targets.value = [];\r\n                    ping();\r\n                }\r\n                break;\r\n            }\r\n            case 5 /* PING */: {\r\n                targets.value = [e.data.id];\r\n                send({\r\n                    type: 6 /* PONG */,\r\n                    id,\r\n                });\r\n                break;\r\n            }\r\n            case 6 /* PONG */: {\r\n                targets.value.push(e.data.id);\r\n                break;\r\n            }\r\n        }\r\n    }, PASSIVE_EV);\r\n    ping();\r\n    watch(data, (v, o) => {\r\n        if (updateState) {\r\n            updateState = false;\r\n            return;\r\n        }\r\n        // mind is set to MASTER and we are not master, we shouldn't update!\r\n        if (mind.value === 1 /* MASTER */ && master.value === false) {\r\n            updateState = true;\r\n            data.value = o;\r\n            return;\r\n        }\r\n        send({\r\n            type: 2 /* UPDATE */,\r\n            mind: mind.value,\r\n            value: isObject(v) ? { ...v } : v,\r\n        });\r\n        updateState = false;\r\n    }, { deep: true, immediate: false });\r\n    if (isClient) {\r\n        window.addEventListener(\"unload\", disconnect, PASSIVE_EV);\r\n    }\r\n    onUnmounted(() => {\r\n        disconnect();\r\n        close();\r\n    });\r\n    return {\r\n        supported,\r\n        id,\r\n        data,\r\n        master,\r\n        mind,\r\n        editable,\r\n        targets,\r\n        ping,\r\n        setMind,\r\n        addListener: addListener,\r\n    };\r\n}\r\nlet shared = undefined;\r\nfunction refShared(defaultValue, id) {\r\n    const vm = getCurrentInstance();\r\n    const name = id\r\n        ? id\r\n        : vm.vnode.scopeId; // TODO test this :/ NOTE @vue/runtime-core might be different\r\n    if (!name) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(\"[refShared] please assign an id, returning `ref`\");\r\n        }\r\n        return ref(defaultValue);\r\n    }\r\n    /* istanbul ignore else  */\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        if (!shared) {\r\n            shared = new Set();\r\n        }\r\n        if (shared.has(name)) {\r\n            console.warn(\"[refShared] You can only have one refShared per component, if you need more please assign pass an id refShared(defaultValue, id)\");\r\n        }\r\n        shared.add(name);\r\n    }\r\n    const { data, supported } = useSharedRef(name, defaultValue);\r\n    /* istanbul ignore next  */\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        if (!supported) {\r\n            console.warn(\"[refShared] is dependent of BroadcastChannel\");\r\n        }\r\n    }\r\n    return data;\r\n}\n\nconst SCROLL_LOCK_CLASS = \"no-scroll\";\r\nfunction useLockScroll(selectorElements, classOptions) {\r\n    const elements = (isString(selectorElements)\r\n        ? ref([]) // it will be resolved when mounted\r\n        : isArray(unref(selectorElements))\r\n            ? wrap(selectorElements)\r\n            : wrap([selectorElements]));\r\n    const options = isString(classOptions)\r\n        ? { lockedClass: classOptions, auto: true }\r\n        : classOptions || { auto: true };\r\n    if (!options.lockedClass) {\r\n        options.lockedClass = SCROLL_LOCK_CLASS;\r\n    }\r\n    const locked = ref(false);\r\n    // NOTE issues on Vue3 because of the `watch.deep`, we wrap all elements\r\n    const tracked = computed(() => elements.value.map(x => ref(x)));\r\n    const remove = watch([locked, tracked], ([l, els], [oldLocked, oldElements]) => {\r\n        for (const refEl of els) {\r\n            const el = unwrap(refEl);\r\n            // istanbul ignore else\r\n            if (options.lockedClass) {\r\n                // istanbul ignore else\r\n                if (!el) {\r\n                    // istanbul ignore else\r\n                    if ((process.env.NODE_ENV !== 'production')) {\r\n                        console.warn(\"[useLockScroll] element is undefined\");\r\n                    }\r\n                    return;\r\n                }\r\n                el.classList.toggle(options.lockedClass, l);\r\n            }\r\n            if (options.onChange) {\r\n                if (oldLocked !== l || !oldElements.find(x => unwrap(x) === el))\r\n                    options.onChange(el, l);\r\n            }\r\n        }\r\n    }, { flush: \"sync\", deep: false });\r\n    const lock = () => (locked.value = true);\r\n    const unlock = () => (locked.value = false);\r\n    if (isString(selectorElements)) {\r\n        onMounted(() => (elements.value = Array.from(document.querySelectorAll(selectorElements))));\r\n    }\r\n    if (options.auto !== false) {\r\n        onMounted(lock);\r\n        onActivated(lock);\r\n        onDeactivated(unlock);\r\n        onBeforeUnmount(unlock);\r\n    }\r\n    return {\r\n        locked,\r\n        lock,\r\n        unlock,\r\n        remove\r\n    };\r\n}\n\nfunction useVModel(props, name) {\r\n    const instance = getCurrentInstance();\r\n    if (!instance) {\r\n        throw new Error(\"useVModel must be called from the setup or lifecycle hook methods.\");\r\n    }\r\n    return computed({\r\n        get() {\r\n            return props[name];\r\n        },\r\n        set(v) {\r\n            // @ts-ignore when building v2 the instance doesn't have `emit`\r\n            instance.emit(`update:${name}`, v);\r\n        },\r\n    });\r\n}\n\nfunction injectFactory(key, defaultValueFactory) {\r\n    return inject(key, defaultValueFactory, true);\r\n}\n\nfunction useInterval(callback, ms, ...args) {\r\n    let intervalId = undefined;\r\n    const start = (_ms, ..._args) => {\r\n        remove();\r\n        if (!_ms && !ms) {\r\n            return;\r\n        }\r\n        const m = (_ms || ms);\r\n        return (intervalId = setInterval(callback, m, ...(_args && _args.length ? _args : args)));\r\n    };\r\n    const remove = () => {\r\n        if (!intervalId)\r\n            return;\r\n        clearInterval(intervalId);\r\n        intervalId = undefined;\r\n    };\r\n    if (isNumber(ms)) {\r\n        start();\r\n    }\r\n    onUnmounted(remove);\r\n    return { remove, start };\r\n}\r\n// TODO move this:  type checkings\r\n// useInterval((x: number) => {}).start();\r\n// useInterval((x: number) => {}, 100, 1).start();\r\n// useInterval(() => {}).start();\n\nfunction refDebounced(value, delay) {\r\n    let [v, d] = arguments.length === 1 && isNumber(value) && typeof delay === \"undefined\"\r\n        ? [ref(), value]\r\n        : [ref(value), delay];\r\n    return customRef((track, trigger) => ({\r\n        get() {\r\n            track();\r\n            return v.value;\r\n        },\r\n        set: debounce(val => {\r\n            v.value = val;\r\n            trigger();\r\n        }, d)\r\n    }));\r\n}\n\nfunction intlDateFormatExtractArguments(localesOptions, opts) {\r\n    const wrappedOpts = wrap(opts);\r\n    const wrappedLocalesOptions = wrap(localesOptions);\r\n    return isObject(wrappedOpts.value) || isRef(opts)\r\n        ? [\r\n            wrappedLocalesOptions.value !== undefined\r\n                ? wrappedLocalesOptions\r\n                : undefined,\r\n            wrappedOpts,\r\n        ]\r\n        : isObject(wrappedLocalesOptions.value) &&\r\n            !isArray(wrappedLocalesOptions.value) &&\r\n            !isString(wrappedLocalesOptions.value)\r\n            ? [undefined, wrappedLocalesOptions]\r\n            : [\r\n                wrappedLocalesOptions.value\r\n                    ? wrappedLocalesOptions\r\n                    : undefined,\r\n                undefined,\r\n            ];\r\n}\n\nfunction useIntlDateTimeFormat(localesOptions, opts) {\r\n    const [locales, options] = intlDateFormatExtractArguments(localesOptions, opts);\r\n    const formatter = computed(() => new Intl.DateTimeFormat(unwrap(locales), unwrap(options)));\r\n    const formatString = (value, overrideOpts, overrideLocale) => {\r\n        const f = overrideOpts || overrideLocale\r\n            ? new Intl.DateTimeFormat(unwrap(overrideLocale) ||\r\n                unwrap(locales), { ...unwrap(options), ...unwrap(overrideOpts) })\r\n            : formatter.value;\r\n        const v = unwrap(value);\r\n        return f.format(isString(v) ? new Date(v) : v);\r\n    };\r\n    const format = (value, overrideOpts, overrideLocale) => computed(() => formatString(value, overrideOpts, overrideLocale));\r\n    return {\r\n        format,\r\n        formatString,\r\n        formatter,\r\n    };\r\n}\n\nfunction useIntlNumberFormat(localesOptions, opts) {\r\n    const [locales, options] = intlDateFormatExtractArguments(localesOptions, opts);\r\n    const formatter = computed(() => new Intl.NumberFormat(unwrap(locales), unwrap(options)));\r\n    const formatString = (value, overrideOpts, overrideLocale) => {\r\n        const f = overrideOpts || overrideLocale\r\n            ? new Intl.NumberFormat(unwrap(overrideLocale) ||\r\n                unwrap(locales), { ...unwrap(options), ...unwrap(overrideOpts) })\r\n            : formatter.value;\r\n        return f.format(unwrap(value));\r\n    };\r\n    const format = (value, overrideOpts, overrideLocale) => computed(() => formatString(value, overrideOpts, overrideLocale));\r\n    return {\r\n        format,\r\n        formatString,\r\n        formatter\r\n    };\r\n}\n\nfunction useCurrencyFormat(currencyCodeOptions, localesOptions, opts) {\r\n    const unwrapCodeOptions = unwrap(currencyCodeOptions);\r\n    const hasCurrency = !isObject(unwrapCodeOptions);\r\n    const currencyCode = hasCurrency\r\n        ? currencyCodeOptions\r\n        : computed(() => {\r\n            const o = unwrap(currencyCodeOptions);\r\n            return o.currency;\r\n        });\r\n    const [locales, argOptions] = intlDateFormatExtractArguments(localesOptions, hasCurrency\r\n        ? opts\r\n        : currencyCodeOptions);\r\n    const options = computed(() => {\r\n        const opts = unwrap(argOptions) || {};\r\n        const currency = unwrap(currencyCode) || opts.currency;\r\n        return {\r\n            style: \"currency\",\r\n            ...opts,\r\n            currency\r\n        };\r\n    });\r\n    const numberFormat = useIntlNumberFormat(locales);\r\n    const formatString = (amount, currency, display, opts, overrideLocale) => {\r\n        const o = { ...options.value, ...unwrap(opts) };\r\n        const c = unwrap(currency) || o.currency;\r\n        const d = unwrap(display) || o.currencyDisplay;\r\n        // istanbul ignore else\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            if (!c) {\r\n                console.error(\"[useCurrencyFormat] No currency provided.\");\r\n                return \"\";\r\n            }\r\n            if (o.style !== \"currency\") {\r\n                console.warn(\"[useCurrencyFormat] invalid style passed in options, please leave it undefined.\");\r\n            }\r\n        }\r\n        return numberFormat.formatString(amount, {\r\n            ...o,\r\n            currency: c,\r\n            currencyDisplay: d\r\n        }, overrideLocale);\r\n    };\r\n    const format = (amount, currency, display, opts, overrideLocale) => {\r\n        return computed(() => formatString(amount, currency, display, opts, overrideLocale));\r\n    };\r\n    return {\r\n        format,\r\n        formatString\r\n    };\r\n}\n\nfunction getBreakpointWidth(bp) {\r\n    if (!bp)\r\n        return undefined;\r\n    if (isNumber(bp))\r\n        return bp;\r\n    return isValidWidthBreakpoint(bp);\r\n}\r\nconst isValidWidthBreakpoint = (bp) => {\r\n    const m = bp.match(/^(\\d+)px$/);\r\n    if (m) {\r\n        return +m[1];\r\n    }\r\n    return undefined;\r\n};\r\nfunction useBreakpoint(breakpoints) {\r\n    const result = {};\r\n    const map = new Map();\r\n    const current = ref();\r\n    let sorted = [];\r\n    const removeMedia = [];\r\n    for (const key in breakpoints) {\r\n        const bp = breakpoints[key];\r\n        const width = getBreakpointWidth(bp);\r\n        if (width !== undefined) {\r\n            const r = ref(false);\r\n            result[key] = r;\r\n            map.set(width, {\r\n                name: key,\r\n                valid: r\r\n            });\r\n            sorted.push(width);\r\n        }\r\n        else {\r\n            const { matches, remove } = useMatchMedia(bp);\r\n            result[key] = matches;\r\n            removeMedia.push(remove);\r\n        }\r\n    }\r\n    sorted = sorted.sort((a, b) => b - a);\r\n    const resize = isClient\r\n        ? () => {\r\n            const width = window.innerWidth;\r\n            let c = undefined;\r\n            for (let i = 0; i < sorted.length; i++) {\r\n                const bp = sorted[i];\r\n                const r = map.get(bp);\r\n                r.valid.value = width >= bp;\r\n                if (width >= bp && c === undefined) {\r\n                    c = r.name;\r\n                }\r\n            }\r\n            current.value = c;\r\n        }\r\n        : NO_OP;\r\n    const processResize = useDebounce(resize, 10);\r\n    const remove = isClient\r\n        ? () => window.removeEventListener(\"resize\", processResize)\r\n        : NO_OP;\r\n    if (isClient) {\r\n        onMounted(() => {\r\n            resize();\r\n            window.addEventListener(\"resize\", processResize, PASSIVE_EV);\r\n        });\r\n        onUnmounted(() => {\r\n            remove();\r\n            removeMedia.forEach(x => x());\r\n        });\r\n    }\r\n    return {\r\n        ...result,\r\n        remove,\r\n        current\r\n    };\r\n}\n\nfunction useBreakpointChrome() {\r\n    return useBreakpoint({\r\n        mobileS: 320,\r\n        mobileM: 375,\r\n        mobileL: 425,\r\n        tablet: 768,\r\n        laptop: 1024,\r\n        laptopL: 1440,\r\n        desktop4K: 2560\r\n    });\r\n}\n\n// istanbul ignore next\r\nconst BREAKPOINT_TAILWIND_KEY = Symbol(((process.env.NODE_ENV !== 'production') && \"TAILWIND_BREAKPOINTS\") || ``);\r\nconst defaultTailwindBreakpoint = {\r\n    sm: 640,\r\n    md: 768,\r\n    lg: 1024,\r\n    xl: 1280\r\n};\r\nfunction isTailwind(t) {\r\n    return isObject(t) && isObject(t.theme) && isObject(t.theme.screens);\r\n}\r\nfunction isRawScreen(t) {\r\n    return isObject(t) && isString(t.raw);\r\n}\r\nfunction isRangeScreen(t) {\r\n    if (!isObject(t))\r\n        return false;\r\n    return (isString(t.min) || isString(t.max) || isNumber(t.min) || isNumber(t.max));\r\n}\r\n/**\r\n * Sanitize width value, if number is passed it will append `px`\r\n * @param s width value\r\n */\r\nfunction sanitizeWidth(s) {\r\n    return isNumber(s) ? s + \"px\" : s;\r\n}\r\nfunction screenRangeToBreakpoint(s) {\r\n    if (!isRangeScreen(s)) {\r\n        // istanbul ignore else\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(\"[useBreakpointTailwind] screen range provided is not valid\");\r\n        }\r\n        return \"\";\r\n    }\r\n    const condition = [\r\n        s.max && `max-width: ${sanitizeWidth(s.max)}`,\r\n        s.min && `min-width: ${sanitizeWidth(s.min)}`\r\n    ]\r\n        .filter(Boolean)\r\n        .join(\" and \");\r\n    return `(${condition})`;\r\n}\r\nfunction screenToBreakpoint(s) {\r\n    const conditions = [];\r\n    if (isArray(s)) {\r\n        const bks = s.map(screenToBreakpoint);\r\n        for (let i = 0; i < bks.length; i++) {\r\n            const b = bks[i];\r\n            conditions.push(...b);\r\n        }\r\n    }\r\n    else if (isRawScreen(s)) {\r\n        conditions.push(s.raw);\r\n    }\r\n    else if (isRangeScreen(s)) {\r\n        conditions.push(screenRangeToBreakpoint(s));\r\n    }\r\n    else if (isString(s) || isNumber(s)) {\r\n        conditions.push(`(min-width: ${sanitizeWidth(s)})`);\r\n    }\r\n    else {\r\n        // istanbul ignore else\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(\"[useBreakpointTailwind] unknown type used for the breakpoint`\");\r\n        }\r\n    }\r\n    return conditions;\r\n}\r\nfunction setBreakpointTailwindCSS(breakpoints) {\r\n    const bk = isTailwind(breakpoints) ? breakpoints.theme.screens : breakpoints;\r\n    if (isTailwind(breakpoints)) {\r\n        for (const k in bk) {\r\n            // istanbul ignore else\r\n            if (bk.hasOwnProperty(k)) {\r\n                const v = bk[k];\r\n                if (isObject(v)) {\r\n                    bk[k] = screenToBreakpoint(bk[k]).join(\" or \");\r\n                }\r\n                else if (isString(v)) {\r\n                    if (!v.endsWith(\"px\")) {\r\n                        bk[k] = screenToBreakpoint(bk[k]).join(\" or \");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const bp = useBreakpoint(bk);\r\n    provide(BREAKPOINT_TAILWIND_KEY, bp);\r\n    return bp;\r\n}\r\nfunction useBreakpointTailwindCSS(config) {\r\n    return injectFactory(BREAKPOINT_TAILWIND_KEY, () => setBreakpointTailwindCSS(config || defaultTailwindBreakpoint));\r\n}\n\nconst STORAGE_TEST_KEY = (process.env.NODE_ENV !== 'production') ? \"__storage_test__\" : \":$\";\r\n/* istanbul ignore next */\r\nfunction isQuotaExceededError(e, storage) {\r\n    return (e instanceof DOMException &&\r\n        // everything except Firefox\r\n        (e.code === 22 ||\r\n            // Firefox\r\n            e.code === 1014 ||\r\n            // test name field too, because code might not be present\r\n            // everything except Firefox\r\n            e.name === \"QuotaExceededError\" ||\r\n            // Firefox\r\n            e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") &&\r\n        // acknowledge QuotaExceededError only if there's something already stored\r\n        ((storage && storage.length !== 0) || false));\r\n}\r\n// based on https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API\r\nfunction storageAvailable(storage) {\r\n    try {\r\n        if (!storage) {\r\n            return false;\r\n        }\r\n        const x = STORAGE_TEST_KEY;\r\n        storage.setItem(x, x);\r\n        storage.removeItem(x);\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        return isQuotaExceededError(e, storage);\r\n    }\r\n}\r\nfunction safeParse(serializer, value) {\r\n    try {\r\n        return serializer.parse(value);\r\n    }\r\n    catch {\r\n        return value;\r\n    }\r\n}\r\nlet storageMap = undefined;\r\nfunction useWebStorage(type, serializer = JSON, ms = 10) {\r\n    const storage = isClient ? window[type] : undefined;\r\n    const supported = storageAvailable(storage);\r\n    const remove = () => storageMap.delete(type);\r\n    if (!storageMap) {\r\n        storageMap = new Map();\r\n        if (isClient) {\r\n            window.addEventListener(\"storage\", (e) => {\r\n                if (e.newValue === e.oldValue) {\r\n                    return;\r\n                }\r\n                let webStore = storageMap.get(\"localStorage\");\r\n                if (e.storageArea === window.localStorage) {\r\n                    webStore = storageMap.get(\"localStorage\");\r\n                }\r\n                else {\r\n                    webStore = storageMap.get(\"sessionStorage\");\r\n                }\r\n                if (webStore && Object.keys(webStore.$syncKeys).length > 0) {\r\n                    if (e.key === null) {\r\n                        webStore.clear();\r\n                    }\r\n                    else if (webStore.$syncKeys[e.key]) {\r\n                        if (e.newValue === null) {\r\n                            webStore.removeItem(e.key);\r\n                        }\r\n                        else {\r\n                            webStore.updateItem(e.key, e.newValue);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    let store = storageMap.get(type);\r\n    let quotaError;\r\n    if (supported && storage) {\r\n        if (!store) {\r\n            quotaError = ref(false);\r\n            store = {\r\n                $refMap: new Map(),\r\n                $watchHandlers: new Map(),\r\n                $syncKeys: {},\r\n                $quotaError: quotaError,\r\n                key: storage.key,\r\n                length: storage.length,\r\n                setSync(key, sync) {\r\n                    if (sync) {\r\n                        this.$syncKeys[key] = true;\r\n                    }\r\n                    else {\r\n                        delete this.$syncKeys[key];\r\n                    }\r\n                },\r\n                save(key, value) {\r\n                    try {\r\n                        const oldValue = storage.getItem(key);\r\n                        const data = isString(value) ? value : serializer.stringify(value);\r\n                        storage.setItem(key, data);\r\n                        if (oldValue !== data && isClient && store.$syncKeys[key]) {\r\n                            window.dispatchEvent(new StorageEvent(key, {\r\n                                newValue: data,\r\n                                oldValue,\r\n                                storageArea: storage,\r\n                            }));\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        quotaError.value = isQuotaExceededError(e, storage);\r\n                    }\r\n                },\r\n                clear() {\r\n                    this.$refMap.forEach((_, k) => this.removeItem(k));\r\n                },\r\n                removeItem(k) {\r\n                    const item = this.$refMap.get(k);\r\n                    // remove the object value if item deleted\r\n                    if (item) {\r\n                        item.value = undefined;\r\n                    }\r\n                    // clear the watch\r\n                    const stop = this.$watchHandlers.get(k);\r\n                    if (stop) {\r\n                        stop();\r\n                    }\r\n                    delete this.$syncKeys[k];\r\n                    this.$refMap.delete(k);\r\n                    storage.removeItem(k);\r\n                },\r\n                getItem(k) {\r\n                    /**\r\n                     * NOTE seems if the element who created the `ref` gets destroyed all the watchers assigned will be also disposed\r\n                     * making returning of the cached `ref` invalid\r\n                     */\r\n                    const data = storage.getItem(k);\r\n                    if (!data) {\r\n                        return null;\r\n                    }\r\n                    return this.setItem(k, safeParse(serializer, data));\r\n                },\r\n                getRef(k) {\r\n                    const item = ref();\r\n                    let keyWatch = watch(wrap(k), (k) => {\r\n                        const data = storage.getItem(k);\r\n                        if (!data) {\r\n                            return (item.value = null);\r\n                        }\r\n                        item.value = safeParse(serializer, data);\r\n                    }, {\r\n                        immediate: true,\r\n                        flush: \"sync\",\r\n                    });\r\n                    let valueWatch = watch(item, debounce((i) => {\r\n                        this.save(unwrap(k), i);\r\n                    }, ms), { deep: true, flush: \"sync\" });\r\n                    // used to reference to this ref, since `k` change change we need to generate one\r\n                    const fakeKey = Math.random().toString();\r\n                    this.$watchHandlers.set(fakeKey, () => {\r\n                        keyWatch();\r\n                        valueWatch();\r\n                    });\r\n                    this.$refMap.set(fakeKey, item);\r\n                    return item;\r\n                },\r\n                setItem(k, v) {\r\n                    const reference = wrap(v);\r\n                    this.$refMap.set(k, reference);\r\n                    this.save(k, v);\r\n                    // @ts-ignore\r\n                    const stop = watch(reference, debounce((r) => {\r\n                        this.save(k, r);\r\n                    }, ms), {\r\n                        immediate: false,\r\n                        deep: true,\r\n                    });\r\n                    this.$watchHandlers.set(k, stop);\r\n                    return reference;\r\n                },\r\n                updateItem(k, data) {\r\n                    let r = this.$refMap.get(k);\r\n                    if (r) {\r\n                        r.value = safeParse(serializer, data);\r\n                    }\r\n                },\r\n            };\r\n            storageMap.set(type, store);\r\n        }\r\n        else {\r\n            quotaError = store.$quotaError;\r\n        }\r\n    }\r\n    else {\r\n        quotaError = ref(false);\r\n        store = {};\r\n    }\r\n    return {\r\n        supported,\r\n        quotaError,\r\n        store,\r\n        remove,\r\n    };\r\n}\n\nfunction useLocalStorage(key, defaultValue, sync) {\r\n    const { supported, store } = useWebStorage(\"localStorage\");\r\n    let remove = NO_OP;\r\n    let clear = NO_OP;\r\n    let setSync = NO_OP;\r\n    let storage = undefined;\r\n    if (supported && store) {\r\n        setSync = (s) => store.setSync(unwrap(key), s);\r\n        remove = () => store.removeItem(unwrap(key));\r\n        clear = () => store.clear();\r\n        storage = store.getRef(key);\r\n        if (storage.value == null) {\r\n            store.save(unwrap(key), defaultValue);\r\n            storage.value = defaultValue;\r\n        }\r\n        watchEffect(() => {\r\n            if (sync !== false) {\r\n                setSync(true);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(\"[localStorage] is not available\");\r\n        }\r\n        storage = ref(defaultValue);\r\n    }\r\n    return {\r\n        supported,\r\n        storage,\r\n        clear,\r\n        remove,\r\n        setSync,\r\n    };\r\n}\n\nfunction useSessionStorage(key, defaultValue, sync) {\r\n    const { supported, store } = useWebStorage(\"sessionStorage\");\r\n    let remove = NO_OP;\r\n    let clear = NO_OP;\r\n    let setSync = FALSE_OP;\r\n    let storage = undefined;\r\n    if (supported && store) {\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            setSync = () => console.warn(\"sync is not supported, please `useLocalStorage` instead\");\r\n            if (sync) {\r\n                setSync(sync);\r\n            }\r\n        }\r\n        remove = () => store.removeItem(unwrap(key));\r\n        clear = () => store.clear();\r\n        storage = store.getRef(key);\r\n        if (storage.value == null) {\r\n            store.save(unwrap(key), defaultValue);\r\n            storage.value = defaultValue;\r\n        }\r\n    }\r\n    else {\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(\"[sessionStorage] is not available\");\r\n        }\r\n        storage = ref(defaultValue);\r\n    }\r\n    return {\r\n        supported,\r\n        storage,\r\n        clear,\r\n        remove,\r\n        setSync,\r\n    };\r\n}\n\nlet canUseLocalStorage = undefined;\r\nfunction useStorage(key, defaultValue, sync) {\r\n    if (canUseLocalStorage === undefined) {\r\n        canUseLocalStorage = useWebStorage(\"localStorage\").supported;\r\n    }\r\n    return canUseLocalStorage\r\n        ? useLocalStorage(key, defaultValue, sync)\r\n        : useSessionStorage(key, defaultValue, sync);\r\n}\n\n/**\r\n * Create a pagination controller based on the arguments\r\n * @param options -\r\n */\r\nfunction usePagination(options) {\r\n    const _currentPage = wrap(options.currentPage);\r\n    const _pageSize = wrap(options.pageSize);\r\n    const _offset = ref(0);\r\n    const total = wrap(options.total);\r\n    const offset = computed({\r\n        get() {\r\n            return _offset.value;\r\n        },\r\n        set(v) {\r\n            if (!isNumber(v)) {\r\n                /* istanbul ignore else */\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    console.warn(`[offset] expected number but got: '${typeof v}' value: '${v}'`);\r\n                }\r\n                return;\r\n            }\r\n            _offset.value = Math.min(v, total.value);\r\n        }\r\n    });\r\n    const currentPage = computed({\r\n        get() {\r\n            return _currentPage.value;\r\n        },\r\n        set(v) {\r\n            if (!isNumber(v)) {\r\n                /* istanbul ignore else  */\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    console.warn(`[currentPage] expected number but got: '${typeof v}' value: '${v}'`);\r\n                }\r\n                return;\r\n            }\r\n            _currentPage.value = minMax(v, 1, lastPage.value);\r\n            // set the offset\r\n            offset.value = (_currentPage.value - 1) * pageSize.value;\r\n        }\r\n    });\r\n    const pageSize = computed({\r\n        get() {\r\n            return _pageSize.value;\r\n        },\r\n        set(v) {\r\n            if (!isNumber(v)) {\r\n                /* istanbul ignore else */\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    console.warn(`[pageSize] expected number but got: '${typeof v}' value: '${v}'`);\r\n                }\r\n                return;\r\n            }\r\n            _pageSize.value = v;\r\n        }\r\n    });\r\n    const lastPage = computed(() => Math.ceil(total.value / pageSize.value));\r\n    // make sure the current page is the correct value\r\n    currentPage.value = _currentPage.value;\r\n    const prev = () => --currentPage.value;\r\n    const next = () => ++currentPage.value;\r\n    const first = () => (currentPage.value = 1);\r\n    const last = () => (currentPage.value = lastPage.value);\r\n    watch([total, pageSize], _ => {\r\n        if (currentPage.value > lastPage.value) {\r\n            currentPage.value = lastPage.value;\r\n        }\r\n    }, { immediate: false } // no need to run on first render\r\n    );\r\n    return {\r\n        // Mutable state\r\n        pageSize,\r\n        total,\r\n        currentPage,\r\n        offset,\r\n        // Computed\r\n        lastPage,\r\n        // Functions\r\n        next,\r\n        prev,\r\n        first,\r\n        last\r\n    };\r\n}\n\nfunction useArrayPagination(array, options) {\r\n    const arrayRef = wrap(array);\r\n    const pagination = usePagination({\r\n        ...{\r\n            currentPage: 1,\r\n            pageSize: 10\r\n        },\r\n        ...options,\r\n        total: computed(() => arrayRef.value.length)\r\n    });\r\n    const result = computed(() => {\r\n        const array = arrayRef.value;\r\n        if (!Array.isArray(array))\r\n            return [];\r\n        return array.slice(pagination.offset.value, pagination.offset.value + pagination.pageSize.value);\r\n    });\r\n    return {\r\n        ...pagination,\r\n        result\r\n    };\r\n}\n\n/**\r\n * Reactive custom timer with specified refresh rate\r\n * @param options - Configuration\r\n */\r\nfunction useNow(options) {\r\n    const SYNC_MS = 1000;\r\n    const ms = (options && options.refreshMs) || SYNC_MS;\r\n    const sync = options && isBoolean(options.sync) ? options.sync : true;\r\n    const fn = (options && isFunction(options.timeFn) && options.timeFn) || Date.now;\r\n    /* istanbul ignore else */\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        if (options && options.timeFn && isFunction(options.timeFn) === false) {\r\n            console.warn(\"[useNow] timeFn param must be Function\");\r\n        }\r\n    }\r\n    let handler = undefined;\r\n    let timeoutHandler = undefined;\r\n    const now = ref(fn());\r\n    const remove = () => {\r\n        clearInterval(handler);\r\n        clearTimeout(timeoutHandler);\r\n    };\r\n    /* istanbul ignore next */\r\n    const start = isClient\r\n        ? () => (handler = setInterval(() => (now.value = fn()), ms))\r\n        : NO_OP;\r\n    if (sync) {\r\n        const offset = SYNC_MS - (now.value - Math.floor(now.value / SYNC_MS) * SYNC_MS);\r\n        timeoutHandler = setTimeout(start, offset);\r\n    }\r\n    else {\r\n        start();\r\n    }\r\n    onUnmounted(remove);\r\n    return {\r\n        now,\r\n        remove\r\n    };\r\n}\n\n/**\r\n * Reactive `Date.now()` with specified refresh rate\r\n * @param options - Configuration\r\n */\r\nfunction useDateNow(options) {\r\n    const refreshMs = (options && options.refreshMs) || 1000;\r\n    const sync = options && isBoolean(options.sync) ? options.sync : true;\r\n    return useNow({\r\n        refreshMs,\r\n        sync,\r\n        timeFn: Date.now\r\n    });\r\n}\n\n/**\r\n * Reactive `performance.now()` with specified refresh rate\r\n * @param options - Configuration\r\n */\r\nfunction usePerformanceNow(options) {\r\n    const refreshMs = (options && options.refreshMs) || 1000;\r\n    const sync = options && isBoolean(options.sync) ? options.sync : true;\r\n    return useNow({\r\n        refreshMs,\r\n        sync,\r\n        timeFn: () => performance.now()\r\n    });\r\n}\n\nfunction useFormat(format, args) {\r\n    return computed(() => {\r\n        const f = unwrap(format);\r\n        if (!args) {\r\n            return f;\r\n        }\r\n        const r = isRef(args) ? reactive(args.value) : reactive(args);\r\n        const regEx = /({?{[\\w\\s]*}?})/g;\r\n        return f.replace(regEx, s => {\r\n            const k = s\r\n                .replace(\"{\", \"\")\r\n                .replace(\"}\", \"\")\r\n                .trim();\r\n            // ignore if {{ }}\r\n            if (s[0] === s[1] && s[0] === \"{\") {\r\n                return `${k}`;\r\n            }\r\n            const v = isArray(r) ? r[+k] : r[k];\r\n            return v === undefined ? s : `${unwrap(v)}`;\r\n        });\r\n    });\r\n}\n\n/**\r\n * Retrieve object value based on string path\r\n * @param source - Source object to retrieve path\r\n * @param path - string path to value\r\n * @param separator - path separator, default '.'\r\n * @param notFoundReturn - not found handler\r\n */\r\nfunction usePath(source, path, separator = \".\", notFoundReturn = NO_OP) {\r\n    return computed(() => {\r\n        const s = unwrap(source);\r\n        const p = unwrap(path);\r\n        if (s === undefined)\r\n            return notFoundReturn(p, s, p, s);\r\n        if (!p) {\r\n            return s;\r\n        }\r\n        const fragments = p.split(separator);\r\n        let c = s;\r\n        for (let i = 0; i < fragments.length; i++) {\r\n            let fragmentPath = fragments[i];\r\n            if (fragmentPath[fragmentPath.length - 1] === \"]\") {\r\n                const r = /\\[[`'\"]?([^`'\"\\]]*)[`'\"]?\\]/g;\r\n                let path = fragmentPath;\r\n                let m = r.exec(path);\r\n                if (m) {\r\n                    let lastLen = m[0].length;\r\n                    let lastIndex = m.index - lastLen;\r\n                    let mi = 1;\r\n                    do {\r\n                        if (lastIndex + lastLen !== m.index) {\r\n                            // istanbul ignore else\r\n                            if ((process.env.NODE_ENV !== 'production')) {\r\n                                console.warn(`[usePath] invalid path \"${fragments[i]}\"`);\r\n                            }\r\n                        }\r\n                        lastIndex = m.index;\r\n                        lastLen = m[0].length;\r\n                        fragmentPath = fragmentPath.slice(0, -m[0].length);\r\n                        fragments.splice(i + mi, 0, m[1]);\r\n                        ++mi;\r\n                    } while ((m = r.exec(path)));\r\n                    // if the fragmentPath is empty, eg: [1][1]\r\n                    // we should continue until the next path\r\n                    if (!fragmentPath && path[0] === \"[\" && path.length > 2) {\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    fragmentPath = \"\";\r\n                    console.warn(`[usePath] invalid path provided \"${path}\"`);\r\n                }\r\n            }\r\n            if (isObject(c)) {\r\n                if (!fragmentPath) {\r\n                    // istanbul ignore else\r\n                    if ((process.env.NODE_ENV !== 'production')) {\r\n                        console.warn(`Path \"${fragments\r\n                            .slice(0, i + 1)\r\n                            .join(separator)}\" doesn't exist on:`, source);\r\n                    }\r\n                    return notFoundReturn(fragments.slice(0, i + 1).join(separator), c, p, s);\r\n                }\r\n                c = c[fragmentPath];\r\n            }\r\n            else {\r\n                // istanbul ignore else\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    console.warn(`Path \"${fragments\r\n                        .slice(0, i + 1)\r\n                        .join(separator)}\" doesn't exist on:`, source);\r\n                }\r\n                return notFoundReturn(fragments.slice(0, i + 1).join(separator), c, p, s);\r\n            }\r\n            if (!c) {\r\n                // istanbul ignore else\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    console.warn(`Path \"${fragments\r\n                        .slice(0, i + 1)\r\n                        .join(separator)}\" doesn't exist on:`, source);\r\n                }\r\n                return notFoundReturn(fragments.slice(0, i + 1).join(separator), c, p, s);\r\n            }\r\n        }\r\n        return c;\r\n    });\r\n}\n\n/* /Output */\r\nfunction isValidation(v) {\r\n    return typeof v.$value !== \"undefined\";\r\n}\r\nfunction isValidatorObject(v) {\r\n    return isObject(v);\r\n}\r\nconst buildValidationFunction = (r, f, m, handlers) => {\r\n    const $promise = ref(null);\r\n    const $pending = ref(false);\r\n    const $error = ref();\r\n    const $invalid = ref(false);\r\n    let context = undefined;\r\n    const onChange = (r) => {\r\n        const p = async () => {\r\n            try {\r\n                $pending.value = true;\r\n                const result = f(r, context);\r\n                if (isPromise(result)) {\r\n                    $invalid.value = !(await result);\r\n                }\r\n                else {\r\n                    $invalid.value = !result;\r\n                }\r\n                // @ts-ignore\r\n                $error.value = $invalid.value ? m.value || true : undefined;\r\n            }\r\n            catch (e) {\r\n                $invalid.value = true;\r\n                throw e;\r\n            }\r\n            finally {\r\n                $pending.value = false;\r\n            }\r\n        };\r\n        $promise.value = p().catch((x) => {\r\n            $error.value = unwrap(x);\r\n            $invalid.value = true;\r\n            return x;\r\n        });\r\n    };\r\n    handlers.push((ctx) => {\r\n        context = ctx;\r\n        watch(() => {\r\n            try {\r\n                // keep track on the external dependencies\r\n                f(r.value, context);\r\n            }\r\n            catch (e) {\r\n                // ignore error\r\n            }\r\n            return r.value;\r\n        }, onChange, { deep: true, immediate: true });\r\n    });\r\n    function $touch() {\r\n        onChange(r.value);\r\n    }\r\n    return {\r\n        $promise,\r\n        $pending,\r\n        $invalid,\r\n        $error,\r\n        $touch,\r\n    };\r\n};\r\nconst buildValidationValue = (r, v, handlers) => {\r\n    const { $message, $validator, ...$rest } = isValidatorObject(v)\r\n        ? v\r\n        : { $validator: v, $message: undefined };\r\n    const { $pending, $promise, $invalid, $error, $touch, } = buildValidationFunction(r, $validator, ref($message), handlers);\r\n    return {\r\n        $pending,\r\n        $error,\r\n        $promise,\r\n        $invalid,\r\n        $message,\r\n        $touch,\r\n        ...$rest,\r\n    };\r\n};\r\nconst buildValidation = (o, handlers) => {\r\n    const r = {};\r\n    const $value = isValidation(o) ? wrap(o.$value) : undefined;\r\n    for (const k of Object.keys(o)) {\r\n        if (k[0] === \"$\") {\r\n            if (k === \"$value\") {\r\n                r[k] = $value;\r\n                const $dirty = ref(false);\r\n                let dirtyWatch = NO_OP;\r\n                const createDirtyWatcher = () => {\r\n                    dirtyWatch();\r\n                    dirtyWatch = watch($value, () => {\r\n                        $dirty.value = true;\r\n                        dirtyWatch();\r\n                    }, { immediate: false, deep: true });\r\n                };\r\n                createDirtyWatcher();\r\n                r[\"$dirty\"] = $dirty;\r\n                r[\"$reset\"] = () => {\r\n                    $dirty.value = false;\r\n                    createDirtyWatcher();\r\n                };\r\n                r[\"$touch\"] = () => ($dirty.value = true);\r\n                // @ts-ignore\r\n                r.toObject = () => unwrap($value);\r\n                continue;\r\n            }\r\n            else {\r\n                r[k] = o[k];\r\n                continue;\r\n            }\r\n        }\r\n        if ($value) {\r\n            const validation = buildValidationValue($value, o[k], handlers);\r\n            // @ts-expect-error no valid type\r\n            r[k] = validation;\r\n        }\r\n        else {\r\n            const validation = buildValidation(o[k], handlers);\r\n            let $anyDirty = undefined;\r\n            let $errors;\r\n            let $anyInvalid;\r\n            let toObject = NO_OP;\r\n            if (isValidation(validation)) {\r\n                const validations = Object.keys(validation)\r\n                    .filter((x) => x[0] !== \"$\")\r\n                    .map((x) => validation[x]);\r\n                $errors = computed(() => validations\r\n                    .map((x) => x.$error)\r\n                    .map((x) => unwrap(x))\r\n                    .filter((x) => x !== undefined));\r\n                // $anyDirty = computed(() => validations.some(x => !!x));\r\n                $anyInvalid = computed(() => validations.some((x) => {\r\n                    return !!unwrap(x.$invalid);\r\n                }));\r\n                toObject = () => {\r\n                    return Object.keys(validation)\r\n                        .filter((x) => x[0] !== \"$\")\r\n                        .reduce((p, c) => {\r\n                        //@ts-ignore\r\n                        p[c] = validation[c].toObject();\r\n                        return p;\r\n                    }, {});\r\n                };\r\n            }\r\n            else {\r\n                const validations = Object.keys(validation).map((x) => validation[x]);\r\n                $errors = computed(() => {\r\n                    return validations\r\n                        .map((x) => unwrap(x.$errors))\r\n                        .filter((x) => x !== undefined)\r\n                        .filter((x) => {\r\n                        return x.some(Boolean);\r\n                    });\r\n                });\r\n                $anyDirty = computed(() => {\r\n                    return validations.some((x) => {\r\n                        return (unwrap(x.$anyDirty) ||\r\n                            (isBoolean(unwrap(x.$dirty)) &&\r\n                                unwrap(x.$dirty)));\r\n                    });\r\n                });\r\n                $anyInvalid = computed(() => validations.some((x) => {\r\n                    return !!unwrap(x.$anyInvalid);\r\n                }));\r\n                toObject = () => {\r\n                    return Object.keys(validation)\r\n                        .filter((x) => x[0] !== \"$\")\r\n                        .reduce((p, c) => {\r\n                        //@ts-ignore\r\n                        p[c] = validation[c].toObject();\r\n                        return p;\r\n                    }, {});\r\n                };\r\n            }\r\n            r[k] = {\r\n                toObject,\r\n                ...validation,\r\n                $errors,\r\n                $anyInvalid,\r\n            };\r\n            if ($anyDirty) {\r\n                r[k].$anyDirty = $anyDirty;\r\n                const keys = Object.keys(r[k]).filter((x) => x[0] !== \"$\" && isObject(r[k][x]));\r\n                r[k].$touch = () => {\r\n                    // r[k].\r\n                    keys.forEach((m) => {\r\n                        const touch = r[k][m].$touch;\r\n                        if (touch) {\r\n                            touch();\r\n                        }\r\n                    });\r\n                };\r\n                r[k].$reset = () => {\r\n                    keys.forEach((m) => {\r\n                        const reset = r[k][m].$reset;\r\n                        if (reset) {\r\n                            reset();\r\n                        }\r\n                    });\r\n                };\r\n            }\r\n        }\r\n    }\r\n    return r;\r\n};\r\nfunction useValidation(input) {\r\n    const handlers = [];\r\n    const validation = buildValidation({ input }, handlers);\r\n    // convert to reactive, this will make it annoying to deconstruct, but\r\n    // allows to use it directly on the render template without `.value`\r\n    // https://github.com/vuejs/vue-next/pull/738\r\n    // @ts-expect-error TODO check this error\r\n    const validationInput = reactive(validation.input);\r\n    // set the context, this will allow to use this object as the second\r\n    // argument when calling validators\r\n    handlers.forEach((x) => x(validationInput));\r\n    return validationInput;\r\n}\n\n// istanbul ignore next\r\n// Symbol used to inject/provide the i18n values\r\nconst I18n_ACCESS_SYMBOL = Symbol(((process.env.NODE_ENV !== 'production') && \"I18n\") || ``);\r\nfunction useI18n(definition) {\r\n    if (definition) {\r\n        return setI18n(definition);\r\n    }\r\n    else\r\n        return inject(I18n_ACCESS_SYMBOL);\r\n}\r\n/**\r\n * Builds i18n object based on the definition\r\n * @param definition - i18n definition\r\n */\r\nfunction buildI18n(definition) {\r\n    const locales = ref(Object.keys(definition.messages));\r\n    const localeMessages = ref(definition.messages);\r\n    const locale = ref(definition.locale);\r\n    const i18n = ref({});\r\n    let fallback = ref();\r\n    const cache = {};\r\n    const retrieveLocaleValue = (x) => {\r\n        return (\"__esModule\" in x || x[Symbol.toStringTag] === \"Module\") &&\r\n            \"default\" in x\r\n            ? x.default\r\n            : x;\r\n    };\r\n    const loadLocale = (locale, messages) => {\r\n        if (cache[locale]) {\r\n            return cache[locale];\r\n        }\r\n        const l = messages.value[locale];\r\n        if (!l) {\r\n            return ref({});\r\n        }\r\n        let m = isFunction(l) ? l() : l;\r\n        if (isPromise(m)) {\r\n            return m.then((x) => {\r\n                return (cache[locale] = wrap(retrieveLocaleValue(x)));\r\n            });\r\n        }\r\n        // if it was function we don't keep track on that\r\n        if (isFunction(l)) {\r\n            // return wrap(m)\r\n            return wrap(retrieveLocaleValue(m));\r\n        }\r\n        return (cache[locale] = computed(() => retrieveLocaleValue(messages.value[locale])));\r\n    };\r\n    const shouldFallback = definition.fallback\r\n        ? isBoolean(definition.notFoundFallback)\r\n            ? definition.notFoundFallback\r\n            : true\r\n        : false;\r\n    let fallbackIsPromise = false;\r\n    if (shouldFallback) {\r\n        const fallbackI18n = loadLocale(definition.fallback, localeMessages);\r\n        if (isPromise(fallbackI18n)) {\r\n            fallbackI18n.then((x) => {\r\n                fallback.value = x.value;\r\n            });\r\n            fallbackIsPromise = true;\r\n        }\r\n        else {\r\n            fallback.value = fallbackI18n.value;\r\n        }\r\n    }\r\n    else {\r\n        fallback.value = {};\r\n    }\r\n    const localeChangesCount = ref(0);\r\n    watch(localeMessages, () => localeChangesCount.value++, {\r\n        deep: true,\r\n        immediate: false,\r\n    });\r\n    watch([locale, fallback, localeChangesCount], ([l, fb, _]) => {\r\n        if (l === definition.fallback && shouldFallback) {\r\n            i18n.value = fb;\r\n        }\r\n        else {\r\n            const setI18n = (v) => (i18n.value = deepClone({}, fb, unwrap(v)));\r\n            // const localeMessage = await loadLocale(l as string, localeMessages);\r\n            // i18n.value = deepClone<any>({}, fb, localeMessage.value);\r\n            const r = loadLocale(l, localeMessages);\r\n            if (isPromise(r)) {\r\n                r.then(setI18n);\r\n            }\r\n            else {\r\n                setI18n(r);\r\n            }\r\n        }\r\n    }, {\r\n        immediate: !fallbackIsPromise,\r\n    });\r\n    const $t = (path, args) => {\r\n        if (definition.resolve) {\r\n            return wrap(definition.resolve(i18n.value, path, args));\r\n        }\r\n        return useFormat(usePath(i18n, path, \".\", (_, _1, p, _2) => p), args);\r\n    };\r\n    const $ts = (path, args) => {\r\n        return $t(path, args).value;\r\n    };\r\n    const addLocale = (l, m) => {\r\n        if (locales.value.indexOf(l) >= 0) {\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                console.warn(`[useI18n] Locale \"${l}\" already exists, overriding it...`);\r\n            }\r\n        }\r\n        else {\r\n            locales.value.push(l);\r\n        }\r\n        delete cache[l];\r\n        // istanbul ignore if\r\n        {\r\n            localeMessages.value[l] = m;\r\n        }\r\n    };\r\n    const removeLocale = (l) => {\r\n        const index = locales.value.indexOf(l);\r\n        if (index >= 0) {\r\n            const nextLocale = [\r\n                locale.value,\r\n                fallback.value && definition.fallback,\r\n                ...locales.value,\r\n            ].find((x) => x && x !== l);\r\n            if (nextLocale) {\r\n                if (l === definition.fallback) {\r\n                    /* istanbul ignore else */\r\n                    if ((process.env.NODE_ENV !== 'production')) {\r\n                        console.warn(`[useI18n] removing default fallback locale \"${l}\"`);\r\n                    }\r\n                    fallback.value = undefined;\r\n                }\r\n                if (l === locale.value) {\r\n                    /* istanbul ignore else */\r\n                    if ((process.env.NODE_ENV !== 'production')) {\r\n                        console.warn(`[useI18n] removing current locale \"${l}\", setting current locale to \"${nextLocale}\"`);\r\n                    }\r\n                    locale.value = nextLocale;\r\n                }\r\n            }\r\n            else {\r\n                /* istanbul ignore else */\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    console.error(\"[useI18n] No locales available to use\");\r\n                }\r\n            }\r\n            locales.value.splice(index, 1);\r\n        }\r\n        else {\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                console.warn(`[useI18n] Locale \"${l}\" doesn't exist`);\r\n            }\r\n        }\r\n        // istanbul ignore else\r\n        {\r\n            delete localeMessages.value[l];\r\n        }\r\n        delete cache[l];\r\n    };\r\n    return {\r\n        locale,\r\n        locales,\r\n        i18n,\r\n        $t,\r\n        $ts,\r\n        addLocale,\r\n        removeLocale,\r\n    };\r\n}\r\n/**\r\n * Build and provide i18n definition\r\n * @param definition - I18N definition\r\n */\r\nfunction setI18n(definition) {\r\n    const r = buildI18n(definition);\r\n    provide(I18n_ACCESS_SYMBOL, r);\r\n    return r;\r\n}\n\n// istanbul ignore next\r\nconst SSR_TITLE_KEY = Symbol(((process.env.NODE_ENV !== 'production') && \"SSR_TITLE_KEY\") || ``);\r\nfunction provideSSRTitle(app, title) {\r\n    const r = wrap(title === undefined ? \"\" : title);\r\n    app.provide(SSR_TITLE_KEY, r);\r\n    return r;\r\n}\r\nfunction useSSRTitle(defaultTitle) {\r\n    const s = Symbol();\r\n    const title = inject(SSR_TITLE_KEY, s);\r\n    // @ts-ignore check if it exists\r\n    if (title === s) {\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(\"[useSSRTitle] can't find SSRTitle have you forgotten calling `provideSSRTitle`?\");\r\n        }\r\n        // istanbul ignore next\r\n        return ref(isString(defaultTitle) ? defaultTitle : \"\");\r\n    }\r\n    if (title === undefined) {\r\n        // probably not in `setup()`\r\n        // istanbul ignore next\r\n        return ref(isString(defaultTitle) ? defaultTitle : \"\");\r\n    }\r\n    if (isString(defaultTitle)) {\r\n        title.value = defaultTitle;\r\n    }\r\n    return title;\r\n}\r\nfunction useTitle(overrideTitle = null) {\r\n    if (((globalThis.import ? globalThis.import.meta.env.SSR : process.env.SSR )) && !isClient) {\r\n        return useSSRTitle(overrideTitle);\r\n    }\r\n    const title = ref(isString(overrideTitle) ? overrideTitle : document.title);\r\n    const observer = new MutationObserver(m => {\r\n        title.value = m[0].target.textContent;\r\n    });\r\n    watch(title, (t, o) => {\r\n        if (isString(t) && t !== o) {\r\n            document.title = t;\r\n        }\r\n    }, {\r\n        immediate: true,\r\n        flush: \"sync\"\r\n    });\r\n    const titleElement = document.querySelector(\"title\");\r\n    observer.observe(titleElement, { childList: true });\r\n    onUnmounted(() => observer.disconnect());\r\n    return title;\r\n}\n\n// istanbul ignore next\r\nconst HYDRATION_KEY = Symbol(((process.env.NODE_ENV !== 'production') && \"VUE_COMPOSABLE_HYDRATION_KEY\") || ``);\r\nconst hydrationPlugin = {\r\n    // @ts-ignore\r\n    install(app) {\r\n        const hydrating = ref(true);\r\n        const h = readonly(hydrating);\r\n        {\r\n            // @ts-ignore\r\n            app._context.provides[HYDRATION_KEY] = h;\r\n            const appMount = app.mount;\r\n            app.mount = (...args) => {\r\n                const component = appMount(...args);\r\n                hydrating.value = false;\r\n                return component;\r\n            };\r\n        }\r\n    }\r\n};\r\nfunction useHydration() {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const s = Symbol();\r\n        const r = inject(HYDRATION_KEY, s);\r\n        if (r === s) {\r\n            console.warn(\"[useHydration] no hydration found, did you forget to `app.use(HydrationPlugin)`?\");\r\n        }\r\n    }\r\n    return inject(HYDRATION_KEY, computed(() => false));\r\n}\n\nfunction useValueSync(main, args) {\r\n    const master = wrap(main);\r\n    const list = arguments.length === 2\r\n        ? isRef(arguments[1]) && isArray(arguments[1].value)\r\n            ? arguments[1]\r\n            : ref([wrap(arguments[1])])\r\n        : ref(Array.from(arguments)\r\n            .slice(1)\r\n            .map(x => wrap(x)));\r\n    list.value.forEach(x => {\r\n        x.value = master.value;\r\n    });\r\n    let lastLen = list.value.length;\r\n    watch([master, list], ([m, list]) => {\r\n        // value added set master\r\n        if (lastLen < list.length) {\r\n            list.forEach(x => {\r\n                if (x.value !== m) {\r\n                    x.value = m;\r\n                }\r\n            });\r\n            return;\r\n        }\r\n        lastLen = list.length;\r\n        for (const v of list) {\r\n            if (v.value !== m) {\r\n                master.value = v.value;\r\n                return;\r\n            }\r\n        }\r\n    }, {\r\n        deep: true\r\n    });\r\n    watch(master, m => {\r\n        list.value.forEach(x => (x.value = m));\r\n    }, {\r\n        deep: true,\r\n        flush: \"sync\"\r\n    });\r\n    return list;\r\n}\n\nfunction useTimeline(value, options) {\r\n    const timeline = ref([]);\r\n    const clone = options && options.clone ? options.clone : (x) => x;\r\n    const maxLength = (options && options.maxLength) || MAX_ARRAY_SIZE;\r\n    watch(value, (_, o) => {\r\n        timeline.value.unshift({\r\n            item: clone(o),\r\n            date: new Date()\r\n        });\r\n        if (timeline.value.length > maxLength) {\r\n            timeline.value.pop();\r\n        }\r\n    }, {\r\n        immediate: false,\r\n        flush: \"sync\",\r\n        // allow options to override defaults\r\n        ...options\r\n    });\r\n    return readonly(timeline);\r\n}\n\nfunction useUndo(defaultValue, options) {\r\n    const current = wrap(defaultValue);\r\n    const timeline = ref([]);\r\n    const position = ref(0);\r\n    const maxLen = (options && options.maxLength) || MAX_ARRAY_SIZE;\r\n    const clone = (options && options.clone) || ((t) => t);\r\n    const prev = computed(() => {\r\n        // hide current\r\n        const p = position.value === 0 ? 1 : position.value;\r\n        return timeline.value.slice(p);\r\n    });\r\n    const next = computed(() => {\r\n        // hide current\r\n        const p = position.value === 0 ? 1 : 0;\r\n        return timeline.value.slice(p, position.value);\r\n    });\r\n    let addTimelineEvent = undefined;\r\n    if ((process.env.NODE_ENV !== 'production') && options && options.devtoolId) {\r\n        const layer = useDevtoolsTimelineLayer(`useUndo:${options.devtoolId}`, options.devtoolId, 0x32a2bf // TODO devtools fix color\r\n        );\r\n        addTimelineEvent = (time, data) => layer.addEvent({\r\n            time,\r\n            data: {\r\n                value: data,\r\n                prev: [...prev.value],\r\n                next: [...next.value],\r\n            },\r\n            meta: {\r\n                prev: [...prev.value],\r\n                next: [...next.value],\r\n            },\r\n        });\r\n    }\r\n    watch(current, (c) => {\r\n        if (timeline.value[position.value] === c) {\r\n            //ignore because is the same value\r\n            return;\r\n        }\r\n        // new value added\r\n        if (position.value > 0) {\r\n            const pos = position.value;\r\n            timeline.value.splice(0, pos);\r\n            // reset position\r\n            position.value = 0;\r\n        }\r\n        if (timeline.value.length > maxLen) {\r\n            timeline.value.pop();\r\n        }\r\n        const v = clone(c);\r\n        timeline.value.unshift(v);\r\n        if (addTimelineEvent) {\r\n            addTimelineEvent(Date.now(), c);\r\n        }\r\n    }, {\r\n        ...options,\r\n        immediate: true,\r\n        flush: \"sync\",\r\n    });\r\n    const undo = (step = 1) => jump(step);\r\n    const redo = (step = 1) => jump(-step);\r\n    const jump = (delta) => {\r\n        const s = Math.sign(delta) <= 0\r\n            ? Math.max(delta, -next.value.length)\r\n            : Math.min(delta, prev.value.length);\r\n        position.value += s;\r\n        current.value = timeline.value[position.value];\r\n        if (addTimelineEvent) {\r\n            addTimelineEvent(Date.now(), clone(current.value));\r\n        }\r\n    };\r\n    return {\r\n        value: current,\r\n        undo,\r\n        redo,\r\n        jump,\r\n        prev,\r\n        next,\r\n    };\r\n}\n\nfunction useMouseDistanceFromElement(el, options, wait) {\r\n    let distance = undefined;\r\n    let remove = NO_OP;\r\n    if (isClient) {\r\n        // @ts-ignore\r\n        const { pageX, pageY, remove: removeMouseEvent } = useOnMouseMove(window, options, wait);\r\n        distance = computed(() => {\r\n            const elem = unwrap(el);\r\n            if (!elem)\r\n                return 0;\r\n            return Math.floor(Math.sqrt(Math.pow(pageX.value - (elem.offsetLeft + elem.clientWidth / 2), 2) +\r\n                Math.pow(pageY.value - (elem.offsetTop + elem.clientHeight / 2), 2)));\r\n        });\r\n        remove = removeMouseEvent;\r\n    }\r\n    else {\r\n        distance = computed(() => -1);\r\n    }\r\n    return {\r\n        distance,\r\n        remove,\r\n    };\r\n}\n\nconst VERSION = \"1.0.0-beta.23\";\r\n// istanbul ignore next\r\nconst VUE_VERSION = \"3\";\r\nconst COMMIT = \"f5d933f\";\n\nexport { COMMIT, FALSE_OP, MAX_ARRAY_SIZE, NO_OP, PASSIVE_EV, SCROLL_LOCK_CLASS, UseDevtoolsApp, VERSION, VUE_VERSION, VueComposableDevtools, buildI18n, debounce, deepClone, exponentialDelay, exposeWorker, getCssVariableFor, getDevtools, hydrationPlugin, injectFactory, isArray, isBoolean, isClient, isDate, isElement, isFunction, isNull, isNumber, isObject, isPromise, isString, isSymbol, isUndefined, minMax, noDelay, promisedTimeout, provideSSRTitle, refDebounced, refShared, setBreakpointTailwindCSS, setCssVariableFor, setDevtools, setI18n, storageAvailable, unwrap, useArrayPagination, useBreakpoint, useBreakpointChrome, useBreakpointTailwindCSS, useBroadcastChannel, useCancellablePromise, useClipboard, useCssVariables, useCurrencyFormat, useDateNow, useDebounce, useDevtoolsComponentState, useDevtoolsInspector, useDevtoolsTimelineLayer, useEvent, useFetch, useFormat, useGeolocation, useHydration, useI18n, useIntersectionObserver, useInterval, useIntlDateTimeFormat, useIntlNumberFormat, useLanguage, useLocalStorage, useLockScroll, useMatchMedia, useMouseDistanceFromElement, useNetworkInformation, useNow, useOnMouseMove, useOnOutsidePress, useOnResize, useOnScroll, useOnline, usePageVisibility, usePagination, usePath, usePerformanceNow, usePromise, usePromiseLazy, useRetry, useSSRTitle, useSessionStorage, useShare, useSharedRef, useStorage, useTimeline, useTimeout, useTitle, useUndo, useVModel, useValidation, useValueSync, useWebSocket, useWebStorage, useWorker, useWorkerFunction, wrap };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,gBAAgB,GAAG;AACf,SAAO,MAAM,KAAK,EAAE,QAAQ;AAAA;AAGhC,cAAc,GAAG;AACb,SAAO,MAAM,KAAK,IAAI,IAAI;AAAA;AAE9B,IAAM,UAAU,MAAM;AACtB,IAAM,aAAa,CAAC,QAAQ,OAAO,QAAQ;AAC3C,IAAM,WAAW,CAAC,QAAQ,OAAO,QAAQ;AACzC,IAAM,WAAW,CAAC,QAAQ,OAAO,QAAQ;AACzC,IAAM,YAAY,CAAC,QAAQ,OAAO,QAAQ;AAC1C,IAAM,cAAc,CAAC,QAAQ,OAAO,QAAQ;AAC5C,IAAM,SAAS,CAAC,QAAQ,QAAQ;AAChC,IAAM,SAAS,CAAC,QAAQ,SAAS,QAAQ,WAAW,IAAI;AACxD,IAAM,WAAW,CAAC,QAAQ,OAAO,QAAQ;AACzC,IAAM,WAAW,CAAC,QAAQ,QAAQ,QAAQ,OAAO,QAAQ;AACzD,IAAM,YAAY,CAAC,QAAQ,SAAS,QAAQ,CAAC,CAAC,IAAI;AAClD,mBAAmB,KAAK;AACpB,SAAO,SAAS,QAAQ,WAAW,IAAI,SAAS,WAAW,IAAI;AAAA;AAEnE,IAAM,QAAQ,MAAM;AAAA;AACpB,IAAM,WAAW,MAAM;AACvB,IAAM,aAAa,EAAE,SAAS;AAC9B,yBAAyB,SAAS;AAC9B,SAAO,IAAI,QAAQ,CAAC,QAAQ;AACxB,eAAW,KAAK;AAAA;AAAA;AAIxB,IAAM,iBAAiB,KAAK,KAAK;AACjC,gBAAgB,KAAK,KAAK,KAAK;AAC3B,MAAI,MAAM;AACN,WAAO;AACX,MAAI,MAAM;AACN,WAAO;AACX,SAAO;AAAA;AAEX,IAAM,WAAW,OAAO,UAAU;AAClC,mBAAmB,WAAW,SAAS;AACnC,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACrC,UAAM,SAAS,QAAQ;AACvB,QAAI,WAAW,UAAa,CAAC,SAAS;AAClC;AACJ,UAAM,OAAO,OAAO,KAAK;AACzB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAClC,YAAM,IAAI,KAAK;AACf,YAAM,IAAI,OAAO,OAAO;AACxB,YAAM,aAAa,OAAO;AAC1B,YAAM,OAAO,OAAO,OAAO;AAC3B,UAAI,OAAO,OAAO,UAAa,eAAe,MAAM;AAChD,eAAO,KAAK,SAAS,KACf,UAAU,OAAO,MAAM,IAAI,KAC3B,OAAO;AAAA;AAAA;AAAA;AAIzB,SAAO;AAAA;AAWX,kBAAkB,IAAI,MAAM,UAAU,SAAS;AAC3C,MAAI,SAAS;AACb,MAAI,IAAI;AACJ,UAAM,UAAU,KAAK;AACrB,UAAM,sBAAsB,CAAC,MAAM,EAAE,oBAAoB,MAAM;AAC/D,UAAM,mBAAmB,CAAC,MAAM,EAAE,iBAAiB,MAAM,UAAU;AACnE,UAAM,cAAc,MAAM,SAAS,CAAC,GAAG,GAAG,YAAY;AAClD,UAAI,GAAG;AACH,yBAAiB;AACjB,gBAAQ,MAAM,oBAAoB;AAAA;AAAA,OAEvC,EAAE,WAAW;AAChB,aAAS,MAAM;AACX,0BAAoB,QAAQ;AAC5B;AAAA;AAAA;AAGR,SAAO;AAAA;AASX,qBAAqB,SAAS,MAAM,SAAS;AACzC,SAAO,SAAS,SAAS,MAAM;AAAA;AAEnC,kBAAkB,MAAM,mBAAmB,IAAI,UAAU;AAAA,EACrD,aAAa;AAAA,GACd;AACC,MAAI;AACJ,SAAO,YAAa,MAAM;AACtB,UAAM,UAAU;AAChB,UAAM,UAAU,WAAY;AACxB,kBAAY;AACZ,UAAI,CAAC,QAAQ,aAAa;AACtB,aAAK,MAAM,SAAS;AAAA;AAAA;AAG5B,UAAM,gBAAgB,QAAQ,eAAe,cAAc;AAC3D,QAAI,cAAc,QAAW;AACzB,mBAAa;AAAA;AAEjB,gBAAY,WAAW,SAAS;AAChC,QAAI,eAAe;AACf,WAAK,MAAM,SAAS;AAAA;AAAA;AAAA;AAKhC,wBAAwB,IAAI,SAAS,MAAM;AACvC,QAAM,SAAS,IAAI;AACnB,QAAM,SAAS,IAAI;AACnB,QAAM,QAAQ,IAAI;AAClB,QAAM,QAAQ,IAAI;AAClB,MAAI,UAAU,CAAC,OAAO;AAClB,WAAO,QAAQ,GAAG;AAClB,WAAO,QAAQ,GAAG;AAClB,UAAM,QAAQ,GAAG;AACjB,UAAM,QAAQ,GAAG;AAAA;AAErB,QAAM,CAAC,cAAc,MAAM,SAAS,WAC9B,CAAC,QAAW,WACZ,CAAC,SAAS;AAChB,MAAI,IAAI;AACJ,cAAU,YAAY,SAAS;AAAA;AAEnC,QAAM,SAAS,SAAS,IAAI,aAAa,SAAS;AAClD,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,qBAAqB,IAAI,SAAS,MAAM;AACpC,QAAM,UAAU,KAAK;AACrB,QAAM,SAAS,IAAI,QAAQ,SAAS,QAAQ,MAAM;AAClD,QAAM,QAAQ,IAAI,QAAQ,SAAS,QAAQ,MAAM;AACjD,MAAI,UAAU,MAAM;AAChB,WAAO,QAAQ,QAAQ,MAAM;AAC7B,UAAM,QAAQ,QAAQ,MAAM;AAAA;AAEhC,QAAM,CAAC,cAAc,MAAM,SAAS,WAC9B,CAAC,QAAW,WACZ,CAAC,SAAS;AAChB,MAAI,IAAI;AACJ,cAAU,YAAY,SAAS;AAAA;AAGnC,QAAM,SAAS,WACT,SAAS,QAAQ,UAAU,SAAS,gBAAgB,cACzB;AACjC,MAAI,MAAM,OAAO,CAAC,GAAG,OAAO;AACxB,cAAU;AAAA;AAEd,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,IAAM,iBAAiB,CAAC,YAAY,YAAY;AAChD,qBAAqB,IAAI,SAAS,MAAM;AACpC,QAAM,iBAAiB,CAAC,QAAO,SAAS,QAAO,UAAU,QAAO,CAAE,WAAU,QAAO,MAAM,SAAQ,CAAC,MAC5F,QACA;AACN,QAAM,UAAU,eAAe,MACzB,KAAK,MACL,IAAK,YAAY,UAAW;AAClC,QAAM,oBAAoB,eAAe,MACnC,UACA,IAAK,YAAY,OAAO,SAAS,oBAAqB;AAC5D,QAAM,YAAY,IAAK,kBAAkB,SAAS,kBAAkB,MAAM,aAAc;AACxF,QAAM,aAAa,IAAK,kBAAkB,SAAS,kBAAkB,MAAM,cAAe;AAC1F,MAAI,UAAU,MAAM;AAChB,cAAU,QAAQ,kBAAkB,MAAM;AAC1C,eAAW,QAAQ,kBAAkB,MAAM;AAAA;AAE/C,QAAM,UAAU,eAAe,OAAO,CAAC,GAAG,MAAM;AAE5C,MAAE,KAAK,IAAI,SAEX,kBAAkB,SAEd,kBAAkB,MAAM,MAExB,kBAAkB,MAAM,GAAG,MAAM,kBAAkB,OAAO;AAC9D,WAAO;AAAA,KACR;AACH,QAAM,cAAc,CAAC,QAAQ,QAAQ,SAAS,EAAE;AAChD,QAAM,eAAe,CAAC,SAAS,QAAQ,SAAS,EAAE;AAClD,QAAM,CAAC,cAAc,MAAM,SAAS,OAAO,CAAC,KACtC,CAAC,YAAY,MACb,SAAS,WACL,CAAC,YAAY,WACb,CAAC,SAAS;AACpB,MAAI,IAAI;AACJ,cAAU,YAAY,SAAS;AAAA;AAEnC,QAAM,cAAc,SAAS,SAAS,UAAU,SAAS;AACzD,QAAM,iBAAiB,MAAM,WAAW,aAAa,EAAE,WAAW;AAClE,QAAM,kBAAkB,MAAM,YAAY,cAAc,EAAE,WAAW;AACrE,QAAM,SAAS,MAAM;AACjB;AACA;AACA;AAAA;AAEJ,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,OACG;AAAA;AAAA;AAIX,IAAM,SAAS,CAAC,aAAa;AAC7B,2BAA2B,IAAI,wBAAwB;AACnD,MAAI,CAAC,UAAU;AACX,WAAO,MAAM;AAAA;AAAA;AAEjB,QAAM,UAAU,KAAK;AACrB,QAAM,UAAU,CAAC,MAAM,QAAQ,SAC3B,CAAC,QAAQ,MAAM,SAAS,EAAE,WAC1B,uBAAuB;AAC3B,QAAM,QAAQ,OAAO,KAAK,OAAK,KAAK,OAAO,SAAS;AACpD,SAAO,SAAS,UAAU,OAAO,SAAS,EAAE,SAAS;AAAA;AAGzD,oBAAoB,IAAI,aAAa;AACjC,MAAI,CAAC,IAAI;AACL,UAAM,IAAI,MAAM,mCAAmC;AAAA;AAEvD,MAAI,OAAO,OAAO,YAAY;AAC1B,UAAM,IAAI,MAAM,+CAA+C,OAAO;AAAA;AAE1E,QAAM,CAAC,MAAM,kBAAkB,UAAU,eACnC,CAAC,aAAa,SACd,SAAS,eACL,CAAC,YAAY,MAAM,YAAY,kBAC/B,CAAC,OAAO;AAClB,QAAM,UAAU,IAAI;AACpB,QAAM,QAAQ,IAAI;AAClB,QAAM,SAAS,IAAI;AACnB,QAAM,UAAU;AAChB,QAAM,OAAO,UAAU,SAAS;AAC5B,YAAQ,QAAQ;AAChB,UAAM,QAAQ;AACd,UAAM,WAAW,QACb,GAAG,WAAW,KAAK,UACnB,KAAK,SAAS,KACd,UAAU,KAAK,KAAK,SAAS,MAC3B,KAAK,KAAK,SAAS,KACnB;AACN,UAAM,iBAAkB,QAAQ,QAAQ,GAAG,GAAG;AAC9C,QAAI;AACA,YAAM,IAAI,MAAM;AAChB,UAAI,QAAQ,UAAU,gBAAgB;AAClC,eAAO,QAAQ;AAAA;AAEnB,aAAO;AAAA,aAEJ,IAAP;AACI,UAAI,MAAM,QAAQ,WAAW,MAAM,iBAAiB;AAChD,cAAM,QAAQ;AACd,eAAO,QAAQ;AAAA;AAEnB,aAAO,WAAW,iBAAiB;AAAA,cAEvC;AACI,UAAI,QAAQ,UAAU,gBAAgB;AAClC,gBAAQ,QAAQ;AAAA;AAAA;AAAA;AAI5B,MAAI,CAAC,MAAM;AAEP,QAAK,MAAwC;AACzC,UAAI,GAAG,SAAS,KACZ,CAAC,UAAU,SAAS,eAAe,YAAY,OAAO,cAAc;AACpE,gBAAQ,KAAK;AAAA;AAAA;AAIrB;AAAA;AAEJ,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,+BAA+B,IAAI,aAAa;AAC5C,QAAM,YAAY,IAAI;AACtB,MAAI,UAAU;AACd,QAAM,SAAS,CAAC,WAAW;AACvB,QAAI,CAAC,SAAS;AAEV,UAAK,MAAwC;AACzC,gBAAQ,KAAK;AAAA;AAEjB;AAAA;AAEJ,YAAQ;AAAA;AAEZ,QAAM,UAAU,CAAC,MAAM,IAAI,QAAQ,CAAC,KAAK,QAAQ;AAC7C,cAAU,QAAQ;AAClB,cAAU,CAAC,WAAW;AAClB,gBAAU,QAAQ;AAClB,UAAI;AAAA;AAER,MAAE,KAAK,KAAK,MAAM;AAAA;AAEtB,QAAM,MAAM,WAAW,IAAI,SAAS,QAAQ,GAAG,GAAG,QAAQ;AAC1D,MAAI,wBACC,EAAC,SAAS,gBAAgB,YAAY,kBAAkB,QAAQ;AACjE,gBAAY,MAAM,WAAW;AAAA;AAEjC,SAAO;AAAA,OACA;AAAA,IACH;AAAA,IACA;AAAA;AAAA;AAIR,IAAM,cAAc;AAEpB,IAAM,cAA4B,OAAmD;AAErF,IAAM,oBAAkC,OAAmD;AAC3F,IAAM,kBAAkB,OAAO,SAAS,SAAS,SAAS,SAAS;AAC/D,QAAM,UAAU,QAAQ,aAAa;AACrC,MAAI,IAAI;AACR,QAAM,aAAa,QAAQ,cAAc,cAAc;AACvD,QAAM,QAAQ,QAAQ,cAAc;AACpC,UAAQ,YAAY,QAAQ;AAC5B,UAAQ,WAAW,QAAQ;AAC3B,UAAQ,UAAU,QAAQ;AAC1B,MAAI,YAAY;AAChB,KAAG;AACC,QAAI,UAAU;AACd,QAAI,SAAS;AACb,QAAI;AACA,QAAE;AACF,UAAI,MAAM;AACN,iBAAS,QAAQ,GAAG;AAAA,aAEnB;AACD,iBAAS;AAAA;AAEb,UAAI,UAAU,SAAS;AACnB,iBAAS,MAAM;AAAA;AAGnB,UAAI,QAAQ,mBAAmB,OAAO;AAClC,eAAO;AAAA;AAEX,gBAAU;AAAA,aAEP,OAAP;AACI,eAAS;AACT,cAAQ,YAAY,MAAM,KAAK;AAAA;AAGnC,QAAI,YAAY,QAAQ,aAAa,OAAO;AACxC,aAAO;AAAA;AAEX,QAAI,SAAS;AACT,cAAQ,WAAW,QAAQ;AAC3B,cAAQ,UAAU,QAAQ;AAC1B,aAAO;AAAA;AAEX,QAAI,KAAK,YAAY;AACjB,cAAQ,WAAW,QAAQ;AAC3B,cAAQ,UAAU,QAAQ;AAC1B,aAAO,QAAQ,OAAO,IAAI,MAAM,kCAAkC;AAAA;AAEtE,YAAQ,WAAW,QAAQ;AAC3B,UAAM,MAAM,KAAK;AACjB,UAAM,WAAW,MAAM;AACvB,UAAM,UAAU,UAAU,YAAY,MAAM,WAAW;AACvD,QAAI,CAAC,UAAU,aAAa,CAAC,CAAC,SAAS;AACnC,UAAI,SAAS,UAAU;AACnB,oBAAY;AAAA,iBAEP,OAAO,UAAU;AACtB,oBAAY,QAAQ;AAAA,aAEnB;AACD,cAAM,IAAI,MAAM,8DAA8D,OAAO;AAAA;AAGzF,UAAI,YAAY,KAAK;AACjB,gBAAQ,UAAU,QAAQ,MAAM;AAAA,aAE/B;AACD,gBAAQ,UAAU,QAAQ;AAC1B,oBAAY,YAAY;AAAA;AAE5B,UAAI,YAAY,GAAG;AACf,cAAM,gBAAgB;AAAA;AAAA;AAI9B,QAAI,QAAQ,mBAAmB,OAAO;AAClC,aAAO;AAAA;AAGX,QAAI,YAAY,QAAQ,aAAa,OAAO;AACxC,aAAO;AAAA;AAAA,WAEN,IAAI;AACb,SAAO;AAAA;AAEX,kBAAkB,SAAS,SAAS;AAChC,QAAM,MAAM,CAAC,WAAW,WAAW,WAAW,KAAK;AACnD,QAAM,KAAK,WAAW,WAAW,UAAU;AAC3C,MAAI,CAAC,WAAW,YAAY,CAAC,SAAS,UAAU;AAC5C,UAAM,IAAI,MAAM;AAAA;AAEpB,MAAI,CAAC,CAAC,MAAM,CAAC,WAAW,KAAK;AACzB,UAAM,IAAI,MAAM;AAAA;AAEpB,QAAM,aAAa,IAAI;AACvB,QAAM,YAAY;AAClB,QAAM,cAAc,IAAI;AACxB,QAAM,oBAAoB,EAAE,OAAO;AACnC,QAAM,UAAU,EAAE,OAAO;AACzB,QAAM,aAAa,SAAS,MAAM,YAAY,MAAM;AACpD,QAAM,UAAU;AAAA,IACZ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,KACC,cAAc;AAAA,KACd,oBAAoB;AAAA;AAEzB,QAAM,OAAO,KACP,IAAI,SAAS;AACX,MAAE,QAAQ,aAAa;AACvB,WAAO,gBAAgB,KAAK,SAAS,IAAI;AAAA,MAE3C,CAAC,MAAM;AACL,MAAE,QAAQ,aAAa;AACvB,WAAO,gBAAgB,KAAK,SAAS,GAAG;AAAA;AAEhD,QAAM,SAAS,MAAM;AACjB,YAAQ,WAAW,QAAQ;AAC3B,YAAQ,YAAY,MAAM,KAAK,IAAI,MAAM;AACzC,YAAQ,UAAU,QAAQ;AAC1B,sBAAkB,QAAQ;AAAA;AAE9B,SAAO;AAAA,OACA;AAAA,IACH;AAAA,IACA;AAAA;AAAA;AAGR,IAAM,mBAAmB,iBAAe;AACpC,QAAM,QAAQ,KAAK,IAAI,GAAG,eAAe;AACzC,QAAM,YAAY,QAAQ,MAAM,KAAK;AACrC,SAAO,QAAQ;AAAA;AAEnB,IAAM,UAAU,MAAM;AAEtB,wBAAwB,IAAI,iBAAiB,OAAO;AAEhD,SAAO,WAAW,IAAI;AAAA,IAClB,MAAM;AAAA,IACN;AAAA;AAAA;AAKR,IAAM,eAAe,OAAmD;AAMxE,qBAAqB,KAAK,KAAK;AAC3B,MAAI,CAAC,WAAW,IAAI,UAAU;AAC1B,YAAQ,KAAK;AACb;AAAA;AAEJ,MAAI,QAAQ,cAAc;AAAA;AAK9B,uBAAuB;AACnB,QAAM,QAAQ;AACd,QAAM,WAAW,OAAO,cAAc;AACtC,MAAI,aAAa,OAAO;AACpB,YAAQ,KAAK;AACb,WAAO;AAAA;AAEX,SAAO;AAAA;AAGX,IAAI,kBAAkB;AACtB,+BAA+B,KAAK,YAAY,UAAU;AACtD,aAAW,YAAY;AACnB,UAAM,WAAW;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAEJ,eAAW,KAAK,UAAU;AACtB,iBAAW,MAAM,SAAS,OAAO,OAAK,EAAE,SAAS,IAAI;AAEjD,YAAI,GAAG,GAAG,GAAG;AAAA;AAEjB,YAAM,gBAAgB;AAAA;AAE1B,QAAI,IAAI,SAAS,OAAO,OAAK,EAAE,SAAS,yBAAyB,IAAI,OAAK,EAAE,KAAK,KAAK,QAAQ,OAAK,IAAI,sBAAsB;AAE7H,eAAW,QAAQ,OAAK,IAAI,GAAG,EAAE,MAAM,GAAG,EAAE;AAC5C,eAAW,SAAS;AACpB,aAAS,SAAS;AAAA,KACnB;AAAA;AAEP;AACI,oBAAkB,gBAAc;AAC5B,QAAI;AACJ,UAAM,aAAa;AACnB,UAAM,WAAW;AACjB,UAAM,UAAU,IAAI,MAAM,IAAI;AAAA,MAC1B,KAAK,CAAC,QAAQ,SAAS;AACnB,YAAI,KAAK;AAEL,iBAAO,IAAI,GAAG;AAAA,mBAET,QAAQ,QAAQ;AAErB,iBAAO,OAAO;AAAA,eAEb;AAED,iBAAQ,OAAO,QAAQ,IAAI,SAAS;AAChC,uBAAW,KAAK;AAAA,cACZ,MAAM;AAAA,cACN;AAAA;AAAA;AAAA;AAAA;AAAA;AAMpB,UAAM,QAAQ,IAAI,MAAM;AAAA,MACpB,IAAI;AAAA,OACL;AAAA,MACC,KAAK,CAAC,QAAQ,SAAS;AACnB,YAAI,SAAS,MAAM;AACf,iBAAO,OAAO;AAAA;AAElB,YAAI,KAAK;AACL,iBAAO,IAAI;AAAA;AAEf,YAAI,QAAQ,QAAQ;AAEhB,iBAAO,OAAO;AAAA;AAGlB,eAAQ,OAAO,QAAQ,IAAI,SAAS;AAChC,mBAAS,KAAK;AAAA,YACV,MAAM;AAAA,YACN;AAAA;AAAA;AAAA;AAAA;AAKhB,eAAW,KAAK,OAAK;AACjB,YAAM;AACN,sBAAgB,KAAK,YAAY;AAAA;AAErC,WAAO;AAAA;AAAA;AAGf,IAAI,WAAW;AAEf,IAAI,sBAAsB;AAE1B,IAAK,MAAwC;AACzC,MAAI;AACA,0BAAsB,0BAA6B;AAAA,UAEvD;AAAA;AAAA;AAEJ,IAAM,iBAAiB,CAAC,KAAK,KAAK,kBAAkB,QAAQ,qCAAqC;AAC7F,QAAM,UAAU,IAAI,QAAQ,SAAO;AAC/B,wBAAoB;AAAA,MAChB;AAAA,MACA;AAAA,MACA;AAAA,OACD;AAAA;AAEP,cAAY,KAAK,SAAS;AAAA;AAG9B,IAAM,wBAAwB;AAAA,EAC1B,QAAQ,KAAK,UAAU;AAAA,IACnB,IAAI;AAAA,IACJ,OAAO;AAAA,KACR;AACC,WAAO,eAAe,KAAK,QAAQ,IAAI,QAAQ;AAAA;AAAA;AAIvD,8BAA8B,SAAS,WAAW,IAAI;AAClD,QAAM,MAAM;AACZ,QAAM,QAAQ,IAAI;AAClB,QAAM,OAAO,SAAS,MAAM;AACxB,QAAI,CAAC,MAAM;AACP,aAAO,IAAI;AACf,UAAM,IAAI,MAAM,MAAM;AACtB,UAAM,IAAI,IAAI;AACd,eAAW,KAAK,GAAG;AACf,QAAE,IAAI,EAAE,IAAI;AAAA;AAEhB,WAAO;AAAA;AAEX,MAAI,KAAK;AACL,UAAM,KAAK,QAAQ;AACnB,QAAI,aAAa;AAEjB,QAAI,GAAG,iBAAiB,CAAC,YAAY;AACjC,UAAI,QAAQ,eAAe;AACvB;AACJ,UAAI,CAAC,MAAM;AACP;AACJ,YAAM,SAAS,QAAQ;AACvB,UAAI,IAAI,MAAM,MAAM;AACpB,UAAI,QAAQ,QAAQ;AAChB,YAAI,QAAQ,YAAY;AACpB,cAAI,QAAQ,WAAW,QAAQ,QAAQ;AAAA,eAEtC;AAED,cAAI,EAAE,OAAO,CAAC,MAAM,EAAE,GAAG,QAAQ,WAAW,KAAK,EAAE,MAAM,QAAQ,WAAW;AAAA;AAAA;AAGpF,cAAQ,YAAY;AAAA;AAExB,QAAI,GAAG,kBAAkB,CAAC,YAAY;AAClC,UAAI,QAAQ,eAAe;AACvB;AACJ,YAAM,OAAO,KAAK,MAAM,IAAI,QAAQ;AACpC,UAAI,MAAM;AACN,cAAM,IAAI,SAAS,KAAK;AACxB,gBAAQ,QAAQ,QAAQ,cAAc,QAAQ,YAAY,IAAI,KAAK;AAAA;AAAA;AAG3E,UAAM,OAAO,MAAM;AACf,UAAI,kBAAkB;AACtB,UAAI,mBAAmB;AAAA,OACxB;AAAA,MACC,WAAW;AAAA,MACX,MAAM;AAAA;AAAA;AAGd,SAAO;AAAA,IACH;AAAA;AAAA;AAIR,kCAAkC,IAAI,OAAO,OAAO;AAChD,QAAM,MAAM;AACZ,MAAI,WAAW;AACf,MAAI,YAAY;AAChB,MAAI,KAAK;AACL,QAAI,iBAAiB;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA;AAEJ,eAAW,CAAC,OAAO,QAAQ,IAAI,iBAAiB,EAAE,SAAS,IAAI,OAAO;AACtE,gBAAY,CAAC,UAAU,SAAS,KAAK,OAAO,MAAM,KAAK;AAAA;AAE3D,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,4BAA4B,KAAK;AAC7B,MAAI,CAAC;AACD,WAAO;AAEX,QAAM,SAAQ,CAAC,CAAC,IAAI;AACpB,QAAM,aAAa,UAAS,CAAC,CAAC,IAAI;AAClC,QAAM,aAAa,CAAC,CAAC,IAAI;AACzB,QAAM,aAAa,aACb,aACA,SACI,QACA,aACI,aACA;AACd,SAAO;AAAA,OACC,aAAa,EAAE,eAAe;AAAA,OAC9B,IAAI,SAAS,EAAE,KAAK,IAAI,OAAO,IAAI,eAAe;AAAA;AAAA;AAG9D,mCAAmC,OAAO,SAAS;AAC/C,QAAM,WAAW;AACjB,QAAM,MAAM;AACZ,MAAI,OAAO,UAAU;AACjB,QAAI,GAAG,iBAAiB,CAAC,SAAS,QAAQ;AACtC,UAAI,QAAQ,sBAAsB;AAC9B;AACJ,YAAM,CAAC,MAAM,YAAY,SAAS,WAC5B,CAAC,QAAQ,MAAM,QAAQ,YACvB,CAAC,SAAS;AAChB,UAAI,WAAW,QAAQ;AACnB,cAAM,QAAQ,cAAc;AAC5B;AAAA;AAEJ,UAAI,OAAO,QAAQ,SACb,QACA,OAAO,KAAK,OAAO,IAAI,CAAC,QAAS;AAAA,QAC/B;AAAA,QACA;AAAA,QACA,OAAO,OAAO,MAAM;AAAA,WACjB,mBAAmB,MAAM;AAAA;AAEpC,UAAI,CAAC,UAAU;AACX,cAAM,WAAW,IAAI,IAAI,QAAQ,aAAa,MAAM,IAAI,CAAC,MAAM,EAAE;AACjE,eAAO,KAAK,OAAO,CAAC,MAAM,CAAC,SAAS,IAAI,EAAE;AAAA;AAE9C,cAAQ,aAAa,MAAM,KAAK,GAAG;AAAA;AAAA;AAAA;AAK/C,wBAAwB,GAAG;AACvB,SAAQ,KACH,WAAU,EAAE,WACT,UAAU,EAAE,mBACZ,UAAU,EAAE;AAAA;AAExB,kBAAkB,SAAS,oBAAoB;AAE3C,QAAM,OAAO,IAAI;AACjB,QAAM,OAAO,IAAI;AACjB,QAAM,OAAO;AACb,QAAM,YAAY,IAAI;AACtB,QAAM,CAAC,QAAQ,gBAAgB,iBAAiB,eAAe,WACzD;AAAA,IACE,QAAQ,WAAW;AAAA,IACnB,QAAQ,mBAAmB;AAAA,IAC3B,QAAQ,kBAAkB;AAAA,MAE5B,eAAe,sBACX;AAAA,IACE,mBAAmB,WAAW;AAAA,IAC9B,mBAAmB,mBAAmB;AAAA,IACtC,mBAAmB,kBAAkB;AAAA,MAEvC,CAAC,MAAM,MAAM;AACvB,QAAM,cAAc,UACd,SAAS,WACL,qBACA,eAAe,WACX,UACA,SAAS,QAAQ,OACb,qBACA,UACZ;AACN,MAAI,mBAAmB;AACvB,MAAI,YAAa,OACX,SAAS,WACL,UACA,WAAW,SAAS,QAAQ,OACxB,QAAQ,MACR,aACR;AACN,MAA+C,WAAW;AACtD,UAAM,QAAQ,yBAAyB,YAAY,aAAa,WAAW;AAC3E,uBAAmB,CAAC,MAAM,SAAS,UAAU,MAAM,SAAS;AAAA,MACxD;AAAA,MACA,MAAM;AAAA,WACC;AAAA,WACA;AAAA;AAAA,MAEP,MAAM;AAAA;AAAA;AAGd,QAAM,cAAc,IAAI;AACxB,QAAM,mBAAmB;AACzB,MAAI,kBAAkB;AACtB,QAAM,SAAS,CAAC,YAAY;AACxB,QAAI,CAAC,iBAAiB;AAElB,UAAK,MAAwC;AACzC,YAAI,kBAAkB;AAClB,2BAAiB,KAAK,OAAO,EAAE,WAAW;AAAA,YACtC,MAAM;AAAA,YACN,OAAO;AAAA;AAAA;AAGf,cAAM,IAAI,MAAM;AAAA,aAEf;AACD;AAAA;AAAA;AAGR,oBAAgB;AAChB,gBAAY,QAAQ;AACpB,qBAAiB,QAAQ;AACzB,QAAI,kBAAkB;AAClB,uBAAiB,KAAK,OAAO,EAAE,WAAW;AAAA,QACtC,MAAM;AAAA;AAAA;AAAA;AAIlB,QAAM,MAAM,WAAW,OAAO,SAAS,SAAS;AAC5C,sBAAkB,IAAI;AACtB,QAAI,kBAAkB;AAClB,uBAAiB,KAAK,OAAO,SAAS,WAAW,EAAE,KAAK,YAAY,SAAS,EAAE,MAAM,WAAW;AAAA;AAEpG,UAAM,WAAW,MAAM,MAAM,SAAS;AAAA,MAClC,QAAQ,gBAAgB;AAAA,SACrB;AAAA,SACA;AAAA;AAEP,QAAI,kBAAkB;AAClB,uBAAiB,KAAK,OAAO,UAAU;AAAA,QACnC,MAAM;AAAA,QACN;AAAA,QACA;AAAA;AAAA;AAGR,QAAI,UAAU;AACV,YAAM,WAAW;AAAA,QAEb,SACM,SACG,QACA,OACA,KAAK,CAAC,MAAO,KAAK,QAAQ,GAC1B,MAAM,CAAC,MAAM;AACd,eAAK,QAAQ;AACb,oBAAU,QAAQ;AAAA,aAEpB,QAAQ;AAAA,QAEd,SACK,QACA,OACA,KAAK,CAAC,MAAM;AACb,eAAK,QAAQ;AAAA;AAAA,QAGjB,SACK,QACA,OACA,KAAK,CAAC,MAAM;AACb,eAAK,QAAQ;AAAA;AAAA;AAGrB,UAAI,gBAAgB;AAChB,cAAM,QAAQ,IAAI;AAClB,YAAI,kBAAkB;AAClB,2BAAiB,KAAK,OAAO,IAAI;AAAA,YAC7B,MAAM;AAAA,YACN,MAAM,KAAK;AAAA,YACX,MAAM,KAAK;AAAA,YACX,MAAM,KAAK;AAAA,YACX;AAAA;AAAA;AAAA;AAAA;AAKhB,WAAO;AAAA,KACR;AACH,QAAM,SAAS,SAAS,MAAO,IAAI,OAAO,SAAS,IAAI,OAAO,MAAM,UAAW;AAC/E,QAAM,aAAa,SAAS,MAAO,IAAI,OAAO,SAAS,IAAI,OAAO,MAAM,cAAe;AAGvF,MAAI,SAAS;AACT,QAAI,SAAS,YAAY,SAAS,QAAQ,MAAM;AAC5C,UAAI,KAAK,SAAS,QAAW;AAAA;AAAA;AAGrC,MAAI,iBAAiB,sBAAsB;AACvC,gBAAY,MAAM;AACd,UAAI,iBAAiB;AACjB,eAAO;AAAA;AAAA;AAAA;AAInB,SAAO;AAAA,OACA;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,sBAAsB,KAAK,WAAW;AAClC,QAAM,YAAY,YAAY,eAAe;AAC7C,MAAI,KAAK;AACT,QAAM,eAAe,IAAI;AACzB,QAAM,aAAa,IAAI;AACvB,QAAM,OAAO,IAAI;AACjB,QAAM,SAAS,IAAI;AACnB,QAAM,WAAW,IAAI;AACrB,QAAM,UAAU,IAAI;AAEpB,MAAI,cAAgB,AAA0C,KAAK,SAAU;AAC7E,MAAI,OAAO;AACX,MAAI,QAAQ;AACZ,MAAI,WAAW;AACX,SAAK,IAAI,UAAU,KAAK;AACxB,OAAG,iBAAiB,WAAW,OAAK;AAChC,mBAAa,QAAQ;AACrB,WAAK,QAAQ,EAAE;AAGf,UAAK,MAAwC;AACzC,YAAI,KAAK,QAAQ,cAAc,GAAG;AAC9B,kBAAQ,KAAK;AAAA;AAIjB,sBAAc,KAAK;AAAA;AAAA;AAG3B,OAAG,iBAAiB,SAAS,WAAS;AAClC,iBAAW,QAAQ;AACnB,cAAQ,QAAQ;AAAA;AAEpB,OAAG,iBAAiB,SAAS,MAAM;AAC/B,aAAO,QAAQ;AACf,eAAS,QAAQ;AAAA;AAErB,OAAG,iBAAiB,QAAQ,MAAM;AAC9B,aAAO,QAAQ;AACf,eAAS,QAAQ;AAAA;AAErB,WAAO,CAAC,UAAS,GAAG,KAAK;AACzB,YAAQ,CAAC,MAAM,WAAW;AACtB,SAAG,MAAM,MAAM;AAAA;AAAA;AAGvB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,iCAAiC,OAAO,YAAY;AAChD,QAAM,YAAY,YAAY,0BAA0B;AACxD,QAAM,iBAAiB,QAAQ,KAAK,SAAS;AAC7C,QAAM,UAAU,kBAAmB,WAAU,eAAe,UAAU,CAAC,eAAe,SAChF,iBACA;AACN,QAAM,UAAU,SAAS,MAAM,aACzB,OAAO,cACP,CAAC,UACG,OAAO,SACP;AACV,QAAM,WAAW,IAAI;AACrB,QAAM,iBAAiB,SAAS,MAAM,SAAS,MAAM,SAAS,KAAK,SAAS,MAAM,MAAM,OAAK,EAAE;AAC/F,QAAM,WAAW,CAAC,YAAY;AAC1B,aAAS,QAAQ;AAAA;AAErB,MAAI,WAAW;AACf,MAAI,WAAW;AACX,UAAM,SAAS,cAAW;AACtB,UAAI,SAAS,OAAO;AAChB,iBAAS,MAAM;AAAA;AAEnB,YAAM,OAAQ,YACV,YAAW;AAAA,QACX,MAAM,OAAO,SAAQ;AAAA,QACrB,YAAY,OAAO,SAAQ;AAAA,QAC3B,WAAW,OAAO,SAAQ;AAAA,WAE1B;AACJ,eAAS,QAAQ,IAAI,qBAAqB,UAAU;AACpD,YAAM,UAAU,SAAS,MAAM,IAAI,OAAK,EAAE;AAC1C,cAAQ,QAAQ,SAAS,MAAM;AAAA,OAChC,EAAE,MAAM,MAAM,WAAW;AAAA;AAEhC,QAAM,UAAU,YACV,CAAC,aAAY;AACX,UAAM,IAAI,OAAO;AACjB,aAAS,MAAM,QAAQ;AAAA,MAEzB;AACN,QAAM,YAAY,YACZ,CAAC,aAAY;AACX,UAAM,IAAI,OAAO;AACjB,aAAS,MAAM,UAAU;AAAA,MAE3B;AACN,QAAM,aAAa,MAAM,SAAS,MAAM;AAExC,MAAI,SAAS;AAGT,cAAU,MAAM;AACZ,UAAI,QAAQ,OAAO;AACf,gBAAQ;AAAA;AAAA;AAIhB,gBAAY,MAAM;AACd;AAAA;AAAA;AAaR,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,iCAAiC;AAC7B,QAAM,aAAa,WACb,UAAU,cACR,UAAU,iBACV,UAAU,mBACZ;AACN,QAAM,YAAY,CAAC,CAAC;AACpB,QAAM,WAAW,IAAI;AACrB,QAAM,cAAc,IAAI;AACxB,QAAM,gBAAgB,IAAI;AAC1B,QAAM,MAAM,IAAI;AAChB,QAAM,WAAW,IAAI;AACrB,QAAM,OAAO,IAAI;AACjB,MAAI,UAAU;AACd,MAAI,SAAS;AAEb,MAAI,YAAY;AACZ,cAAU,MAAM;AACZ,eAAS,QAAQ,WAAW;AAC5B,kBAAY,QAAQ,WAAW;AAC/B,oBAAc,QAAQ,WAAW;AACjC,UAAI,QAAQ,WAAW;AACvB,eAAS,QAAQ,WAAW;AAC5B,WAAK,QAAQ,WAAW;AAAA;AAE5B,aAAS,SAAS,YAAY,UAAU,SAAS;AACjD;AAAA,SAEC;AAED,QAAK,MAAwC;AACzC,cAAQ,KAAK;AAAA;AAAA;AAGrB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,IAAI,SAAS;AACb,qBAAqB;AACjB,QAAM,YAAY,YAAY,YAAY;AAE1C,MAAI,CAAC,WAAW;AACZ,aAAS,IAAI;AAAA;AAEjB,MAAI,CAAC,QAAQ;AACT,aAAS,IAAI,UAAU;AACvB,WAAO,iBAAiB,WAAW,MAAO,OAAO,QAAQ,OAAQ;AACjE,WAAO,iBAAiB,UAAU,MAAO,OAAO,QAAQ,MAAO;AAAA;AAEnE,SAAO;AAAA,IACH;AAAA,IACA;AAAA;AAAA;AAIR,IAAI,aAAa;AACjB,IAAI,SAAS;AACb,6BAA6B;AACzB,MAAI,CAAC,QAAQ;AACT,aAAS,IAAI,YAAY,SAAS;AAAA;AAEtC,MAAI,CAAC,YAAY;AACb,QAAI,UAAU;AACV,mBAAa,IAAI,SAAS;AAC1B,eAAS,iBAAiB,oBAAoB,MAAM;AAChD,mBAAW,QAAQ,SAAS;AAC5B,eAAO,QAAQ,SAAS;AAAA,SACzB;AAAA,WAEF;AACD,mBAAa,IAAI;AAAA;AAAA;AAGzB,SAAO;AAAA,IACH;AAAA,IACA;AAAA;AAAA;AAIR,IAAI,WAAW;AACf,IAAI,YAAY;AAChB,uBAAuB;AACnB,MAAI,CAAC,UAAU;AACX,eAAW,WAAW,IAAI,UAAU,YAAY,IAAI;AAAA;AAExD,MAAI,CAAC,WAAW;AACZ,QAAI,UAAU;AACV,kBAAY,IAAI,UAAU;AAC1B,YAAM,SAAS,MAAM;AACjB,iBAAS,QAAQ,UAAU;AAC3B,kBAAU,QAAQ,UAAU;AAAA;AAEhC,aAAO,iBAAiB,kBAAkB,QAAQ;AAAA,WAEjD;AACD,kBAAY,IAAI;AAAA;AAAA;AAGxB,SAAO;AAAA,IACH;AAAA,IACA;AAAA;AAAA;AAIR,6BAA6B,MAAM,eAAe;AAC9C,QAAM,YAAY,YAAY,sBAAsB;AACpD,QAAM,OAAO,IAAI;AACjB,QAAM,eAAe,IAAI;AACzB,QAAM,aAAa,IAAI;AACvB,QAAM,UAAU,IAAI;AACpB,QAAM,WAAW,IAAI;AACrB,MAAI,OAAO;AACX,MAAI,QAAQ;AACZ,MAAI,cAAc;AAElB,MAAI,WAAW;AACX,UAAM,KAAK,IAAI,iBAAiB;AAChC,OAAG,iBAAiB,gBAAgB,OAAK;AACrC,iBAAW,QAAQ;AACnB,cAAQ,QAAQ;AAAA,OACjB;AACH,OAAG,iBAAiB,WAAW,QAAM;AACjC,mBAAa,QAAQ;AACrB,WAAK,QAAQ,GAAG;AAAA,OACjB;AACH,WAAO,OAAK,GAAG,YAAY;AAC3B,YAAQ,MAAM;AACV,SAAG;AACH,eAAS,QAAQ;AAAA;AAErB,kBAAc,CAAC,IAAI,MAAM;AACrB,SAAG,iBAAiB,WAAW,IAAI;AACnC,kBAAY,MAAM,GAAG,oBAAoB,WAAW;AAAA;AAExD,gBAAY,MAAM;AACd,uBAAiB;AACjB;AAAA;AAAA,SAGH;AACD,QAAK,MAAwC;AACzC,cAAQ,KAAK;AAAA;AAAA;AAGrB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,wBAAwB,SAAS;AAC7B,QAAM,YAAY,YAAY,CAAC,CAAC,UAAU;AAE1C,QAAM,OAAO,IAAI,UAAU,QAAQ,cAAc,QAAQ;AACzD,QAAM,QAAQ,IAAI;AAClB,QAAM,YAAY,IAAI;AACtB,QAAM,SAAS,IAAI;AACnB,QAAM,eAAe,IAAK,WAAW,QAAQ,sBAAuB;AAEpE,MAAI,UAAU;AACd,MAAI,WAAW;AACX,UAAM,cAAc,CAAC,QAAQ;AACzB,gBAAU,QAAQ,IAAI;AACtB,aAAO,QAAQ,IAAI;AACnB,YAAM,QAAQ;AAAA;AAElB,UAAM,WAAW,CAAC,QAAQ;AACtB,gBAAU,QAAQ,KAAK;AACvB,aAAO,QAAQ;AACf,YAAM,QAAQ;AAAA;AAElB,UAAM,aAAa,MAAM,KAAK,UAAU,QACpC,WACA,UAAU,YAAY,WAAW;AACrC,QAAI,0BAA0B,MAAM,UAAU,YAAY,mBAAmB,aAAa,UAAU;AACpG,QAAI,KAAK,OAAO;AACZ,gBAAU,MAAM;AACZ,YAAI,KAAK,OAAO;AACZ,eAAK,QAAQ;AAAA,eAEZ;AACD;AAAA;AAAA;AAAA,WAIP;AAED,gBAAU;AAAA;AAEd,QAAI,UAAU;AACd,cAAU,MAAM,MAAM,CAAC,cAAc,OAAO,CAAC,MAAM;AAC/C;AACA,YAAM,qBAAqB,UAAU,EAAE,MACjC,EAAE,KACF,UACI,QAAQ,qBACR;AACV,gBAAU,UAAU,YAAY,cAAc,aAAa,UAAU,UAC/D,KAAK,SAAS,uBACd,EAAE;AAAA,OACT;AAAA,MACC,WAAW,CAAC,KAAK;AAAA;AAErB,gBAAY;AAAA;AAEhB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAUR,2BAA2B,SAAS,MAAM;AACtC,QAAM,SAAS,iBAAiB,SAAS,iBAAiB;AAC1D,SAAO,SAAS,OAAO,SAAS;AAAA;AASpC,2BAA2B,SAAS,MAAM,OAAO;AAC7C,UAAQ,MAAM,YAAY,MAAM;AAAA;AAEpC,IAAM,iBAAiB;AAAA,EACnB,YAAY;AAAA,EACZ,WAAW;AAAA,EACX,SAAS;AAAA;AAEb,IAAM,qBAAqB,CAAC,SAAS;AACjC,MAAI,KAAK,UAAU,KAAK,KAAK,OAAO,OAAO,KAAK,OAAO,KAAK;AACxD,WAAO,KAAK;AAAA;AAEhB,SAAO;AAAA;AAEX,yBAAyB,WAAW,kBAAkB,eAAe;AACjE,QAAM,YAAY,YAAY,sBAAsB;AACpD,QAAM,CAAC,SAAS,WAAW,MAAM,qBAAqB,UAAU,oBAC1D,CAAC,kBAAkB,iBAAiB,kBACpC;AAAA,IACG,aAAa,SAAS,mBAAoB;AAAA,IAC3C,oBAAoB;AAAA;AAG5B,QAAM,YAAY,IAAI;AAEtB,QAAM,SAAS;AAEf,QAAM,eAAe;AAErB,QAAM,aAAa,OAAO,QAAQ,WAAW,IAAI,CAAC,MAAM;AACpD,UAAM,CAAC,MAAM,SAAS,SAAS,EAAE,MAAM,CAAC,EAAE,MAAM,CAAC,EAAE,GAAG,MAAM,EAAE,GAAG;AACjE,QAAI,OAAO;AACP,mBAAa,KAAK,MAAM,kBAAkB,OAAO,UAAU,MAAM,OAAO;AAExE,aAAO,EAAE,MAAM,KAAK;AAAA;AAExB,WAAO,CAAC,EAAE,IAAI,mBAAmB;AAAA;AAErC,WAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AACxC,UAAM,CAAC,KAAK,QAAQ,WAAW;AAC/B,QAAI,CAAC,OAAO,MAAM;AAEd,aAAO,OAAO,IAAK,MAAM,YAAY,CAAC,QAAQ,SAAU,CAAC,YACnD,OACA,kBAAkB,OAAO,UAAU;AAAA;AAE7C,QAAI,WAAW;AAEX,YAAM,CAAC,OAAO,MAAM,KAAK,WAAW,CAAC,QAAQ;AACzC,YAAI,CAAC;AACD;AAGJ,YAAI,IAAI,MAAM,IAAI,OAAO,kBAAkB,IAAI,IAAI,OAAO;AACtD,4BAAkB,IAAI,IAAI,MAAM,IAAI;AAAA;AAAA,SAEzC,EAAE,WAAW,CAAC,MAAM;AAAA;AAAA;AAG/B,MAAI,CAAC,WAAW;AACZ,WAAO;AAAA,SACA;AAAA,MACH,MAAM;AAAA,MACN,QAAQ;AAAA,MACR;AAAA,MACA;AAAA;AAAA;AAGR,QAAM,SAAS,MAAM;AAGjB,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AACxC,YAAM,CAAC,KAAK,SAAS,WAAW;AAChC,aAAO,KAAK,QAAQ,kBAAkB,OAAO,UAAU;AAAA;AAAA;AAI/D,QAAM,WAAW,IAAI,iBAAiB;AAEtC,QAAM,OAAO,MAAM;AACf,aAAS;AACT,cAAU,QAAQ;AAAA;AAGtB,QAAM,SAAS,MAAM;AAEjB,QAAI,CAAC,UAAU,OAAO;AAClB;AAAA;AAEJ,aAAS,QAAQ,OAAO,UAAU;AAClC,cAAU,QAAQ;AAAA;AAGtB,cAAY;AACZ,MAAI,MAAM,UAAU;AAChB,cAAU,MAAM;AACZ,mBAAa,QAAQ,OAAK;AAC1B,YAAM,SAAS,CAAC,GAAG,MAAM;AACrB,YAAI,GAAG;AACH;AAAA;AAEJ,YAAI,GAAG;AACH;AAAA;AAAA;AAAA;AAAA,aAKP,YAAY,SAAS;AAC1B,iBAAa,QAAQ,OAAK;AAE1B;AAAA;AAEJ,SAAO;AAAA,OACA;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAMR,sBAAsB,MAAM;AACxB,OAAK,YAAY,OAAO,MAAM;AAC1B,UAAM,IAAI,KAAK,EAAE;AACjB,QAAI,MAAM,QAAW;AAEjB,UAAK,MAAwC;AACzC,gBAAQ,KAAK,6BAA6B;AAAA;AAE9C,WAAK,YAAY;AAAA,eAEZ,MAAM,MAAM;AACjB,WAAK,YAAY;AAAA,eAEZ,QAAQ,IAAI;AACjB,WAAK,YAAY;AAAA,eAEZ,EAAE,OAAO,gBAAgB;AAC9B,uBAAiB,KAAK;AAClB,aAAK,YAAY;AAAA,eAEhB,EAAE,OAAO,WAAW;AACzB,iBAAW,KAAK;AACZ,aAAK,YAAY;AAAA,WAEpB;AACD,WAAK,YAAY,MAAM;AAAA;AAAA;AAAA;AAInC,mBAAmB,WAAW,MAAM,SAAS;AACzC,QAAM,YAAY,YAAY,YAAY;AAC1C,QAAM,aAAa;AACnB,QAAM,OAAO;AACb,QAAM,aAAa,IAAI,CAAC;AACxB,QAAM,UAAU,IAAI,CAAC;AACrB,MAAI,CAAC,WAAW;AACZ,eAAW,QAAQ;AACnB,WAAO;AAAA,MACH,QAAQ;AAAA,MACR;AAAA,MACA,aAAa;AAAA,MACb,WAAW;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA;AAAA;AAGR,QAAM,SAAS,IAAI,OAAO,WAAW;AAErC,MAAI,cAAgB,AAA0C,KAAK,QAAQ,MAAO;AAClF,QAAM,eAAc,WAAQ,OAAO,YAAY;AAC/C,uBAAqB;AACjB,WAAO;AACP,eAAW,QAAQ;AAAA;AAEvB,SAAO,iBAAiB,WAAW,OAAK;AACpC,SAAK,QAAQ,EAAE;AAGf,QAAK,MAAwC;AACzC,UAAI,KAAK,QAAQ,cAAc,GAAG;AAC9B,gBAAQ,KAAK;AAAA;AAEjB,oBAAc,KAAK;AAAA;AAAA,KAExB;AACH,SAAO,iBAAiB,SAAS,WAAS;AACtC,eAAW,QAAQ;AACnB,YAAQ,QAAQ;AAAA,KACjB;AACH,cAAY;AACZ,MAAI,MAAM;AACN,iBAAY;AAAA;AAEhB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AASR,kBAAkB,MAAM;AACpB,QAAM,YAAY,YAAY,WAAW;AACzC,MAAI,QAAQ,MAAM,QAAQ,QAAQ;AAClC,MAAI,WAAW;AACf,MAAI,UAAS,IAAI;AACjB,MAAI,YAAY,IAAI;AACpB,MAAI,WAAW;AACX,YAAQ,WAAQ;AACZ,cAAO,QAAQ;AACf,gBAAU,QAAQ;AAClB,aAAO,UACF,MAAM,OACN,KAAK,OAAK;AACX,gBAAO,QAAQ;AACf,eAAO;AAAA,SAEN,MAAM,OAAK;AACZ,gBAAO,QAAQ;AACf,kBAAU,QAAQ;AAClB,eAAO;AAAA;AAAA;AAGf,eAAW,WAAQ,UAAU,SAAS;AACtC,QAAI,MAAM;AACN,UAAI,SAAS,OAAO;AAChB,cAAM;AAAA;AAAA;AAAA;AAIlB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,wBAAwB;AACpB,QAAM,YAAY,YAAY,eAAe;AAC7C,QAAM,OAAO;AACb,QAAM,OAAO;AACb,QAAM,YAAY,CAAC,UAAS;AACxB,SAAK,QAAQ;AACb,QAAI,CAAC;AACD,aAAO,QAAQ;AAEnB,WAAO,UAAU,UAAU,UAAU;AAAA;AAEzC,QAAM,QAAQ,CAAC,UAAS;AACpB,QAAI,CAAC;AACD,aAAO,QAAQ;AAGnB,WAAO,UAAU,UAAU,MAAM;AAAA;AAErC,MAAI,WAAW,MAAM,QAAQ,QAAQ;AAErC,MAAI,OAAO;AACX,MAAI,WAAW;AACX,QAAI,WAAW;AACf,UAAM,SAAS,MAAM,WAAW,KAAK,CAAC,MAAO,KAAK,QAAQ;AAC1D,KAAC,QAAQ,OAAO,SAAS,IAAI,CAAC,UAAU,SAAS,QAAQ,OAAO,MAAM;AACtE,eAAW,MAAM,UAAU,UAAU,WAAW,KAAK,CAAC,MAAM;AACxD,UAAI;AACA,mBAAW;AACX,eAAQ,KAAK,QAAQ;AAAA,gBAEzB;AAEI,mBAAW;AAAA;AAAA;AAInB,WAAO,MAAM,UAAU,UAAU,OAAO,KAAK,CAAC,MAAO,KAAK,QAAQ;AAClE,UAAM,MAAM,SAAS,CAAC,MAAM;AACxB,UAAI,YAAY,CAAC,SAAS;AACtB;AACJ,gBAAU;AAAA,OACX;AAAA;AAEP,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AASR,oBAAoB,IAAI,QAAQ,GAAG;AAC/B,MAAI,QAAQ,IAAI;AAChB,QAAM,YAAY,WAAW,MAAM;AAC/B,UAAM,QAAQ;AACd;AAAA,KACD;AACH,QAAM,SAAS,MAAM;AACjB,UAAM,QAAQ;AACd,iBAAa;AAAA;AAEjB,cAAY;AACZ,SAAO;AAAA,IACH;AAAA,IACA;AAAA;AAAA;AAIR,IAAM,sBAAsB,CAAC,MAAM,SAAU,GAAG;AAC5C,QAAM,OAAO,EAAE,QAAQ;AACvB,SAAO,IAAI,QAAQ,CAAC,QAAQ;AACxB,QAAI;AACA,cAAQ,QAAQ,EAAE,MAAM,GAAG,OAEtB,KAAK,CAAC,MAAM,IAAI,YAAY,CAAC,MAAM,MAEnC,MAAM,CAAC,MAAM,IAAI,YAAY,CAAC,OAAO;AAAA,aAEvC,IAAP;AAEI,UAAI,YAAY,CAAC,OAAO;AAAA;AAAA;AAAA;AAIpC,uBAAuB,IAAI,cAAc;AACrC,QAAM,UAAU,aAAa,SAAS,IAChC,kBAAkB,aAAa,KAAK,cACpC;AACN,QAAM,aAAa;AAAA,IACf;AAAA,IACA;AAAA,IACA,IAAI,oBAAoB,eAAe,GAAG;AAAA;AAE9C,QAAM,OAAO,IAAI,KAAK,YAAY,EAAE,MAAM;AAC1C,SAAO,IAAI,gBAAgB;AAAA;AAE/B,2BAA2B,IAAI,SAAS;AACpC,QAAM,YAAY,YAAY,YAAY;AAE1C,QAAM,eAAe,SAAS,MAAO,WAAW,OAAO,QAAQ,iBAAkB;AACjF,QAAM,aAAa,SAAS,MAAM,WAAW,OAAO,QAAQ;AAC5D,MAAI,CAAC,WAAW;AACZ,WAAO,sBAAsB,IAAI,EAAE,MAAM,MAAM,gBAAgB;AAAA;AAEnE,QAAM,UAAU,sBAAsB,IAAI,SAAS,IAAI,QAAQ,CAAC,KAAK,QAAQ;AACzE,UAAM,UAAU,cAAc,IAAI,aAAa;AAC/C,UAAM,SAAS,IAAI,OAAO;AAC1B,QAAI,YAAY;AAChB,UAAM,UAAU,WAAW;AAC3B,UAAM,YAAY,MAAM;AACpB,aAAO;AACP,UAAI,gBAAgB;AACpB,mBAAa;AACb;AAAA;AAGJ,UAAM,cAAc,KAAK,WAAW,GAAG,SAAS,KAC5C,MAAM,KAAK,KAAK,SAAS,OACzB,KAAK,KAAK,SAAS,GAAG,UAAU,QAC9B,SAAS,MAAM,QAAQ,UAAU,SAAS,KAAK,KAAK,SAAS,GAAG,SAChE,QAAQ;AACd,UAAM,cAAc,cACd,MAAM,aAAa,MAAM;AACvB;AACA,UAAI;AAAA,OACL,EAAE,WAAW,WACd;AACN,WAAO,iBAAiB,WAAW,CAAC,MAAM;AACtC,UAAI,EAAE,KAAK,IAAI;AACX,YAAI,EAAE,KAAK;AAAA,aAEV;AACD,YAAI,EAAE,KAAK;AAAA;AAEf;AAAA,OACD;AACH,WAAO,iBAAiB,SAAS,CAAC,MAAM;AACpC;AACA,UAAI;AAAA,OACL;AACH,WAAO,YAAY,CAAC,GAAG;AACvB,QAAI,SAAS;AACT,kBAAY,WAAW,MAAM;AACzB,gBAAQ,OAAO,6BAA6B;AAAA,SAC7C;AAAA;AAAA,MAEP;AAAA,IACA,MAAM;AAAA,IACN,gBAAgB;AAAA;AAEpB,SAAO;AAAA;AAGX,uBAAuB,OAAO;AAC1B,QAAM,YAAY,WAAW,gBAAgB,SAAS;AACtD,MAAI,iBAAiB;AACrB,MAAI,UAAU;AACd,MAAI,SAAS;AACb,MAAI,WAAW;AACX,qBAAiB,IAAI,WAAW;AAChC,cAAU,IAAI,eAAe,MAAM;AACnC,UAAM,WAAU,CAAC,MAAM;AACnB,cAAQ,QAAQ,EAAE;AAAA;AAEtB,mBAAe,MAAM,iBAAiB,UAAU,UAAS;AACzD,UAAM,UAAS,MAAM,eAAe,MAAM,oBAAoB,UAAU;AACxE,gBAAY;AAAA,SAEX;AAED,QAAK,MAAwC;AACzC,cAAQ,KAAK;AAAA;AAEjB,qBAAiB,IAAI;AACrB,cAAU,IAAI;AAAA;AAElB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,sBAAsB,MAAM,cAAc;AACtC,QAAM,EAAE,aAAa,MAAM,OAAO,cAAc,oBAAoB,MAAM,MAAM;AAChF,QAAM,KAAK,KAAK;AAChB,QAAM,SAAS,IAAI;AACnB,QAAM,OAAO,IAAI;AACjB,QAAM,WAAW,SAAS,MAAM,KAAK,UAAU,IAAiB,OAAO,QAAQ;AAE/E,QAAM,UAAU,IAAI;AACpB,QAAM,OAAO,IAAI;AAEjB,MAAI,cAAc;AAClB,MAAI,WAAW;AACf,OAAK,EAAE,MAAM;AACb,QAAM,OAAO,MAAM,KAAK,EAAE,MAAM,GAAc;AAC9C,QAAM,aAAa,MAAM;AACrB,QAAI,QAAQ,MAAM,WAAW;AACzB;AACJ,QAAI,OAAO,OAAO;AACd,WAAK;AAAA,QACD,MAAM;AAAA,QACN,MAAM;AAAA,QACN,IAAI,KAAK,IAAI,GAAG,QAAQ;AAAA;AAAA;AAGhC,SAAK;AAAA,MACD,MAAM;AAAA,MACN;AAAA;AAAA;AAGR,QAAM,UAAU,CAAC,MAAM;AACnB,YAAQ;AAAA,WACC,GAAgB;AACjB,eAAO,QAAQ;AACf;AAAA;AAAA,WAEC,GAAc;AACf,eAAO,QAAQ;AACf;AAAA;AAAA;AAGR,SAAK,QAAQ;AACb,SAAK;AAAA,MACD,MAAM;AAAA,MACN;AAAA,MACA,MAAM,KAAK;AAAA;AAAA;AAGnB,cAAY,CAAC,MAAM;AACf,YAAQ,EAAE,KAAK;AAAA,WACN,GAAc;AACf,aAAK;AAAA,UACD,MAAM;AAAA,UACN,OAAO,KAAK;AAAA,UACZ,MAAM,KAAK;AAAA;AAEf;AAAA;AAAA,WAEC,GAAe;AAChB,cAAM,QAAQ,QAAQ,MAAM,QAAQ,EAAE,KAAK;AAC3C,YAAI,SAAS,GAAG;AACZ,kBAAQ,MAAM,OAAO,OAAO;AAAA;AAGhC,YAAI,aAAa,EAAE,KAAK,MAAM,QAAQ,MAAM,SAAS,GAAG;AACpD,eAAK;AAAA,YACD,MAAM;AAAA,YACN,MAAM;AAAA,YACN,IAAI,KAAK,IAAI,IAAI,GAAG,QAAQ;AAAA;AAAA;AAGpC;AAAA;AAAA,WAEC,GAAgB;AACjB,sBAAc;AACd,aAAK,QAAQ,EAAE,KAAK;AACpB,aAAK,QAAQ,EAAE,KAAK;AACpB;AAAA;AAAA,WAEC,GAAkB;AACnB,aAAK,QAAQ,EAAE,KAAK;AACpB,mBACK,EAAE,KAAK,SAAS,KAAkB,EAAE,KAAK,MAAO;AACrD,eAAO,QAAQ,aAAa;AAC5B,YAAI,OAAO,OAAO;AACd,kBAAQ,QAAQ;AAChB;AAAA;AAEJ;AAAA;AAAA,WAEC,GAAc;AACf,gBAAQ,QAAQ,CAAC,EAAE,KAAK;AACxB,aAAK;AAAA,UACD,MAAM;AAAA,UACN;AAAA;AAEJ;AAAA;AAAA,WAEC,GAAc;AACf,gBAAQ,MAAM,KAAK,EAAE,KAAK;AAC1B;AAAA;AAAA;AAAA,KAGT;AACH;AACA,QAAM,MAAM,CAAC,GAAG,MAAM;AAClB,QAAI,aAAa;AACb,oBAAc;AACd;AAAA;AAGJ,QAAI,KAAK,UAAU,KAAkB,OAAO,UAAU,OAAO;AACzD,oBAAc;AACd,WAAK,QAAQ;AACb;AAAA;AAEJ,SAAK;AAAA,MACD,MAAM;AAAA,MACN,MAAM,KAAK;AAAA,MACX,OAAO,SAAS,KAAK,KAAK,MAAM;AAAA;AAEpC,kBAAc;AAAA,KACf,EAAE,MAAM,MAAM,WAAW;AAC5B,MAAI,UAAU;AACV,WAAO,iBAAiB,UAAU,YAAY;AAAA;AAElD,cAAY,MAAM;AACd;AACA;AAAA;AAEJ,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAGR,IAAI,SAAS;AACb,mBAAmB,cAAc,IAAI;AACjC,QAAM,KAAK;AACX,QAAM,OAAO,KACP,KACA,GAAG,MAAM;AACf,MAAI,CAAC,MAAM;AACP,QAAK,MAAwC;AACzC,cAAQ,KAAK;AAAA;AAEjB,WAAO,IAAI;AAAA;AAGf,MAAK,MAAwC;AACzC,QAAI,CAAC,QAAQ;AACT,eAAS,IAAI;AAAA;AAEjB,QAAI,OAAO,IAAI,OAAO;AAClB,cAAQ,KAAK;AAAA;AAEjB,WAAO,IAAI;AAAA;AAEf,QAAM,EAAE,MAAM,cAAc,aAAa,MAAM;AAE/C,MAAK,MAAwC;AACzC,QAAI,CAAC,WAAW;AACZ,cAAQ,KAAK;AAAA;AAAA;AAGrB,SAAO;AAAA;AAGX,IAAM,oBAAoB;AAC1B,uBAAuB,kBAAkB,cAAc;AACnD,QAAM,WAAY,SAAS,oBACrB,IAAI,MACJ,QAAQ,MAAM,qBACV,KAAK,oBACL,KAAK,CAAC;AAChB,QAAM,UAAU,SAAS,gBACnB,EAAE,aAAa,cAAc,MAAM,SACnC,gBAAgB,EAAE,MAAM;AAC9B,MAAI,CAAC,QAAQ,aAAa;AACtB,YAAQ,cAAc;AAAA;AAE1B,QAAM,SAAS,IAAI;AAEnB,QAAM,UAAU,SAAS,MAAM,SAAS,MAAM,IAAI,OAAK,IAAI;AAC3D,QAAM,SAAS,MAAM,CAAC,QAAQ,UAAU,CAAC,CAAC,GAAG,MAAM,CAAC,WAAW,iBAAiB;AAC5E,eAAW,SAAS,KAAK;AACrB,YAAM,KAAK,OAAO;AAElB,UAAI,QAAQ,aAAa;AAErB,YAAI,CAAC,IAAI;AAEL,cAAK,MAAwC;AACzC,oBAAQ,KAAK;AAAA;AAEjB;AAAA;AAEJ,WAAG,UAAU,OAAO,QAAQ,aAAa;AAAA;AAE7C,UAAI,QAAQ,UAAU;AAClB,YAAI,cAAc,KAAK,CAAC,YAAY,KAAK,OAAK,OAAO,OAAO;AACxD,kBAAQ,SAAS,IAAI;AAAA;AAAA;AAAA,KAGlC,EAAE,OAAO,QAAQ,MAAM;AAC1B,QAAM,OAAO,MAAO,OAAO,QAAQ;AACnC,QAAM,SAAS,MAAO,OAAO,QAAQ;AACrC,MAAI,SAAS,mBAAmB;AAC5B,cAAU,MAAO,SAAS,QAAQ,MAAM,KAAK,SAAS,iBAAiB;AAAA;AAE3E,MAAI,QAAQ,SAAS,OAAO;AACxB,cAAU;AACV,gBAAY;AACZ,kBAAc;AACd,oBAAgB;AAAA;AAEpB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,mBAAmB,OAAO,MAAM;AAC5B,QAAM,WAAW;AACjB,MAAI,CAAC,UAAU;AACX,UAAM,IAAI,MAAM;AAAA;AAEpB,SAAO,SAAS;AAAA,IACZ,MAAM;AACF,aAAO,MAAM;AAAA;AAAA,IAEjB,IAAI,GAAG;AAEH,eAAS,KAAK,UAAU,QAAQ;AAAA;AAAA;AAAA;AAK5C,uBAAuB,KAAK,qBAAqB;AAC7C,SAAO,OAAO,KAAK,qBAAqB;AAAA;AAG5C,qBAAqB,UAAU,OAAO,MAAM;AACxC,MAAI,aAAa;AACjB,QAAM,QAAQ,CAAC,QAAQ,UAAU;AAC7B;AACA,QAAI,CAAC,OAAO,CAAC,IAAI;AACb;AAAA;AAEJ,UAAM,IAAK,OAAO;AAClB,WAAQ,aAAa,YAAY,UAAU,GAAG,GAAI,SAAS,MAAM,SAAS,QAAQ;AAAA;AAEtF,QAAM,SAAS,MAAM;AACjB,QAAI,CAAC;AACD;AACJ,kBAAc;AACd,iBAAa;AAAA;AAEjB,MAAI,SAAS,KAAK;AACd;AAAA;AAEJ,cAAY;AACZ,SAAO,EAAE,QAAQ;AAAA;AAOrB,sBAAsB,OAAO,OAAO;AAChC,MAAI,CAAC,GAAG,KAAK,UAAU,WAAW,KAAK,SAAS,UAAU,OAAO,UAAU,cACrE,CAAC,OAAO,SACR,CAAC,IAAI,QAAQ;AACnB,SAAO,UAAU,CAAC,OAAO,YAAa;AAAA,IAClC,MAAM;AACF;AACA,aAAO,EAAE;AAAA;AAAA,IAEb,KAAK,SAAS,SAAO;AACjB,QAAE,QAAQ;AACV;AAAA,OACD;AAAA;AAAA;AAIX,wCAAwC,gBAAgB,MAAM;AAC1D,QAAM,cAAc,KAAK;AACzB,QAAM,wBAAwB,KAAK;AACnC,SAAO,SAAS,YAAY,UAAU,MAAM,QACtC;AAAA,IACE,sBAAsB,UAAU,SAC1B,wBACA;AAAA,IACN;AAAA,MAEF,SAAS,sBAAsB,UAC7B,CAAC,QAAQ,sBAAsB,UAC/B,CAAC,SAAS,sBAAsB,SAC9B,CAAC,QAAW,yBACZ;AAAA,IACE,sBAAsB,QAChB,wBACA;AAAA,IACN;AAAA;AAAA;AAIhB,+BAA+B,gBAAgB,MAAM;AACjD,QAAM,CAAC,SAAS,WAAW,+BAA+B,gBAAgB;AAC1E,QAAM,YAAY,SAAS,MAAM,IAAI,KAAK,eAAe,OAAO,UAAU,OAAO;AACjF,QAAM,eAAe,CAAC,OAAO,cAAc,mBAAmB;AAC1D,UAAM,IAAI,gBAAgB,iBACpB,IAAI,KAAK,eAAe,OAAO,mBAC7B,OAAO,UAAU,KAAK,OAAO,aAAa,OAAO,mBACnD,UAAU;AAChB,UAAM,IAAI,OAAO;AACjB,WAAO,EAAE,OAAO,SAAS,KAAK,IAAI,KAAK,KAAK;AAAA;AAEhD,QAAM,SAAS,CAAC,OAAO,cAAc,mBAAmB,SAAS,MAAM,aAAa,OAAO,cAAc;AACzG,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,6BAA6B,gBAAgB,MAAM;AAC/C,QAAM,CAAC,SAAS,WAAW,+BAA+B,gBAAgB;AAC1E,QAAM,YAAY,SAAS,MAAM,IAAI,KAAK,aAAa,OAAO,UAAU,OAAO;AAC/E,QAAM,eAAe,CAAC,OAAO,cAAc,mBAAmB;AAC1D,UAAM,IAAI,gBAAgB,iBACpB,IAAI,KAAK,aAAa,OAAO,mBAC3B,OAAO,UAAU,KAAK,OAAO,aAAa,OAAO,mBACnD,UAAU;AAChB,WAAO,EAAE,OAAO,OAAO;AAAA;AAE3B,QAAM,SAAS,CAAC,OAAO,cAAc,mBAAmB,SAAS,MAAM,aAAa,OAAO,cAAc;AACzG,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,2BAA2B,qBAAqB,gBAAgB,MAAM;AAClE,QAAM,oBAAoB,OAAO;AACjC,QAAM,cAAc,CAAC,SAAS;AAC9B,QAAM,eAAe,cACf,sBACA,SAAS,MAAM;AACb,UAAM,IAAI,OAAO;AACjB,WAAO,EAAE;AAAA;AAEjB,QAAM,CAAC,SAAS,cAAc,+BAA+B,gBAAgB,cACvE,OACA;AACN,QAAM,UAAU,SAAS,MAAM;AAC3B,UAAM,QAAO,OAAO,eAAe;AACnC,UAAM,WAAW,OAAO,iBAAiB,MAAK;AAC9C,WAAO;AAAA,MACH,OAAO;AAAA,SACJ;AAAA,MACH;AAAA;AAAA;AAGR,QAAM,eAAe,oBAAoB;AACzC,QAAM,eAAe,CAAC,QAAQ,UAAU,SAAS,OAAM,mBAAmB;AACtE,UAAM,IAAI,KAAK,QAAQ,UAAU,OAAO;AACxC,UAAM,IAAI,OAAO,aAAa,EAAE;AAChC,UAAM,IAAI,OAAO,YAAY,EAAE;AAE/B,QAAK,MAAwC;AACzC,UAAI,CAAC,GAAG;AACJ,gBAAQ,MAAM;AACd,eAAO;AAAA;AAEX,UAAI,EAAE,UAAU,YAAY;AACxB,gBAAQ,KAAK;AAAA;AAAA;AAGrB,WAAO,aAAa,aAAa,QAAQ;AAAA,SAClC;AAAA,MACH,UAAU;AAAA,MACV,iBAAiB;AAAA,OAClB;AAAA;AAEP,QAAM,SAAS,CAAC,QAAQ,UAAU,SAAS,OAAM,mBAAmB;AAChE,WAAO,SAAS,MAAM,aAAa,QAAQ,UAAU,SAAS,OAAM;AAAA;AAExE,SAAO;AAAA,IACH;AAAA,IACA;AAAA;AAAA;AAIR,4BAA4B,IAAI;AAC5B,MAAI,CAAC;AACD,WAAO;AACX,MAAI,SAAS;AACT,WAAO;AACX,SAAO,uBAAuB;AAAA;AAElC,IAAM,yBAAyB,CAAC,OAAO;AACnC,QAAM,IAAI,GAAG,MAAM;AACnB,MAAI,GAAG;AACH,WAAO,CAAC,EAAE;AAAA;AAEd,SAAO;AAAA;AAEX,uBAAuB,aAAa;AAChC,QAAM,SAAS;AACf,QAAM,MAAM,IAAI;AAChB,QAAM,UAAU;AAChB,MAAI,SAAS;AACb,QAAM,cAAc;AACpB,aAAW,OAAO,aAAa;AAC3B,UAAM,KAAK,YAAY;AACvB,UAAM,QAAQ,mBAAmB;AACjC,QAAI,UAAU,QAAW;AACrB,YAAM,IAAI,IAAI;AACd,aAAO,OAAO;AACd,UAAI,IAAI,OAAO;AAAA,QACX,MAAM;AAAA,QACN,OAAO;AAAA;AAEX,aAAO,KAAK;AAAA,WAEX;AACD,YAAM,EAAE,SAAS,oBAAW,cAAc;AAC1C,aAAO,OAAO;AACd,kBAAY,KAAK;AAAA;AAAA;AAGzB,WAAS,OAAO,KAAK,CAAC,GAAG,MAAM,IAAI;AACnC,QAAM,SAAS,WACT,MAAM;AACJ,UAAM,QAAQ,OAAO;AACrB,QAAI,IAAI;AACR,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,YAAM,KAAK,OAAO;AAClB,YAAM,IAAI,IAAI,IAAI;AAClB,QAAE,MAAM,QAAQ,SAAS;AACzB,UAAI,SAAS,MAAM,MAAM,QAAW;AAChC,YAAI,EAAE;AAAA;AAAA;AAGd,YAAQ,QAAQ;AAAA,MAElB;AACN,QAAM,gBAAgB,YAAY,QAAQ;AAC1C,QAAM,SAAS,WACT,MAAM,OAAO,oBAAoB,UAAU,iBAC3C;AACN,MAAI,UAAU;AACV,cAAU,MAAM;AACZ;AACA,aAAO,iBAAiB,UAAU,eAAe;AAAA;AAErD,gBAAY,MAAM;AACd;AACA,kBAAY,QAAQ,OAAK;AAAA;AAAA;AAGjC,SAAO;AAAA,OACA;AAAA,IACH;AAAA,IACA;AAAA;AAAA;AAIR,+BAA+B;AAC3B,SAAO,cAAc;AAAA,IACjB,SAAS;AAAA,IACT,SAAS;AAAA,IACT,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,WAAW;AAAA;AAAA;AAKnB,IAAM,0BAA0B,OAAmD;AACnF,IAAM,4BAA4B;AAAA,EAC9B,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA;AAER,oBAAoB,GAAG;AACnB,SAAO,SAAS,MAAM,SAAS,EAAE,UAAU,SAAS,EAAE,MAAM;AAAA;AAEhE,qBAAqB,GAAG;AACpB,SAAO,SAAS,MAAM,SAAS,EAAE;AAAA;AAErC,uBAAuB,GAAG;AACtB,MAAI,CAAC,SAAS;AACV,WAAO;AACX,SAAQ,SAAS,EAAE,QAAQ,SAAS,EAAE,QAAQ,SAAS,EAAE,QAAQ,SAAS,EAAE;AAAA;AAMhF,uBAAuB,GAAG;AACtB,SAAO,SAAS,KAAK,IAAI,OAAO;AAAA;AAEpC,iCAAiC,GAAG;AAChC,MAAI,CAAC,cAAc,IAAI;AAEnB,QAAK,MAAwC;AACzC,cAAQ,KAAK;AAAA;AAEjB,WAAO;AAAA;AAEX,QAAM,YAAY;AAAA,IACd,EAAE,OAAO,cAAc,cAAc,EAAE;AAAA,IACvC,EAAE,OAAO,cAAc,cAAc,EAAE;AAAA,IAEtC,OAAO,SACP,KAAK;AACV,SAAO,IAAI;AAAA;AAEf,4BAA4B,GAAG;AAC3B,QAAM,aAAa;AACnB,MAAI,QAAQ,IAAI;AACZ,UAAM,MAAM,EAAE,IAAI;AAClB,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACjC,YAAM,IAAI,IAAI;AACd,iBAAW,KAAK,GAAG;AAAA;AAAA,aAGlB,YAAY,IAAI;AACrB,eAAW,KAAK,EAAE;AAAA,aAEb,cAAc,IAAI;AACvB,eAAW,KAAK,wBAAwB;AAAA,aAEnC,SAAS,MAAM,SAAS,IAAI;AACjC,eAAW,KAAK,eAAe,cAAc;AAAA,SAE5C;AAED,QAAK,MAAwC;AACzC,cAAQ,KAAK;AAAA;AAAA;AAGrB,SAAO;AAAA;AAEX,kCAAkC,aAAa;AAC3C,QAAM,KAAK,WAAW,eAAe,YAAY,MAAM,UAAU;AACjE,MAAI,WAAW,cAAc;AACzB,eAAW,KAAK,IAAI;AAEhB,UAAI,GAAG,eAAe,IAAI;AACtB,cAAM,IAAI,GAAG;AACb,YAAI,SAAS,IAAI;AACb,aAAG,KAAK,mBAAmB,GAAG,IAAI,KAAK;AAAA,mBAElC,SAAS,IAAI;AAClB,cAAI,CAAC,EAAE,SAAS,OAAO;AACnB,eAAG,KAAK,mBAAmB,GAAG,IAAI,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAM3D,QAAM,KAAK,cAAc;AACzB,UAAQ,yBAAyB;AACjC,SAAO;AAAA;AAEX,kCAAkC,QAAQ;AACtC,SAAO,cAAc,yBAAyB,MAAM,yBAAyB,UAAU;AAAA;AAG3F,IAAM,mBAAoB,OAAyC,qBAAqB;AAExF,8BAA8B,GAAG,SAAS;AACtC,SAAQ,aAAa,gBAEhB,GAAE,SAAS,MAER,EAAE,SAAS,QAGX,EAAE,SAAS,wBAEX,EAAE,SAAS,iCAEb,YAAW,QAAQ,WAAW,KAAM;AAAA;AAG9C,0BAA0B,SAAS;AAC/B,MAAI;AACA,QAAI,CAAC,SAAS;AACV,aAAO;AAAA;AAEX,UAAM,IAAI;AACV,YAAQ,QAAQ,GAAG;AACnB,YAAQ,WAAW;AACnB,WAAO;AAAA,WAEJ,GAAP;AACI,WAAO,qBAAqB,GAAG;AAAA;AAAA;AAGvC,mBAAmB,YAAY,OAAO;AAClC,MAAI;AACA,WAAO,WAAW,MAAM;AAAA,UAE5B;AACI,WAAO;AAAA;AAAA;AAGf,IAAI,aAAa;AACjB,uBAAuB,MAAM,aAAa,MAAM,KAAK,IAAI;AACrD,QAAM,UAAU,WAAW,OAAO,QAAQ;AAC1C,QAAM,YAAY,iBAAiB;AACnC,QAAM,SAAS,MAAM,WAAW,OAAO;AACvC,MAAI,CAAC,YAAY;AACb,iBAAa,IAAI;AACjB,QAAI,UAAU;AACV,aAAO,iBAAiB,WAAW,CAAC,MAAM;AACtC,YAAI,EAAE,aAAa,EAAE,UAAU;AAC3B;AAAA;AAEJ,YAAI,WAAW,WAAW,IAAI;AAC9B,YAAI,EAAE,gBAAgB,OAAO,cAAc;AACvC,qBAAW,WAAW,IAAI;AAAA,eAEzB;AACD,qBAAW,WAAW,IAAI;AAAA;AAE9B,YAAI,YAAY,OAAO,KAAK,SAAS,WAAW,SAAS,GAAG;AACxD,cAAI,EAAE,QAAQ,MAAM;AAChB,qBAAS;AAAA,qBAEJ,SAAS,UAAU,EAAE,MAAM;AAChC,gBAAI,EAAE,aAAa,MAAM;AACrB,uBAAS,WAAW,EAAE;AAAA,mBAErB;AACD,uBAAS,WAAW,EAAE,KAAK,EAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOrD,MAAI,QAAQ,WAAW,IAAI;AAC3B,MAAI;AACJ,MAAI,aAAa,SAAS;AACtB,QAAI,CAAC,OAAO;AACR,mBAAa,IAAI;AACjB,cAAQ;AAAA,QACJ,SAAS,IAAI;AAAA,QACb,gBAAgB,IAAI;AAAA,QACpB,WAAW;AAAA,QACX,aAAa;AAAA,QACb,KAAK,QAAQ;AAAA,QACb,QAAQ,QAAQ;AAAA,QAChB,QAAQ,KAAK,MAAM;AACf,cAAI,MAAM;AACN,iBAAK,UAAU,OAAO;AAAA,iBAErB;AACD,mBAAO,KAAK,UAAU;AAAA;AAAA;AAAA,QAG9B,KAAK,KAAK,OAAO;AACb,cAAI;AACA,kBAAM,WAAW,QAAQ,QAAQ;AACjC,kBAAM,OAAO,SAAS,SAAS,QAAQ,WAAW,UAAU;AAC5D,oBAAQ,QAAQ,KAAK;AACrB,gBAAI,aAAa,QAAQ,YAAY,MAAM,UAAU,MAAM;AACvD,qBAAO,cAAc,IAAI,aAAa,KAAK;AAAA,gBACvC,UAAU;AAAA,gBACV;AAAA,gBACA,aAAa;AAAA;AAAA;AAAA,mBAIlB,GAAP;AACI,uBAAW,QAAQ,qBAAqB,GAAG;AAAA;AAAA;AAAA,QAGnD,QAAQ;AACJ,eAAK,QAAQ,QAAQ,CAAC,GAAG,MAAM,KAAK,WAAW;AAAA;AAAA,QAEnD,WAAW,GAAG;AACV,gBAAM,OAAO,KAAK,QAAQ,IAAI;AAE9B,cAAI,MAAM;AACN,iBAAK,QAAQ;AAAA;AAGjB,gBAAM,OAAO,KAAK,eAAe,IAAI;AACrC,cAAI,MAAM;AACN;AAAA;AAEJ,iBAAO,KAAK,UAAU;AACtB,eAAK,QAAQ,OAAO;AACpB,kBAAQ,WAAW;AAAA;AAAA,QAEvB,QAAQ,GAAG;AAKP,gBAAM,OAAO,QAAQ,QAAQ;AAC7B,cAAI,CAAC,MAAM;AACP,mBAAO;AAAA;AAEX,iBAAO,KAAK,QAAQ,GAAG,UAAU,YAAY;AAAA;AAAA,QAEjD,OAAO,GAAG;AACN,gBAAM,OAAO;AACb,cAAI,WAAW,MAAM,KAAK,IAAI,CAAC,OAAM;AACjC,kBAAM,OAAO,QAAQ,QAAQ;AAC7B,gBAAI,CAAC,MAAM;AACP,qBAAQ,KAAK,QAAQ;AAAA;AAEzB,iBAAK,QAAQ,UAAU,YAAY;AAAA,aACpC;AAAA,YACC,WAAW;AAAA,YACX,OAAO;AAAA;AAEX,cAAI,aAAa,MAAM,MAAM,SAAS,CAAC,MAAM;AACzC,iBAAK,KAAK,OAAO,IAAI;AAAA,aACtB,KAAK,EAAE,MAAM,MAAM,OAAO;AAE7B,gBAAM,UAAU,KAAK,SAAS;AAC9B,eAAK,eAAe,IAAI,SAAS,MAAM;AACnC;AACA;AAAA;AAEJ,eAAK,QAAQ,IAAI,SAAS;AAC1B,iBAAO;AAAA;AAAA,QAEX,QAAQ,GAAG,GAAG;AACV,gBAAM,YAAY,KAAK;AACvB,eAAK,QAAQ,IAAI,GAAG;AACpB,eAAK,KAAK,GAAG;AAEb,gBAAM,OAAO,MAAM,WAAW,SAAS,CAAC,MAAM;AAC1C,iBAAK,KAAK,GAAG;AAAA,aACd,KAAK;AAAA,YACJ,WAAW;AAAA,YACX,MAAM;AAAA;AAEV,eAAK,eAAe,IAAI,GAAG;AAC3B,iBAAO;AAAA;AAAA,QAEX,WAAW,GAAG,MAAM;AAChB,cAAI,IAAI,KAAK,QAAQ,IAAI;AACzB,cAAI,GAAG;AACH,cAAE,QAAQ,UAAU,YAAY;AAAA;AAAA;AAAA;AAI5C,iBAAW,IAAI,MAAM;AAAA,WAEpB;AACD,mBAAa,MAAM;AAAA;AAAA,SAGtB;AACD,iBAAa,IAAI;AACjB,YAAQ;AAAA;AAEZ,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,yBAAyB,KAAK,cAAc,MAAM;AAC9C,QAAM,EAAE,WAAW,UAAU,cAAc;AAC3C,MAAI,SAAS;AACb,MAAI,QAAQ;AACZ,MAAI,UAAU;AACd,MAAI,UAAU;AACd,MAAI,aAAa,OAAO;AACpB,cAAU,CAAC,MAAM,MAAM,QAAQ,OAAO,MAAM;AAC5C,aAAS,MAAM,MAAM,WAAW,OAAO;AACvC,YAAQ,MAAM,MAAM;AACpB,cAAU,MAAM,OAAO;AACvB,QAAI,QAAQ,SAAS,MAAM;AACvB,YAAM,KAAK,OAAO,MAAM;AACxB,cAAQ,QAAQ;AAAA;AAEpB,gBAAY,MAAM;AACd,UAAI,SAAS,OAAO;AAChB,gBAAQ;AAAA;AAAA;AAAA,SAIf;AAED,QAAK,MAAwC;AACzC,cAAQ,KAAK;AAAA;AAEjB,cAAU,IAAI;AAAA;AAElB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,2BAA2B,KAAK,cAAc,MAAM;AAChD,QAAM,EAAE,WAAW,UAAU,cAAc;AAC3C,MAAI,SAAS;AACb,MAAI,QAAQ;AACZ,MAAI,UAAU;AACd,MAAI,UAAU;AACd,MAAI,aAAa,OAAO;AAEpB,QAAK,MAAwC;AACzC,gBAAU,MAAM,QAAQ,KAAK;AAC7B,UAAI,MAAM;AACN,gBAAQ;AAAA;AAAA;AAGhB,aAAS,MAAM,MAAM,WAAW,OAAO;AACvC,YAAQ,MAAM,MAAM;AACpB,cAAU,MAAM,OAAO;AACvB,QAAI,QAAQ,SAAS,MAAM;AACvB,YAAM,KAAK,OAAO,MAAM;AACxB,cAAQ,QAAQ;AAAA;AAAA,SAGnB;AAED,QAAK,MAAwC;AACzC,cAAQ,KAAK;AAAA;AAEjB,cAAU,IAAI;AAAA;AAElB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,IAAI,qBAAqB;AACzB,oBAAoB,KAAK,cAAc,MAAM;AACzC,MAAI,uBAAuB,QAAW;AAClC,yBAAqB,cAAc,gBAAgB;AAAA;AAEvD,SAAO,qBACD,gBAAgB,KAAK,cAAc,QACnC,kBAAkB,KAAK,cAAc;AAAA;AAO/C,uBAAuB,SAAS;AAC5B,QAAM,eAAe,KAAK,QAAQ;AAClC,QAAM,YAAY,KAAK,QAAQ;AAC/B,QAAM,UAAU,IAAI;AACpB,QAAM,QAAQ,KAAK,QAAQ;AAC3B,QAAM,SAAS,SAAS;AAAA,IACpB,MAAM;AACF,aAAO,QAAQ;AAAA;AAAA,IAEnB,IAAI,GAAG;AACH,UAAI,CAAC,SAAS,IAAI;AAEd,YAAK,MAAwC;AACzC,kBAAQ,KAAK,sCAAsC,OAAO,cAAc;AAAA;AAE5E;AAAA;AAEJ,cAAQ,QAAQ,KAAK,IAAI,GAAG,MAAM;AAAA;AAAA;AAG1C,QAAM,cAAc,SAAS;AAAA,IACzB,MAAM;AACF,aAAO,aAAa;AAAA;AAAA,IAExB,IAAI,GAAG;AACH,UAAI,CAAC,SAAS,IAAI;AAEd,YAAK,MAAwC;AACzC,kBAAQ,KAAK,2CAA2C,OAAO,cAAc;AAAA;AAEjF;AAAA;AAEJ,mBAAa,QAAQ,OAAO,GAAG,GAAG,SAAS;AAE3C,aAAO,QAAS,cAAa,QAAQ,KAAK,SAAS;AAAA;AAAA;AAG3D,QAAM,WAAW,SAAS;AAAA,IACtB,MAAM;AACF,aAAO,UAAU;AAAA;AAAA,IAErB,IAAI,GAAG;AACH,UAAI,CAAC,SAAS,IAAI;AAEd,YAAK,MAAwC;AACzC,kBAAQ,KAAK,wCAAwC,OAAO,cAAc;AAAA;AAE9E;AAAA;AAEJ,gBAAU,QAAQ;AAAA;AAAA;AAG1B,QAAM,WAAW,SAAS,MAAM,KAAK,KAAK,MAAM,QAAQ,SAAS;AAEjE,cAAY,QAAQ,aAAa;AACjC,QAAM,OAAO,MAAM,EAAE,YAAY;AACjC,QAAM,OAAO,MAAM,EAAE,YAAY;AACjC,QAAM,QAAQ,MAAO,YAAY,QAAQ;AACzC,QAAM,OAAO,MAAO,YAAY,QAAQ,SAAS;AACjD,QAAM,CAAC,OAAO,WAAW,OAAK;AAC1B,QAAI,YAAY,QAAQ,SAAS,OAAO;AACpC,kBAAY,QAAQ,SAAS;AAAA;AAAA,KAElC,EAAE,WAAW;AAEhB,SAAO;AAAA,IAEH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IAEA;AAAA,IAEA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,4BAA4B,OAAO,SAAS;AACxC,QAAM,WAAW,KAAK;AACtB,QAAM,aAAa,cAAc;AAAA,OAC1B;AAAA,MACC,aAAa;AAAA,MACb,UAAU;AAAA;AAAA,OAEX;AAAA,IACH,OAAO,SAAS,MAAM,SAAS,MAAM;AAAA;AAEzC,QAAM,SAAS,SAAS,MAAM;AAC1B,UAAM,SAAQ,SAAS;AACvB,QAAI,CAAC,MAAM,QAAQ;AACf,aAAO;AACX,WAAO,OAAM,MAAM,WAAW,OAAO,OAAO,WAAW,OAAO,QAAQ,WAAW,SAAS;AAAA;AAE9F,SAAO;AAAA,OACA;AAAA,IACH;AAAA;AAAA;AAQR,gBAAgB,SAAS;AACrB,QAAM,UAAU;AAChB,QAAM,KAAM,WAAW,QAAQ,aAAc;AAC7C,QAAM,OAAO,WAAW,UAAU,QAAQ,QAAQ,QAAQ,OAAO;AACjE,QAAM,KAAM,WAAW,WAAW,QAAQ,WAAW,QAAQ,UAAW,KAAK;AAE7E,MAAK,MAAwC;AACzC,QAAI,WAAW,QAAQ,UAAU,WAAW,QAAQ,YAAY,OAAO;AACnE,cAAQ,KAAK;AAAA;AAAA;AAGrB,MAAI,UAAU;AACd,MAAI,iBAAiB;AACrB,QAAM,MAAM,IAAI;AAChB,QAAM,SAAS,MAAM;AACjB,kBAAc;AACd,iBAAa;AAAA;AAGjB,QAAM,QAAQ,WACR,MAAO,UAAU,YAAY,MAAO,IAAI,QAAQ,MAAO,MACvD;AACN,MAAI,MAAM;AACN,UAAM,SAAS,UAAW,KAAI,QAAQ,KAAK,MAAM,IAAI,QAAQ,WAAW;AACxE,qBAAiB,WAAW,OAAO;AAAA,SAElC;AACD;AAAA;AAEJ,cAAY;AACZ,SAAO;AAAA,IACH;AAAA,IACA;AAAA;AAAA;AAQR,oBAAoB,SAAS;AACzB,QAAM,YAAa,WAAW,QAAQ,aAAc;AACpD,QAAM,OAAO,WAAW,UAAU,QAAQ,QAAQ,QAAQ,OAAO;AACjE,SAAO,OAAO;AAAA,IACV;AAAA,IACA;AAAA,IACA,QAAQ,KAAK;AAAA;AAAA;AAQrB,2BAA2B,SAAS;AAChC,QAAM,YAAa,WAAW,QAAQ,aAAc;AACpD,QAAM,OAAO,WAAW,UAAU,QAAQ,QAAQ,QAAQ,OAAO;AACjE,SAAO,OAAO;AAAA,IACV;AAAA,IACA;AAAA,IACA,QAAQ,MAAM,YAAY;AAAA;AAAA;AAIlC,mBAAmB,QAAQ,MAAM;AAC7B,SAAO,SAAS,MAAM;AAClB,UAAM,IAAI,OAAO;AACjB,QAAI,CAAC,MAAM;AACP,aAAO;AAAA;AAEX,UAAM,IAAI,MAAM,QAAQ,SAAS,KAAK,SAAS,SAAS;AACxD,UAAM,QAAQ;AACd,WAAO,EAAE,QAAQ,OAAO,OAAK;AACzB,YAAM,IAAI,EACL,QAAQ,KAAK,IACb,QAAQ,KAAK,IACb;AAEL,UAAI,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,KAAK;AAC/B,eAAO,GAAG;AAAA;AAEd,YAAM,IAAI,QAAQ,KAAK,EAAE,CAAC,KAAK,EAAE;AACjC,aAAO,MAAM,SAAY,IAAI,GAAG,OAAO;AAAA;AAAA;AAAA;AAYnD,iBAAiB,QAAQ,MAAM,YAAY,KAAK,iBAAiB,OAAO;AACpE,SAAO,SAAS,MAAM;AAClB,UAAM,IAAI,OAAO;AACjB,UAAM,IAAI,OAAO;AACjB,QAAI,MAAM;AACN,aAAO,eAAe,GAAG,GAAG,GAAG;AACnC,QAAI,CAAC,GAAG;AACJ,aAAO;AAAA;AAEX,UAAM,YAAY,EAAE,MAAM;AAC1B,QAAI,IAAI;AACR,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,UAAI,eAAe,UAAU;AAC7B,UAAI,aAAa,aAAa,SAAS,OAAO,KAAK;AAC/C,cAAM,IAAI;AACV,YAAI,QAAO;AACX,YAAI,IAAI,EAAE,KAAK;AACf,YAAI,GAAG;AACH,cAAI,UAAU,EAAE,GAAG;AACnB,cAAI,YAAY,EAAE,QAAQ;AAC1B,cAAI,KAAK;AACT,aAAG;AACC,gBAAI,YAAY,YAAY,EAAE,OAAO;AAEjC,kBAAK,MAAwC;AACzC,wBAAQ,KAAK,2BAA2B,UAAU;AAAA;AAAA;AAG1D,wBAAY,EAAE;AACd,sBAAU,EAAE,GAAG;AACf,2BAAe,aAAa,MAAM,GAAG,CAAC,EAAE,GAAG;AAC3C,sBAAU,OAAO,IAAI,IAAI,GAAG,EAAE;AAC9B,cAAE;AAAA,mBACI,IAAI,EAAE,KAAK;AAGrB,cAAI,CAAC,gBAAgB,MAAK,OAAO,OAAO,MAAK,SAAS,GAAG;AACrD;AAAA;AAAA,eAGH;AACD,yBAAe;AACf,kBAAQ,KAAK,oCAAoC;AAAA;AAAA;AAGzD,UAAI,SAAS,IAAI;AACb,YAAI,CAAC,cAAc;AAEf,cAAK,MAAwC;AACzC,oBAAQ,KAAK,SAAS,UACjB,MAAM,GAAG,IAAI,GACb,KAAK,iCAAiC;AAAA;AAE/C,iBAAO,eAAe,UAAU,MAAM,GAAG,IAAI,GAAG,KAAK,YAAY,GAAG,GAAG;AAAA;AAE3E,YAAI,EAAE;AAAA,aAEL;AAED,YAAK,MAAwC;AACzC,kBAAQ,KAAK,SAAS,UACjB,MAAM,GAAG,IAAI,GACb,KAAK,iCAAiC;AAAA;AAE/C,eAAO,eAAe,UAAU,MAAM,GAAG,IAAI,GAAG,KAAK,YAAY,GAAG,GAAG;AAAA;AAE3E,UAAI,CAAC,GAAG;AAEJ,YAAK,MAAwC;AACzC,kBAAQ,KAAK,SAAS,UACjB,MAAM,GAAG,IAAI,GACb,KAAK,iCAAiC;AAAA;AAE/C,eAAO,eAAe,UAAU,MAAM,GAAG,IAAI,GAAG,KAAK,YAAY,GAAG,GAAG;AAAA;AAAA;AAG/E,WAAO;AAAA;AAAA;AAKf,sBAAsB,GAAG;AACrB,SAAO,OAAO,EAAE,WAAW;AAAA;AAE/B,2BAA2B,GAAG;AAC1B,SAAO,SAAS;AAAA;AAEpB,IAAM,0BAA0B,CAAC,GAAG,GAAG,GAAG,aAAa;AACnD,QAAM,WAAW,IAAI;AACrB,QAAM,WAAW,IAAI;AACrB,QAAM,SAAS;AACf,QAAM,WAAW,IAAI;AACrB,MAAI,UAAU;AACd,QAAM,WAAW,CAAC,OAAM;AACpB,UAAM,IAAI,YAAY;AAClB,UAAI;AACA,iBAAS,QAAQ;AACjB,cAAM,SAAS,EAAE,IAAG;AACpB,YAAI,UAAU,SAAS;AACnB,mBAAS,QAAQ,CAAE,MAAM;AAAA,eAExB;AACD,mBAAS,QAAQ,CAAC;AAAA;AAGtB,eAAO,QAAQ,SAAS,QAAQ,EAAE,SAAS,OAAO;AAAA,eAE/C,GAAP;AACI,iBAAS,QAAQ;AACjB,cAAM;AAAA,gBAEV;AACI,iBAAS,QAAQ;AAAA;AAAA;AAGzB,aAAS,QAAQ,IAAI,MAAM,CAAC,MAAM;AAC9B,aAAO,QAAQ,OAAO;AACtB,eAAS,QAAQ;AACjB,aAAO;AAAA;AAAA;AAGf,WAAS,KAAK,CAAC,QAAQ;AACnB,cAAU;AACV,UAAM,MAAM;AACR,UAAI;AAEA,UAAE,EAAE,OAAO;AAAA,eAER,GAAP;AAAA;AAGA,aAAO,EAAE;AAAA,OACV,UAAU,EAAE,MAAM,MAAM,WAAW;AAAA;AAE1C,oBAAkB;AACd,aAAS,EAAE;AAAA;AAEf,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAGR,IAAM,uBAAuB,CAAC,GAAG,GAAG,aAAa;AAC7C,QAAM,EAAE,UAAU,eAAe,UAAU,kBAAkB,KACvD,IACA,EAAE,YAAY,GAAG,UAAU;AACjC,QAAM,EAAE,UAAU,UAAU,UAAU,QAAQ,WAAY,wBAAwB,GAAG,YAAY,IAAI,WAAW;AAChH,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,OACG;AAAA;AAAA;AAGX,IAAM,kBAAkB,CAAC,GAAG,aAAa;AACrC,QAAM,IAAI;AACV,QAAM,SAAS,aAAa,KAAK,KAAK,EAAE,UAAU;AAClD,aAAW,KAAK,OAAO,KAAK,IAAI;AAC5B,QAAI,EAAE,OAAO,KAAK;AACd,UAAI,MAAM,UAAU;AAChB,UAAE,KAAK;AACP,cAAM,SAAS,IAAI;AACnB,YAAI,aAAa;AACjB,cAAM,qBAAqB,MAAM;AAC7B;AACA,uBAAa,MAAM,QAAQ,MAAM;AAC7B,mBAAO,QAAQ;AACf;AAAA,aACD,EAAE,WAAW,OAAO,MAAM;AAAA;AAEjC;AACA,UAAE,YAAY;AACd,UAAE,YAAY,MAAM;AAChB,iBAAO,QAAQ;AACf;AAAA;AAEJ,UAAE,YAAY,MAAO,OAAO,QAAQ;AAEpC,UAAE,WAAW,MAAM,OAAO;AAC1B;AAAA,aAEC;AACD,UAAE,KAAK,EAAE;AACT;AAAA;AAAA;AAGR,QAAI,QAAQ;AACR,YAAM,aAAa,qBAAqB,QAAQ,EAAE,IAAI;AAEtD,QAAE,KAAK;AAAA,WAEN;AACD,YAAM,aAAa,gBAAgB,EAAE,IAAI;AACzC,UAAI,YAAY;AAChB,UAAI;AACJ,UAAI;AACJ,UAAI,WAAW;AACf,UAAI,aAAa,aAAa;AAC1B,cAAM,cAAc,OAAO,KAAK,YAC3B,OAAO,CAAC,MAAM,EAAE,OAAO,KACvB,IAAI,CAAC,MAAM,WAAW;AAC3B,kBAAU,SAAS,MAAM,YACpB,IAAI,CAAC,MAAM,EAAE,QACb,IAAI,CAAC,MAAM,OAAO,IAClB,OAAO,CAAC,MAAM,MAAM;AAEzB,sBAAc,SAAS,MAAM,YAAY,KAAK,CAAC,MAAM;AACjD,iBAAO,CAAC,CAAC,OAAO,EAAE;AAAA;AAEtB,mBAAW,MAAM;AACb,iBAAO,OAAO,KAAK,YACd,OAAO,CAAC,MAAM,EAAE,OAAO,KACvB,OAAO,CAAC,GAAG,MAAM;AAElB,cAAE,KAAK,WAAW,GAAG;AACrB,mBAAO;AAAA,aACR;AAAA;AAAA,aAGN;AACD,cAAM,cAAc,OAAO,KAAK,YAAY,IAAI,CAAC,MAAM,WAAW;AAClE,kBAAU,SAAS,MAAM;AACrB,iBAAO,YACF,IAAI,CAAC,MAAM,OAAO,EAAE,UACpB,OAAO,CAAC,MAAM,MAAM,QACpB,OAAO,CAAC,MAAM;AACf,mBAAO,EAAE,KAAK;AAAA;AAAA;AAGtB,oBAAY,SAAS,MAAM;AACvB,iBAAO,YAAY,KAAK,CAAC,MAAM;AAC3B,mBAAQ,OAAO,EAAE,cACZ,UAAU,OAAO,EAAE,YAChB,OAAO,EAAE;AAAA;AAAA;AAGzB,sBAAc,SAAS,MAAM,YAAY,KAAK,CAAC,MAAM;AACjD,iBAAO,CAAC,CAAC,OAAO,EAAE;AAAA;AAEtB,mBAAW,MAAM;AACb,iBAAO,OAAO,KAAK,YACd,OAAO,CAAC,MAAM,EAAE,OAAO,KACvB,OAAO,CAAC,GAAG,MAAM;AAElB,cAAE,KAAK,WAAW,GAAG;AACrB,mBAAO;AAAA,aACR;AAAA;AAAA;AAGX,QAAE,KAAK;AAAA,QACH;AAAA,WACG;AAAA,QACH;AAAA,QACA;AAAA;AAEJ,UAAI,WAAW;AACX,UAAE,GAAG,YAAY;AACjB,cAAM,OAAO,OAAO,KAAK,EAAE,IAAI,OAAO,CAAC,MAAM,EAAE,OAAO,OAAO,SAAS,EAAE,GAAG;AAC3E,UAAE,GAAG,SAAS,MAAM;AAEhB,eAAK,QAAQ,CAAC,MAAM;AAChB,kBAAM,QAAQ,EAAE,GAAG,GAAG;AACtB,gBAAI,OAAO;AACP;AAAA;AAAA;AAAA;AAIZ,UAAE,GAAG,SAAS,MAAM;AAChB,eAAK,QAAQ,CAAC,MAAM;AAChB,kBAAM,QAAQ,EAAE,GAAG,GAAG;AACtB,gBAAI,OAAO;AACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOxB,SAAO;AAAA;AAEX,uBAAuB,OAAO;AAC1B,QAAM,WAAW;AACjB,QAAM,aAAa,gBAAgB,EAAE,SAAS;AAK9C,QAAM,kBAAkB,SAAS,WAAW;AAG5C,WAAS,QAAQ,CAAC,MAAM,EAAE;AAC1B,SAAO;AAAA;AAKX,IAAM,qBAAqB,OAAmD;AAC9E,iBAAiB,YAAY;AACzB,MAAI,YAAY;AACZ,WAAO,QAAQ;AAAA;AAGf,WAAO,OAAO;AAAA;AAMtB,mBAAmB,YAAY;AAC3B,QAAM,UAAU,IAAI,OAAO,KAAK,WAAW;AAC3C,QAAM,iBAAiB,IAAI,WAAW;AACtC,QAAM,SAAS,IAAI,WAAW;AAC9B,QAAM,OAAO,IAAI;AACjB,MAAI,WAAW;AACf,QAAM,QAAQ;AACd,QAAM,sBAAsB,CAAC,MAAM;AAC/B,WAAQ,iBAAgB,KAAK,EAAE,OAAO,iBAAiB,aACnD,aAAa,IACX,EAAE,UACF;AAAA;AAEV,QAAM,aAAa,CAAC,SAAQ,aAAa;AACrC,QAAI,MAAM,UAAS;AACf,aAAO,MAAM;AAAA;AAEjB,UAAM,IAAI,SAAS,MAAM;AACzB,QAAI,CAAC,GAAG;AACJ,aAAO,IAAI;AAAA;AAEf,QAAI,IAAI,WAAW,KAAK,MAAM;AAC9B,QAAI,UAAU,IAAI;AACd,aAAO,EAAE,KAAK,CAAC,MAAM;AACjB,eAAQ,MAAM,WAAU,KAAK,oBAAoB;AAAA;AAAA;AAIzD,QAAI,WAAW,IAAI;AAEf,aAAO,KAAK,oBAAoB;AAAA;AAEpC,WAAQ,MAAM,WAAU,SAAS,MAAM,oBAAoB,SAAS,MAAM;AAAA;AAE9E,QAAM,iBAAiB,WAAW,WAC5B,UAAU,WAAW,oBACjB,WAAW,mBACX,OACJ;AACN,MAAI,oBAAoB;AACxB,MAAI,gBAAgB;AAChB,UAAM,eAAe,WAAW,WAAW,UAAU;AACrD,QAAI,UAAU,eAAe;AACzB,mBAAa,KAAK,CAAC,MAAM;AACrB,iBAAS,QAAQ,EAAE;AAAA;AAEvB,0BAAoB;AAAA,WAEnB;AACD,eAAS,QAAQ,aAAa;AAAA;AAAA,SAGjC;AACD,aAAS,QAAQ;AAAA;AAErB,QAAM,qBAAqB,IAAI;AAC/B,QAAM,gBAAgB,MAAM,mBAAmB,SAAS;AAAA,IACpD,MAAM;AAAA,IACN,WAAW;AAAA;AAEf,QAAM,CAAC,QAAQ,UAAU,qBAAqB,CAAC,CAAC,GAAG,IAAI,OAAO;AAC1D,QAAI,MAAM,WAAW,YAAY,gBAAgB;AAC7C,WAAK,QAAQ;AAAA,WAEZ;AACD,YAAM,WAAU,CAAC,MAAO,KAAK,QAAQ,UAAU,IAAI,IAAI,OAAO;AAG9D,YAAM,IAAI,WAAW,GAAG;AACxB,UAAI,UAAU,IAAI;AACd,UAAE,KAAK;AAAA,aAEN;AACD,iBAAQ;AAAA;AAAA;AAAA,KAGjB;AAAA,IACC,WAAW,CAAC;AAAA;AAEhB,QAAM,KAAK,CAAC,MAAM,SAAS;AACvB,QAAI,WAAW,SAAS;AACpB,aAAO,KAAK,WAAW,QAAQ,KAAK,OAAO,MAAM;AAAA;AAErD,WAAO,UAAU,QAAQ,MAAM,MAAM,KAAK,CAAC,GAAG,IAAI,GAAG,OAAO,IAAI;AAAA;AAEpE,QAAM,MAAM,CAAC,MAAM,SAAS;AACxB,WAAO,GAAG,MAAM,MAAM;AAAA;AAE1B,QAAM,YAAY,CAAC,GAAG,MAAM;AACxB,QAAI,QAAQ,MAAM,QAAQ,MAAM,GAAG;AAE/B,UAAK,MAAwC;AACzC,gBAAQ,KAAK,qBAAqB;AAAA;AAAA,WAGrC;AACD,cAAQ,MAAM,KAAK;AAAA;AAEvB,WAAO,MAAM;AAEb;AACI,qBAAe,MAAM,KAAK;AAAA;AAAA;AAGlC,QAAM,eAAe,CAAC,MAAM;AACxB,UAAM,QAAQ,QAAQ,MAAM,QAAQ;AACpC,QAAI,SAAS,GAAG;AACZ,YAAM,aAAa;AAAA,QACf,OAAO;AAAA,QACP,SAAS,SAAS,WAAW;AAAA,QAC7B,GAAG,QAAQ;AAAA,QACb,KAAK,CAAC,MAAM,KAAK,MAAM;AACzB,UAAI,YAAY;AACZ,YAAI,MAAM,WAAW,UAAU;AAE3B,cAAK,MAAwC;AACzC,oBAAQ,KAAK,+CAA+C;AAAA;AAEhE,mBAAS,QAAQ;AAAA;AAErB,YAAI,MAAM,OAAO,OAAO;AAEpB,cAAK,MAAwC;AACzC,oBAAQ,KAAK,sCAAsC,kCAAkC;AAAA;AAEzF,iBAAO,QAAQ;AAAA;AAAA,aAGlB;AAED,YAAK,MAAwC;AACzC,kBAAQ,MAAM;AAAA;AAAA;AAGtB,cAAQ,MAAM,OAAO,OAAO;AAAA,WAE3B;AAED,UAAK,MAAwC;AACzC,gBAAQ,KAAK,qBAAqB;AAAA;AAAA;AAI1C;AACI,aAAO,eAAe,MAAM;AAAA;AAEhC,WAAO,MAAM;AAAA;AAEjB,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAOR,iBAAiB,YAAY;AACzB,QAAM,IAAI,UAAU;AACpB,UAAQ,oBAAoB;AAC5B,SAAO;AAAA;AAIX,IAAM,gBAAgB,OAAmD;AACzE,yBAAyB,KAAK,OAAO;AACjC,QAAM,IAAI,KAAK,UAAU,SAAY,KAAK;AAC1C,MAAI,QAAQ,eAAe;AAC3B,SAAO;AAAA;AAEX,qBAAqB,cAAc;AAC/B,QAAM,IAAI;AACV,QAAM,QAAQ,OAAO,eAAe;AAEpC,MAAI,UAAU,GAAG;AAEb,QAAK,MAAwC;AACzC,cAAQ,KAAK;AAAA;AAGjB,WAAO,IAAI,SAAS,gBAAgB,eAAe;AAAA;AAEvD,MAAI,UAAU,QAAW;AAGrB,WAAO,IAAI,SAAS,gBAAgB,eAAe;AAAA;AAEvD,MAAI,SAAS,eAAe;AACxB,UAAM,QAAQ;AAAA;AAElB,SAAO;AAAA;AAEX,kBAAkB,gBAAgB,MAAM;AACpC,MAAM,YAAW,SAAS,WAAW,OAAO,KAAK,IAAI,MAAM,QAAQ,IAAI,QAAU,CAAC,UAAU;AACxF,WAAO,YAAY;AAAA;AAEvB,QAAM,QAAQ,IAAI,SAAS,iBAAiB,gBAAgB,SAAS;AACrE,QAAM,WAAW,IAAI,iBAAiB,OAAK;AACvC,UAAM,QAAQ,EAAE,GAAG,OAAO;AAAA;AAE9B,QAAM,OAAO,CAAC,GAAG,MAAM;AACnB,QAAI,SAAS,MAAM,MAAM,GAAG;AACxB,eAAS,QAAQ;AAAA;AAAA,KAEtB;AAAA,IACC,WAAW;AAAA,IACX,OAAO;AAAA;AAEX,QAAM,eAAe,SAAS,cAAc;AAC5C,WAAS,QAAQ,cAAc,EAAE,WAAW;AAC5C,cAAY,MAAM,SAAS;AAC3B,SAAO;AAAA;AAIX,IAAM,gBAAgB,OAAmD;AACzE,IAAM,kBAAkB;AAAA,EAEpB,QAAQ,KAAK;AACT,UAAM,YAAY,IAAI;AACtB,UAAM,IAAI,SAAS;AACnB;AAEI,UAAI,SAAS,SAAS,iBAAiB;AACvC,YAAM,WAAW,IAAI;AACrB,UAAI,QAAQ,IAAI,SAAS;AACrB,cAAM,YAAY,SAAS,GAAG;AAC9B,kBAAU,QAAQ;AAClB,eAAO;AAAA;AAAA;AAAA;AAAA;AAKvB,wBAAwB;AACpB,MAAK,MAAwC;AACzC,UAAM,IAAI;AACV,UAAM,IAAI,OAAO,eAAe;AAChC,QAAI,MAAM,GAAG;AACT,cAAQ,KAAK;AAAA;AAAA;AAGrB,SAAO,OAAO,eAAe,SAAS,MAAM;AAAA;AAGhD,sBAAsB,MAAM,MAAM;AAC9B,QAAM,SAAS,KAAK;AACpB,QAAM,OAAO,UAAU,WAAW,IAC5B,MAAM,UAAU,OAAO,QAAQ,UAAU,GAAG,SACxC,UAAU,KACV,IAAI,CAAC,KAAK,UAAU,QACxB,IAAI,MAAM,KAAK,WACZ,MAAM,GACN,IAAI,OAAK,KAAK;AACvB,OAAK,MAAM,QAAQ,OAAK;AACpB,MAAE,QAAQ,OAAO;AAAA;AAErB,MAAI,UAAU,KAAK,MAAM;AACzB,QAAM,CAAC,QAAQ,OAAO,CAAC,CAAC,GAAG,WAAU;AAEjC,QAAI,UAAU,MAAK,QAAQ;AACvB,YAAK,QAAQ,OAAK;AACd,YAAI,EAAE,UAAU,GAAG;AACf,YAAE,QAAQ;AAAA;AAAA;AAGlB;AAAA;AAEJ,cAAU,MAAK;AACf,eAAW,KAAK,OAAM;AAClB,UAAI,EAAE,UAAU,GAAG;AACf,eAAO,QAAQ,EAAE;AACjB;AAAA;AAAA;AAAA,KAGT;AAAA,IACC,MAAM;AAAA;AAEV,QAAM,QAAQ,OAAK;AACf,SAAK,MAAM,QAAQ,OAAM,EAAE,QAAQ;AAAA,KACpC;AAAA,IACC,MAAM;AAAA,IACN,OAAO;AAAA;AAEX,SAAO;AAAA;AAGX,qBAAqB,OAAO,SAAS;AACjC,QAAM,WAAW,IAAI;AACrB,QAAM,QAAQ,WAAW,QAAQ,QAAQ,QAAQ,QAAQ,CAAC,MAAM;AAChE,QAAM,YAAa,WAAW,QAAQ,aAAc;AACpD,QAAM,OAAO,CAAC,GAAG,MAAM;AACnB,aAAS,MAAM,QAAQ;AAAA,MACnB,MAAM,MAAM;AAAA,MACZ,MAAM,IAAI;AAAA;AAEd,QAAI,SAAS,MAAM,SAAS,WAAW;AACnC,eAAS,MAAM;AAAA;AAAA,KAEpB;AAAA,IACC,WAAW;AAAA,IACX,OAAO;AAAA,OAEJ;AAAA;AAEP,SAAO,SAAS;AAAA;AAGpB,iBAAiB,cAAc,SAAS;AACpC,QAAM,UAAU,KAAK;AACrB,QAAM,WAAW,IAAI;AACrB,QAAM,WAAW,IAAI;AACrB,QAAM,SAAU,WAAW,QAAQ,aAAc;AACjD,QAAM,QAAS,WAAW,QAAQ,SAAW,EAAC,MAAM;AACpD,QAAM,OAAO,SAAS,MAAM;AAExB,UAAM,IAAI,SAAS,UAAU,IAAI,IAAI,SAAS;AAC9C,WAAO,SAAS,MAAM,MAAM;AAAA;AAEhC,QAAM,OAAO,SAAS,MAAM;AAExB,UAAM,IAAI,SAAS,UAAU,IAAI,IAAI;AACrC,WAAO,SAAS,MAAM,MAAM,GAAG,SAAS;AAAA;AAE5C,MAAI,mBAAmB;AACvB,MAAK,AAA0C,WAAW,QAAQ,WAAW;AACzE,UAAM,QAAQ,yBAAyB,WAAW,QAAQ,aAAa,QAAQ,WAAW;AAE1F,uBAAmB,CAAC,MAAM,SAAS,MAAM,SAAS;AAAA,MAC9C;AAAA,MACA,MAAM;AAAA,QACF,OAAO;AAAA,QACP,MAAM,CAAC,GAAG,KAAK;AAAA,QACf,MAAM,CAAC,GAAG,KAAK;AAAA;AAAA,MAEnB,MAAM;AAAA,QACF,MAAM,CAAC,GAAG,KAAK;AAAA,QACf,MAAM,CAAC,GAAG,KAAK;AAAA;AAAA;AAAA;AAI3B,QAAM,SAAS,CAAC,MAAM;AAClB,QAAI,SAAS,MAAM,SAAS,WAAW,GAAG;AAEtC;AAAA;AAGJ,QAAI,SAAS,QAAQ,GAAG;AACpB,YAAM,MAAM,SAAS;AACrB,eAAS,MAAM,OAAO,GAAG;AAEzB,eAAS,QAAQ;AAAA;AAErB,QAAI,SAAS,MAAM,SAAS,QAAQ;AAChC,eAAS,MAAM;AAAA;AAEnB,UAAM,IAAI,MAAM;AAChB,aAAS,MAAM,QAAQ;AACvB,QAAI,kBAAkB;AAClB,uBAAiB,KAAK,OAAO;AAAA;AAAA,KAElC;AAAA,OACI;AAAA,IACH,WAAW;AAAA,IACX,OAAO;AAAA;AAEX,QAAM,OAAO,CAAC,OAAO,MAAM,KAAK;AAChC,QAAM,OAAO,CAAC,OAAO,MAAM,KAAK,CAAC;AACjC,QAAM,OAAO,CAAC,UAAU;AACpB,UAAM,IAAI,KAAK,KAAK,UAAU,IACxB,KAAK,IAAI,OAAO,CAAC,KAAK,MAAM,UAC5B,KAAK,IAAI,OAAO,KAAK,MAAM;AACjC,aAAS,SAAS;AAClB,YAAQ,QAAQ,SAAS,MAAM,SAAS;AACxC,QAAI,kBAAkB;AAClB,uBAAiB,KAAK,OAAO,MAAM,QAAQ;AAAA;AAAA;AAGnD,SAAO;AAAA,IACH,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIR,qCAAqC,IAAI,SAAS,MAAM;AACpD,MAAI,WAAW;AACf,MAAI,SAAS;AACb,MAAI,UAAU;AAEV,UAAM,EAAE,OAAO,OAAO,QAAQ,qBAAqB,eAAe,QAAQ,SAAS;AACnF,eAAW,SAAS,MAAM;AACtB,YAAM,OAAO,OAAO;AACpB,UAAI,CAAC;AACD,eAAO;AACX,aAAO,KAAK,MAAM,KAAK,KAAK,KAAK,IAAI,MAAM,QAAS,MAAK,aAAa,KAAK,cAAc,IAAI,KACzF,KAAK,IAAI,MAAM,QAAS,MAAK,YAAY,KAAK,eAAe,IAAI;AAAA;AAEzE,aAAS;AAAA,SAER;AACD,eAAW,SAAS,MAAM;AAAA;AAE9B,SAAO;AAAA,IACH;AAAA,IACA;AAAA;AAAA;AAIR,IAAM,UAAU;AAEhB,IAAM,cAAc;AACpB,IAAM,SAAS;",
  "names": []
}

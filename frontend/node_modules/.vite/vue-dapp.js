import {
  BaseContract,
  Contract,
  ContractFactory,
  Web3Provider,
  getDefaultProvider,
  lib_exports as lib_exports18
} from "./chunk-IZR7THCA.js";
import {
  Fragment,
  Teleport,
  Transition,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createStaticVNode,
  createVNode,
  defineComponent,
  inject,
  markRaw,
  normalizeClass,
  onMounted,
  onUnmounted,
  openBlock,
  popScopeId,
  pushScopeId,
  ref,
  renderSlot,
  resolveComponent,
  resolveDirective,
  watch,
  withCtx,
  withDirectives
} from "./chunk-E734WVW6.js";
import {
  AbiCoder,
  Base58,
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  FormatTypes,
  Fragment as Fragment2,
  FunctionFragment,
  HDNode,
  Indexed,
  Interface,
  LogDescription,
  ParamType,
  Signer,
  SigningKey,
  SupportedAlgorithm,
  TransactionDescription,
  TransactionTypes,
  TypedDataEncoder,
  UnicodeNormalizationForm,
  Utf8ErrorFuncs,
  Utf8ErrorReason,
  VoidSigner,
  Wallet,
  Wordlist,
  _fetchData,
  _toEscapedUtf8String,
  accessListify,
  checkProperties,
  checkResultErrors,
  computeAddress,
  computeHmac,
  computePublicKey,
  deepCopy,
  defaultAbiCoder,
  defaultPath,
  defineReadOnly,
  entropyToMnemonic,
  fetchJson,
  formatBytes32String,
  getAccountPath,
  getJsonWalletAddress,
  getStatic,
  hashMessage,
  id,
  init_lib as init_lib3,
  init_lib10 as init_lib14,
  init_lib11 as init_lib15,
  init_lib12 as init_lib16,
  init_lib13 as init_lib17,
  init_lib14 as init_lib18,
  init_lib15 as init_lib19,
  init_lib16 as init_lib20,
  init_lib17 as init_lib21,
  init_lib18 as init_lib22,
  init_lib19 as init_lib23,
  init_lib2 as init_lib7,
  init_lib3 as init_lib8,
  init_lib4 as init_lib9,
  init_lib5 as init_lib10,
  init_lib7 as init_lib11,
  init_lib8 as init_lib12,
  init_lib9 as init_lib13,
  isValidMnemonic,
  isValidName,
  keccak256 as keccak2562,
  lib_exports as lib_exports3,
  lib_exports10 as lib_exports15,
  lib_exports11 as lib_exports16,
  lib_exports12 as lib_exports17,
  lib_exports13 as lib_exports19,
  lib_exports14 as lib_exports20,
  lib_exports15 as lib_exports21,
  lib_exports16 as lib_exports22,
  lib_exports2 as lib_exports7,
  lib_exports3 as lib_exports8,
  lib_exports4 as lib_exports9,
  lib_exports5 as lib_exports10,
  lib_exports6 as lib_exports11,
  lib_exports7 as lib_exports12,
  lib_exports8 as lib_exports13,
  lib_exports9 as lib_exports14,
  mnemonicToEntropy,
  mnemonicToSeed,
  namehash,
  nameprep,
  pack,
  parse,
  parseBytes32String,
  poll,
  randomBytes,
  recoverAddress,
  recoverPublicKey,
  resolveProperties,
  ripemd160,
  serialize,
  sha256,
  sha2562,
  sha512,
  shallowCopy,
  shuffled,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String,
  verifyMessage,
  verifyTypedData,
  wordlists
} from "./chunk-4R3KLTPG.js";
import {
  getAddress,
  getContractAddress,
  getCreate2Address,
  getIcapAddress,
  init_lib as init_lib4,
  init_lib2 as init_lib5,
  init_lib3 as init_lib6,
  isAddress,
  keccak256,
  lib_exports as lib_exports4,
  lib_exports2 as lib_exports5,
  lib_exports3 as lib_exports6
} from "./chunk-WPY4IOJC.js";
import {
  commify,
  formatEther,
  formatUnits,
  init_lib as init_lib24,
  lib_exports as lib_exports23,
  parseEther,
  parseUnits
} from "./chunk-BCENLZDW.js";
import {
  ErrorCode,
  Logger,
  arrayify,
  concat,
  hexConcat,
  hexDataLength,
  hexDataSlice,
  hexStripZeros,
  hexValue,
  hexZeroPad,
  hexlify,
  init_lib,
  init_lib2,
  isBytes,
  isBytesLike,
  isHexString,
  joinSignature,
  lib_exports,
  lib_exports2,
  require_bn,
  splitSignature,
  stripZeros,
  zeroPad
} from "./chunk-YSEQAY4U.js";
import {
  __commonJS,
  __export,
  __toModule
} from "./chunk-YOHASWQG.js";

// ../node_modules/@metamask/detect-provider/dist/index.js
var require_dist = __commonJS({
  "../node_modules/@metamask/detect-provider/dist/index.js"(exports, module) {
    "use strict";
    function detectEthereumProvider2({ mustBeMetaMask = false, silent = false, timeout = 3e3 } = {}) {
      _validateInputs();
      let handled = false;
      return new Promise((resolve) => {
        if (window.ethereum) {
          handleEthereum();
        } else {
          window.addEventListener("ethereum#initialized", handleEthereum, { once: true });
          setTimeout(() => {
            handleEthereum();
          }, timeout);
        }
        function handleEthereum() {
          if (handled) {
            return;
          }
          handled = true;
          window.removeEventListener("ethereum#initialized", handleEthereum);
          const { ethereum } = window;
          if (ethereum && (!mustBeMetaMask || ethereum.isMetaMask)) {
            resolve(ethereum);
          } else {
            const message = mustBeMetaMask && ethereum ? "Non-MetaMask window.ethereum detected." : "Unable to detect window.ethereum.";
            !silent && console.error("@metamask/detect-provider:", message);
            resolve(null);
          }
        }
      });
      function _validateInputs() {
        if (typeof mustBeMetaMask !== "boolean") {
          throw new Error(`@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.`);
        }
        if (typeof silent !== "boolean") {
          throw new Error(`@metamask/detect-provider: Expected option 'silent' to be a boolean.`);
        }
        if (typeof timeout !== "number") {
          throw new Error(`@metamask/detect-provider: Expected option 'timeout' to be a number.`);
        }
      }
    }
    module.exports = detectEthereumProvider2;
  }
});

// ../node_modules/vue-dapp/node_modules/ethers/lib/utils.js
var require_utils = __commonJS({
  "../node_modules/vue-dapp/node_modules/ethers/lib/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;
    exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.parseBytes32String = void 0;
    var abi_1 = (init_lib10(), lib_exports10);
    Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
      return abi_1.AbiCoder;
    } });
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return abi_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
      return abi_1.ConstructorFragment;
    } });
    Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
      return abi_1.defaultAbiCoder;
    } });
    Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
      return abi_1.ErrorFragment;
    } });
    Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
      return abi_1.EventFragment;
    } });
    Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
      return abi_1.FormatTypes;
    } });
    Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
      return abi_1.Fragment;
    } });
    Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
      return abi_1.FunctionFragment;
    } });
    Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
      return abi_1.Indexed;
    } });
    Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
      return abi_1.Interface;
    } });
    Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
      return abi_1.LogDescription;
    } });
    Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
      return abi_1.ParamType;
    } });
    Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
      return abi_1.TransactionDescription;
    } });
    var address_1 = (init_lib6(), lib_exports6);
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return address_1.getAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return address_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return address_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
      return address_1.getIcapAddress;
    } });
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return address_1.isAddress;
    } });
    var base64 = __importStar((init_lib13(), lib_exports13));
    exports.base64 = base64;
    var basex_1 = (init_lib11(), lib_exports11);
    Object.defineProperty(exports, "base58", { enumerable: true, get: function() {
      return basex_1.Base58;
    } });
    var bytes_1 = (init_lib2(), lib_exports2);
    Object.defineProperty(exports, "arrayify", { enumerable: true, get: function() {
      return bytes_1.arrayify;
    } });
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return bytes_1.concat;
    } });
    Object.defineProperty(exports, "hexConcat", { enumerable: true, get: function() {
      return bytes_1.hexConcat;
    } });
    Object.defineProperty(exports, "hexDataSlice", { enumerable: true, get: function() {
      return bytes_1.hexDataSlice;
    } });
    Object.defineProperty(exports, "hexDataLength", { enumerable: true, get: function() {
      return bytes_1.hexDataLength;
    } });
    Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
      return bytes_1.hexlify;
    } });
    Object.defineProperty(exports, "hexStripZeros", { enumerable: true, get: function() {
      return bytes_1.hexStripZeros;
    } });
    Object.defineProperty(exports, "hexValue", { enumerable: true, get: function() {
      return bytes_1.hexValue;
    } });
    Object.defineProperty(exports, "hexZeroPad", { enumerable: true, get: function() {
      return bytes_1.hexZeroPad;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return bytes_1.isBytes;
    } });
    Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
      return bytes_1.isBytesLike;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return bytes_1.isHexString;
    } });
    Object.defineProperty(exports, "joinSignature", { enumerable: true, get: function() {
      return bytes_1.joinSignature;
    } });
    Object.defineProperty(exports, "zeroPad", { enumerable: true, get: function() {
      return bytes_1.zeroPad;
    } });
    Object.defineProperty(exports, "splitSignature", { enumerable: true, get: function() {
      return bytes_1.splitSignature;
    } });
    Object.defineProperty(exports, "stripZeros", { enumerable: true, get: function() {
      return bytes_1.stripZeros;
    } });
    var hash_1 = (init_lib9(), lib_exports9);
    Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
      return hash_1._TypedDataEncoder;
    } });
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hash_1.hashMessage;
    } });
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return hash_1.id;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return hash_1.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return hash_1.namehash;
    } });
    var hdnode_1 = (init_lib20(), lib_exports19);
    Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
      return hdnode_1.defaultPath;
    } });
    Object.defineProperty(exports, "entropyToMnemonic", { enumerable: true, get: function() {
      return hdnode_1.entropyToMnemonic;
    } });
    Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
      return hdnode_1.getAccountPath;
    } });
    Object.defineProperty(exports, "HDNode", { enumerable: true, get: function() {
      return hdnode_1.HDNode;
    } });
    Object.defineProperty(exports, "isValidMnemonic", { enumerable: true, get: function() {
      return hdnode_1.isValidMnemonic;
    } });
    Object.defineProperty(exports, "mnemonicToEntropy", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToEntropy;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToSeed;
    } });
    var json_wallets_1 = (init_lib21(), lib_exports20);
    Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
      return json_wallets_1.getJsonWalletAddress;
    } });
    var keccak256_1 = (init_lib4(), lib_exports4);
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_1.keccak256;
    } });
    var logger_1 = (init_lib(), lib_exports);
    Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    var sha2_1 = (init_lib12(), lib_exports12);
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var solidity_1 = (init_lib23(), lib_exports22);
    Object.defineProperty(exports, "solidityKeccak256", { enumerable: true, get: function() {
      return solidity_1.keccak256;
    } });
    Object.defineProperty(exports, "solidityPack", { enumerable: true, get: function() {
      return solidity_1.pack;
    } });
    Object.defineProperty(exports, "soliditySha256", { enumerable: true, get: function() {
      return solidity_1.sha256;
    } });
    var random_1 = (init_lib18(), lib_exports17);
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
      return random_1.shuffled;
    } });
    var properties_1 = (init_lib3(), lib_exports3);
    Object.defineProperty(exports, "checkProperties", { enumerable: true, get: function() {
      return properties_1.checkProperties;
    } });
    Object.defineProperty(exports, "deepCopy", { enumerable: true, get: function() {
      return properties_1.deepCopy;
    } });
    Object.defineProperty(exports, "defineReadOnly", { enumerable: true, get: function() {
      return properties_1.defineReadOnly;
    } });
    Object.defineProperty(exports, "getStatic", { enumerable: true, get: function() {
      return properties_1.getStatic;
    } });
    Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
      return properties_1.resolveProperties;
    } });
    Object.defineProperty(exports, "shallowCopy", { enumerable: true, get: function() {
      return properties_1.shallowCopy;
    } });
    var RLP = __importStar((init_lib5(), lib_exports5));
    exports.RLP = RLP;
    var signing_key_1 = (init_lib15(), lib_exports15);
    Object.defineProperty(exports, "computePublicKey", { enumerable: true, get: function() {
      return signing_key_1.computePublicKey;
    } });
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return signing_key_1.recoverPublicKey;
    } });
    Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
      return signing_key_1.SigningKey;
    } });
    var strings_1 = (init_lib8(), lib_exports8);
    Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
      return strings_1.formatBytes32String;
    } });
    Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
      return strings_1.nameprep;
    } });
    Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
      return strings_1.parseBytes32String;
    } });
    Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return strings_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return strings_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return strings_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return strings_1.toUtf8String;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return strings_1.Utf8ErrorFuncs;
    } });
    var transactions_1 = (init_lib16(), lib_exports16);
    Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
      return transactions_1.accessListify;
    } });
    Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
      return transactions_1.computeAddress;
    } });
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return transactions_1.parse;
    } });
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return transactions_1.recoverAddress;
    } });
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return transactions_1.serialize;
    } });
    Object.defineProperty(exports, "TransactionTypes", { enumerable: true, get: function() {
      return transactions_1.TransactionTypes;
    } });
    var units_1 = (init_lib24(), lib_exports23);
    Object.defineProperty(exports, "commify", { enumerable: true, get: function() {
      return units_1.commify;
    } });
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return units_1.formatEther;
    } });
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return units_1.parseEther;
    } });
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return units_1.formatUnits;
    } });
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return units_1.parseUnits;
    } });
    var wallet_1 = (init_lib22(), lib_exports21);
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return wallet_1.verifyMessage;
    } });
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return wallet_1.verifyTypedData;
    } });
    var web_1 = (init_lib14(), lib_exports14);
    Object.defineProperty(exports, "_fetchData", { enumerable: true, get: function() {
      return web_1._fetchData;
    } });
    Object.defineProperty(exports, "fetchJson", { enumerable: true, get: function() {
      return web_1.fetchJson;
    } });
    Object.defineProperty(exports, "poll", { enumerable: true, get: function() {
      return web_1.poll;
    } });
    var sha2_2 = (init_lib12(), lib_exports12);
    Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
      return sha2_2.SupportedAlgorithm;
    } });
    var strings_2 = (init_lib8(), lib_exports8);
    Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return strings_2.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
      return strings_2.Utf8ErrorReason;
    } });
  }
});

// ../node_modules/vue-dapp/dist/index.esm.js
init_lib10();
var import_detect_provider = __toModule(require_dist());

// ../node_modules/vue-dapp/node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports7,
  errors: () => ErrorCode,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger3,
  providers: () => lib_exports18,
  utils: () => utils_exports,
  version: () => version2,
  wordlists: () => wordlists
});

// ../node_modules/vue-dapp/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var import_bn = __toModule(require_bn());
init_lib2();
init_lib();

// ../node_modules/vue-dapp/node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version = "bignumber/5.4.2";

// ../node_modules/vue-dapp/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
"use strict";
var BN = import_bn.default.BN;
var logger = new Logger(version);
var _constructorGuard = {};
var MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
var _warnedToStringRadix = false;
var BigNumber = class {
  constructor(constructorGuard, hex) {
    logger.checkNew(new.target, BigNumber);
    if (constructorGuard !== _constructorGuard) {
      logger.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o = BigNumber.from(other);
    if (o.isZero()) {
      throwFault("division by zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("cannot modulo negative values", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("cannot raise to negative values", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'and' negative values", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'or' negative values", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'xor' negative values", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot mask negative values", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot shift negative values", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot shift negative values", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error2) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard, toHex(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard, toHex(new BN(value)));
      }
      return logger.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}

// ../node_modules/vue-dapp/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_lib2();
init_lib();
"use strict";
var logger2 = new Logger(version);
var _constructorGuard2 = {};
var Zero = BigNumber.from(0);
var NegativeOne = BigNumber.from(-1);
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger2.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
var zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger2.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.,]+$/)) {
    logger2.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger2.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger2.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var FixedFormat = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard2) {
      logger2.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger2.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key, type, defaultValue) => {
        if (value[key] == null) {
          return defaultValue;
        }
        if (typeof value[key] !== type) {
          logger2.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
        }
        return value[key];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger2.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger2.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard2, signed, width, decimals);
  }
};
var FixedNumber = class {
  constructor(constructorGuard, hex, value, format) {
    logger2.checkNew(new.target, FixedNumber);
    if (constructorGuard !== _constructorGuard2) {
      logger2.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger2.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger2.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger2.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero)) {
      throwFault2("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }
    if (isBytes(value)) {
      return FixedNumber.fromBytes(value, format);
    }
    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error2) {
      if (error2.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error2;
      }
    }
    return logger2.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE = FixedNumber.from(1);
var BUMP = FixedNumber.from("0.5");

// ../node_modules/vue-dapp/node_modules/ethers/lib.esm/ethers.js
init_lib17();
init_lib22();
init_lib7();
init_lib19();

// ../node_modules/vue-dapp/node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment2,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  Logger: () => Logger,
  ParamType: () => ParamType,
  RLP: () => lib_exports5,
  SigningKey: () => SigningKey,
  SupportedAlgorithm: () => SupportedAlgorithm,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _TypedDataEncoder: () => TypedDataEncoder,
  _fetchData: () => _fetchData,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  accessListify: () => accessListify,
  arrayify: () => arrayify,
  base58: () => Base58,
  base64: () => lib_exports13,
  checkProperties: () => checkProperties,
  checkResultErrors: () => checkResultErrors,
  commify: () => commify,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  computePublicKey: () => computePublicKey,
  concat: () => concat,
  deepCopy: () => deepCopy,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath,
  defineReadOnly: () => defineReadOnly,
  entropyToMnemonic: () => entropyToMnemonic,
  fetchJson: () => fetchJson,
  formatBytes32String: () => formatBytes32String,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic,
  hashMessage: () => hashMessage,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName,
  joinSignature: () => joinSignature,
  keccak256: () => keccak256,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  parseEther: () => parseEther,
  parseTransaction: () => parse,
  parseUnits: () => parseUnits,
  poll: () => poll,
  randomBytes: () => randomBytes,
  recoverAddress: () => recoverAddress,
  recoverPublicKey: () => recoverPublicKey,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd160,
  serializeTransaction: () => serialize,
  sha256: () => sha256,
  sha512: () => sha512,
  shallowCopy: () => shallowCopy,
  shuffled: () => shuffled,
  solidityKeccak256: () => keccak2562,
  solidityPack: () => pack,
  soliditySha256: () => sha2562,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad
});
init_lib10();
init_lib6();
init_lib13();
init_lib11();
init_lib2();
init_lib9();
init_lib20();
init_lib21();
init_lib4();
init_lib();
init_lib12();
init_lib23();
init_lib18();
init_lib3();
init_lib5();
init_lib15();
init_lib8();
init_lib16();
init_lib24();
init_lib22();
init_lib14();
init_lib12();
init_lib8();
"use strict";

// ../node_modules/vue-dapp/node_modules/ethers/lib.esm/ethers.js
init_lib();

// ../node_modules/vue-dapp/node_modules/ethers/lib.esm/_version.js
var version2 = "ethers/5.4.7";

// ../node_modules/vue-dapp/node_modules/ethers/lib.esm/ethers.js
"use strict";
var logger3 = new Logger(version2);

// ../node_modules/vue-dapp/node_modules/ethers/lib.esm/index.js
"use strict";
try {
  const anyGlobal = window;
  if (anyGlobal._ethers == null) {
    anyGlobal._ethers = ethers_exports;
  }
} catch (error2) {
}

// ../node_modules/vue-dapp/dist/index.esm.js
var import_utils = __toModule(require_utils());
var ChainId;
(function(ChainId2) {
  ChainId2[ChainId2["Hardhat"] = 31337] = "Hardhat";
  ChainId2[ChainId2["Mainnet"] = 1] = "Mainnet";
  ChainId2[ChainId2["Ropsten"] = 3] = "Ropsten";
  ChainId2[ChainId2["Rinkeby"] = 4] = "Rinkeby";
  ChainId2[ChainId2["Goerli"] = 5] = "Goerli";
  ChainId2[ChainId2["Kovan"] = 42] = "Kovan";
  ChainId2[ChainId2["xDai"] = 100] = "xDai";
})(ChainId || (ChainId = {}));
var CHAIN_NAMES = {
  [ChainId.Hardhat]: "Hardhat",
  [ChainId.Mainnet]: "Mainnet",
  [ChainId.Ropsten]: "Ropsten",
  [ChainId.Kovan]: "Kovan",
  [ChainId.Rinkeby]: "Rinkeby",
  [ChainId.Goerli]: "Goerli",
  [ChainId.xDai]: "xDai"
};
var MULTICALL2_ADDRESS = "0x5ba1e12693dc8f9c48aad8770482f4739beed696";
var MULTICALL2_ABI = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall2.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate",
    outputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      },
      {
        internalType: "bytes[]",
        name: "returnData",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall2.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "blockAndAggregate",
    outputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "blockHash",
        type: "bytes32"
      },
      {
        components: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall2.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      }
    ],
    name: "getBlockHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "blockHash",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getBlockNumber",
    outputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockCoinbase",
    outputs: [
      {
        internalType: "address",
        name: "coinbase",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockDifficulty",
    outputs: [
      {
        internalType: "uint256",
        name: "difficulty",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockGasLimit",
    outputs: [
      {
        internalType: "uint256",
        name: "gaslimit",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "timestamp",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "addr",
        type: "address"
      }
    ],
    name: "getEthBalance",
    outputs: [
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getLastBlockHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "blockHash",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "requireSuccess",
        type: "bool"
      },
      {
        components: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall2.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "tryAggregate",
    outputs: [
      {
        components: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall2.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "requireSuccess",
        type: "bool"
      },
      {
        components: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall2.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "tryBlockAndAggregate",
    outputs: [
      {
        internalType: "uint256",
        name: "blockNumber",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "blockHash",
        type: "bytes32"
      },
      {
        components: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        internalType: "struct Multicall2.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var contractName = "ERC20";
var abi = [
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    payable: true,
    stateMutability: "payable",
    type: "fallback"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  }
];
var bytecode = "0x608060405234801561001057600080fd5b506105dd806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a5576000357c01000000000000000000000000000000000000000000000000000000009004806370a082311161007857806370a0823114610166578063a457c2d71461018c578063a9059cbb146101b8578063dd62ed3e146101e4576100a5565b8063095ea7b3146100aa57806318160ddd146100ea57806323b872dd14610104578063395093511461013a575b600080fd5b6100d6600480360360408110156100c057600080fd5b50600160a060020a038135169060200135610212565b604080519115158252519081900360200190f35b6100f2610290565b60408051918252519081900360200190f35b6100d66004803603606081101561011a57600080fd5b50600160a060020a03813581169160208101359091169060400135610296565b6100d66004803603604081101561015057600080fd5b50600160a060020a03813516906020013561035f565b6100f26004803603602081101561017c57600080fd5b5035600160a060020a031661040f565b6100d6600480360360408110156101a257600080fd5b50600160a060020a03813516906020013561042a565b6100d6600480360360408110156101ce57600080fd5b50600160a060020a038135169060200135610475565b6100f2600480360360408110156101fa57600080fd5b50600160a060020a038135811691602001351661048b565b6000600160a060020a038316151561022957600080fd5b336000818152600160209081526040808320600160a060020a03881680855290835292819020869055805186815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a350600192915050565b60025490565b600160a060020a03831660009081526001602090815260408083203384529091528120546102ca908363ffffffff6104b616565b600160a060020a03851660009081526001602090815260408083203384529091529020556102f98484846104cb565b600160a060020a0384166000818152600160209081526040808320338085529083529281902054815190815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a35060019392505050565b6000600160a060020a038316151561037657600080fd5b336000908152600160209081526040808320600160a060020a03871684529091529020546103aa908363ffffffff61059816565b336000818152600160209081526040808320600160a060020a0389168085529083529281902085905580519485525191937f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929081900390910190a350600192915050565b600160a060020a031660009081526020819052604090205490565b6000600160a060020a038316151561044157600080fd5b336000908152600160209081526040808320600160a060020a03871684529091529020546103aa908363ffffffff6104b616565b60006104823384846104cb565b50600192915050565b600160a060020a03918216600090815260016020908152604080832093909416825291909152205490565b6000828211156104c557600080fd5b50900390565b600160a060020a03821615156104e057600080fd5b600160a060020a038316600090815260208190526040902054610509908263ffffffff6104b616565b600160a060020a03808516600090815260208190526040808220939093559084168152205461053e908263ffffffff61059816565b600160a060020a038084166000818152602081815260409182902094909455805185815290519193928716927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef92918290030190a3505050565b6000828201838110156105aa57600080fd5b939250505056fea165627a7a72305820722c0187518ce2856a424bdba350d5a263c8f98fcb19cb4cc161372bc3b794c90029";
var deployedBytecode = "0x608060405234801561001057600080fd5b50600436106100a5576000357c01000000000000000000000000000000000000000000000000000000009004806370a082311161007857806370a0823114610166578063a457c2d71461018c578063a9059cbb146101b8578063dd62ed3e146101e4576100a5565b8063095ea7b3146100aa57806318160ddd146100ea57806323b872dd14610104578063395093511461013a575b600080fd5b6100d6600480360360408110156100c057600080fd5b50600160a060020a038135169060200135610212565b604080519115158252519081900360200190f35b6100f2610290565b60408051918252519081900360200190f35b6100d66004803603606081101561011a57600080fd5b50600160a060020a03813581169160208101359091169060400135610296565b6100d66004803603604081101561015057600080fd5b50600160a060020a03813516906020013561035f565b6100f26004803603602081101561017c57600080fd5b5035600160a060020a031661040f565b6100d6600480360360408110156101a257600080fd5b50600160a060020a03813516906020013561042a565b6100d6600480360360408110156101ce57600080fd5b50600160a060020a038135169060200135610475565b6100f2600480360360408110156101fa57600080fd5b50600160a060020a038135811691602001351661048b565b6000600160a060020a038316151561022957600080fd5b336000818152600160209081526040808320600160a060020a03881680855290835292819020869055805186815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a350600192915050565b60025490565b600160a060020a03831660009081526001602090815260408083203384529091528120546102ca908363ffffffff6104b616565b600160a060020a03851660009081526001602090815260408083203384529091529020556102f98484846104cb565b600160a060020a0384166000818152600160209081526040808320338085529083529281902054815190815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a35060019392505050565b6000600160a060020a038316151561037657600080fd5b336000908152600160209081526040808320600160a060020a03871684529091529020546103aa908363ffffffff61059816565b336000818152600160209081526040808320600160a060020a0389168085529083529281902085905580519485525191937f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929081900390910190a350600192915050565b600160a060020a031660009081526020819052604090205490565b6000600160a060020a038316151561044157600080fd5b336000908152600160209081526040808320600160a060020a03871684529091529020546103aa908363ffffffff6104b616565b60006104823384846104cb565b50600192915050565b600160a060020a03918216600090815260016020908152604080832093909416825291909152205490565b6000828211156104c557600080fd5b50900390565b600160a060020a03821615156104e057600080fd5b600160a060020a038316600090815260208190526040902054610509908263ffffffff6104b616565b600160a060020a03808516600090815260208190526040808220939093559084168152205461053e908263ffffffff61059816565b600160a060020a038084166000818152602081815260409182902094909455805185815290519193928716927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef92918290030190a3505050565b6000828201838110156105aa57600080fd5b939250505056fea165627a7a72305820722c0187518ce2856a424bdba350d5a263c8f98fcb19cb4cc161372bc3b794c90029";
var compiler = {
  name: "solc",
  version: "0.5.4+commit.9549d8ff.Emscripten.clang"
};
var ERC20 = {
  contractName,
  abi,
  bytecode,
  deployedBytecode,
  compiler
};
var ERC20Interface = new Interface(ERC20.abi);
var boardOpen = ref(false);
function useBoard() {
  const open = () => {
    boardOpen.value = true;
  };
  const close = () => {
    boardOpen.value = false;
  };
  return {
    boardOpen,
    open,
    close
  };
}
var Metamask = class {
  static async check() {
    const provider2 = await (0, import_detect_provider.default)();
    return provider2 ? true : false;
  }
  static async connect() {
    const provider2 = await (0, import_detect_provider.default)();
    await provider2.request({
      method: "eth_requestAccounts",
      params: [{ eth_accounts: {} }]
    });
    return provider2;
  }
};
var WalletConnectProviderDerived = window.WalletConnectProvider?.default || null;
var Walletconnect = class {
  static async check() {
    if (!WalletConnectProviderDerived) {
      console.warn('Walletconnect unavailable: please add below script to enable the feature: <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.6.5/dist/umd/index.min.js"><\/script>');
      return false;
    }
    return true;
  }
  static async connect(infuraId, options) {
    const provider2 = new WalletConnectProviderDerived({
      infuraId,
      ...options
    });
    return new Promise(async (resolve, reject) => {
      provider2.wc.on("disconnect", (err, payload) => {
        if (!provider2.connected) {
          console.log(err, payload);
          reject(new Error("User rejected the request."));
        }
      });
      try {
        await provider2.enable();
      } catch (e) {
        reject(new Error(e));
        return;
      }
      resolve(provider2);
    });
  }
};
var isActivated = ref(false);
var provider$2 = ref(null);
var signer$1 = ref(null);
var network$1 = ref(null);
var address$1 = ref("");
var balance$1 = ref(BigInt(0));
var deactivate = () => {
  isActivated.value = false;
  provider$2.value = null;
  signer$1.value = null;
  network$1.value = null;
  address$1.value = "";
  balance$1.value = BigInt(0);
};
async function activate(walletProvider) {
  const _provider = new Web3Provider(walletProvider);
  const _signer = _provider.getSigner();
  const _network = await _provider.getNetwork();
  const _address = await _signer.getAddress();
  const _balance = await _signer.getBalance();
  provider$2.value = markRaw(_provider);
  signer$1.value = markRaw(_signer);
  network$1.value = _network;
  address$1.value = _address;
  balance$1.value = _balance.toBigInt();
  isActivated.value = true;
}
function useEthers() {
  const chainId = computed(() => network$1.value?.chainId);
  return {
    isActivated,
    provider: provider$2,
    signer: signer$1,
    network: network$1,
    address: address$1,
    balance: balance$1,
    chainId,
    activate,
    deactivate
  };
}
var provider$1 = ref(null);
var status = ref("none");
var walletName = ref("none");
var error = ref("");
var onDisconnectCallback = ref(null);
var onAccountsChangedCallback = ref(null);
var onChainChangedCallback = ref(null);
function useWallet(options = { library: "ethers" }) {
  const { activate: activate2, deactivate: deactivate2 } = useEthers();
  function clear() {
    provider$1.value = null;
    status.value = "none";
    walletName.value = "none";
    error.value = "";
    onDisconnectCallback.value = null;
    onAccountsChangedCallback.value = null;
    onChainChangedCallback.value = null;
    options.library === "ethers" && deactivate2();
  }
  async function connect(_walletName, infuraAPI) {
    let _provider = null;
    error.value = "";
    try {
      status.value = "connecting";
      switch (_walletName) {
        case "metamask":
          _provider = await Metamask.connect();
          if (!_provider.isConnected)
            throw new Error("metamask is not connected");
          break;
        case "walletconnect":
          if (!infuraAPI)
            throw new Error("You should provide infuraAPI for connecting WalletConnect");
          _provider = await Walletconnect.connect(infuraAPI);
          if (!_provider.connected)
            throw new Error("walletconnect is not connected");
          break;
        default:
          throw new Error("Connect Error: wallet name not found");
      }
    } catch (err) {
      clear();
      error.value = `Failed to connect: ${err.message}`;
      return;
    }
    provider$1.value = markRaw(_provider);
    walletName.value = _walletName;
    status.value = "connected";
    subscribeDisconnect();
    subscribeAccountsChanged();
    subscribeChainChanged();
    options.library === "ethers" && await activate2(provider$1.value);
  }
  async function disconnect() {
    if (walletName.value === "walletconnect") {
      await provider$1.value.disconnect();
    }
    clear();
    onDisconnectCallback.value && onDisconnectCallback.value("Disconnect from Dapp");
  }
  function subscribeDisconnect() {
    switch (walletName.value) {
      case "metamask":
        provider$1.value.on("disconnect", (err) => {
          clear();
          onDisconnectCallback.value && onDisconnectCallback.value(err.message);
        });
        break;
      case "walletconnect":
        provider$1.value.on("disconnect", (code, reason) => {
          clear();
          onDisconnectCallback.value && onDisconnectCallback.value(`${code}: ${reason}`);
        });
        break;
    }
  }
  function subscribeAccountsChanged() {
    switch (walletName.value) {
      case "metamask":
        provider$1.value.on("accountsChanged", async (accounts) => {
          options.library === "ethers" && await activate2(provider$1.value);
          onAccountsChangedCallback.value && onAccountsChangedCallback.value(accounts);
        });
        break;
      case "walletconnect":
        provider$1.value.on("accountsChanged", async (accounts) => {
          options.library === "ethers" && await activate2(provider$1.value);
          onAccountsChangedCallback.value && onAccountsChangedCallback.value(accounts);
        });
        break;
    }
  }
  function subscribeChainChanged() {
    switch (walletName.value) {
      case "metamask":
        provider$1.value.on("chainChanged", async (hexChainId) => {
          const chainId = parseInt(hexChainId, 16);
          options.library === "ethers" && await activate2(provider$1.value);
          onChainChangedCallback.value && onChainChangedCallback.value(chainId);
        });
        break;
      case "walletconnect":
        provider$1.value.on("chainChanged", async (chainId) => {
          options.library === "ethers" && await activate2(provider$1.value);
          onChainChangedCallback.value && onChainChangedCallback.value(chainId);
        });
        break;
    }
  }
  function onDisconnect(callback) {
    onDisconnectCallback.value = callback;
  }
  function onAccountsChanged(callback) {
    onAccountsChangedCallback.value = callback;
  }
  function onChainChanged(callback) {
    onChainChangedCallback.value = callback;
  }
  const isConnected = computed(() => {
    if (status.value === "connected")
      return true;
    else
      return false;
  });
  return {
    provider: provider$1,
    status,
    walletName,
    error,
    isConnected,
    connect,
    disconnect,
    onDisconnect,
    onAccountsChanged,
    onChainChanged
  };
}
function useMulticall(provider2) {
  const results = ref([]);
  const blockNumber = ref(0);
  const multicall = markRaw(new Contract(MULTICALL2_ADDRESS, MULTICALL2_ABI, provider2));
  async function call(contractCalls) {
    const calls = contractCalls.map((call2) => {
      const iface = getInterface(call2.interface);
      return {
        target: call2.address,
        callData: iface.encodeFunctionData(call2.method, call2.args)
      };
    });
    const { blockNumber: blocNum, returnData } = await tryBlockAndAggregate(calls);
    results.value = returnData.map((data, i) => {
      if (!data.success)
        console.error(`Failed to call ${contractCalls[i].method}`);
      const iface = getInterface(contractCalls[i].interface);
      return iface.decodeFunctionResult(contractCalls[i].method, data.returnData);
    });
    blockNumber.value = blocNum.toNumber();
  }
  async function tryBlockAndAggregate(calls) {
    return await multicall.callStatic.tryBlockAndAggregate(false, calls);
  }
  return {
    multicall,
    blockNumber,
    results,
    call
  };
}
function getInterface(contractInterface) {
  if (Interface.isInterface(contractInterface)) {
    return contractInterface;
  }
  return new Interface(contractInterface);
}
var { provider, signer, network, address, balance } = useEthers();
function useEthersHooks() {
  const onActivatedHook = ref(null);
  const onDeactivatedHook = ref(null);
  const onChangedHook = ref(null);
  watch(provider, (provider2, oldProvider) => {
    if (!oldProvider && provider2) {
      onActivatedHook.value && onActivatedHook.value({
        provider: provider2,
        signer: signer.value,
        network: network.value,
        address: address.value,
        balance: balance.value
      });
    } else if (oldProvider && provider2) {
      onChangedHook.value && onChangedHook.value({
        provider: provider2,
        signer: signer.value,
        network: network.value,
        address: address.value,
        balance: balance.value
      });
    } else if (oldProvider && !provider2) {
      onDeactivatedHook.value && onDeactivatedHook.value();
    }
  });
  const onActivated = (hook) => onActivatedHook.value = hook;
  const onChanged = (hook) => onChangedHook.value = hook;
  const onDeactivated = (hook) => onDeactivatedHook.value = hook;
  return {
    onActivated,
    onDeactivated,
    onChanged
  };
}
async function checkInfuraId(infuraId) {
  try {
    const res = await fetch(`https://mainnet.infura.io/v3/${infuraId}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "eth_blockNumber",
        params: []
      })
    });
    const data = await res.json();
    console.log("Infura ID is valid.", data);
    return true;
  } catch (e) {
    console.warn("Walletconnect unavailable: Failed to connect to infura node, please check if your infura ID is valid.");
    return false;
  }
}
function checkChainId(chainId) {
  if (chainId in ChainId) {
    return true;
  }
  return false;
}
function shortenAddress(address2) {
  if ((0, import_utils.isAddress)(address2)) {
    return address2.slice(0, 6) + "..." + address2.slice(-4);
  } else {
    return "";
  }
}
function displayEther(balance2, fixed = 2) {
  return (+(0, import_utils.formatEther)(balance2)).toFixed(fixed);
}
function displayChainName(chainId) {
  if (!checkChainId(chainId)) {
    throw new Error("Error: Invalid chainId");
  }
  return CHAIN_NAMES[chainId].toLowerCase();
}
var clickOutside = {
  beforeMount: (el, binding) => {
    el.clickOutsideEvent = (event) => {
      event.stopPropagation();
      if (event.target !== el && !el.contains(event.target)) {
        binding.value(event);
      }
    };
    const clickHandler = "ontouchstart" in document.documentElement ? "touchstart" : "click";
    setTimeout(() => {
      document.addEventListener(clickHandler, el.clickOutsideEvent);
    }, 0);
  },
  unmounted: (el) => {
    const clickOutsideEvent = el.clickOutsideEvent;
    delete el.clickOutsideEvent;
    const clickHandler = "ontouchstart" in document.documentElement ? "touchstart" : "click";
    document.removeEventListener(clickHandler, clickOutsideEvent);
  }
};
var script$3 = defineComponent({
  emits: ["close"],
  props: {
    modalOpen: {
      type: Boolean,
      required: true
    }
  },
  setup(props, { emit }) {
    const closeModal = () => {
      emit("close");
    };
    watch(() => props.modalOpen, (value) => {
      if (value) {
        document.body.classList.add("overflow-hidden");
      } else {
        document.body.classList.remove("overflow-hidden");
      }
    });
    onUnmounted(() => {
      document.body.classList.remove("overflow-hidden");
    });
    return {
      closeModal
    };
  }
});
pushScopeId("data-v-701ac82d");
var _hoisted_1$3 = {
  key: 0,
  class: "modal"
};
var _hoisted_2$3 = { class: "modal-inner" };
var _hoisted_3$3 = { class: "modal-content" };
popScopeId();
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Teleport, { to: "body" }, [
    createVNode(Transition, { name: "modal-animation" }, {
      default: withCtx(() => [
        _ctx.modalOpen ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
          createBaseVNode("div", _hoisted_2$3, [
            createBaseVNode("div", _hoisted_3$3, [
              createCommentVNode(" Modal Content "),
              renderSlot(_ctx.$slots, "default")
            ])
          ])
        ])) : createCommentVNode("v-if", true)
      ]),
      _: 3
    })
  ]);
}
function styleInject(css, ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z$1 = "\n.modal[data-v-701ac82d] {\n  position: fixed;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n  min-width: 100vw;\n  height: 100vh;\n  background-color: rgba(107, 114, 128, 0.7);\n  left: 0px;\n  top: 0px;\n  z-index: 50;\n}\n.modal-inner[data-v-701ac82d] {\n  display: flex;\n  background: #ffffff;\n  border-radius: 1rem;\n  box-shadow: rgba(255, 255, 255, 0.1) 0px 1px 1px 0px inset,\n    rgba(50, 50, 93, 0.25) 0px 50px 100px -20px,\n    rgba(0, 0, 0, 0.3) 0px 30px 60px -30px;\n}\n.modal-animation-enter-active[data-v-701ac82d],\n.modal-animation-leave-active[data-v-701ac82d] {\n  transition: opacity 0.3s cubic-bezier(0.52, 0.02, 0.19, 1.02);\n}\n.modal-animation-enter-from[data-v-701ac82d],\n.modal-animation-leave-to[data-v-701ac82d] {\n  opacity: 0;\n}\n";
styleInject(css_248z$1);
script$3.render = render$3;
script$3.__scopeId = "data-v-701ac82d";
script$3.__file = "src/components/Modal.vue";
var _hoisted_1$2 = {
  height: "246",
  viewBox: "0 0 400 246",
  width: "400",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2$2 = createBaseVNode("path", {
  d: "m81.9180572 48.3416816c65.2149658-63.8508884 170.9493158-63.8508884 236.1642788 0l7.848727 7.6845565c3.260748 3.1925442 3.260748 8.3686816 0 11.5612272l-26.848927 26.2873374c-1.630375 1.5962734-4.273733 1.5962734-5.904108 0l-10.800779-10.5748639c-45.495589-44.5439756-119.258514-44.5439756-164.754105 0l-11.566741 11.3248068c-1.630376 1.5962721-4.273735 1.5962721-5.904108 0l-26.8489263-26.2873375c-3.2607483-3.1925456-3.2607483-8.3686829 0-11.5612272zm291.6903948 54.3649934 23.895596 23.395862c3.260732 3.19253 3.260751 8.368636.000041 11.561187l-107.746894 105.494845c-3.260726 3.192568-8.547443 3.192604-11.808214.000083-.000013-.000013-.000029-.000029-.000042-.000043l-76.472191-74.872762c-.815187-.798136-2.136867-.798136-2.952053 0-.000006.000005-.00001.00001-.000015.000014l-76.470562 74.872708c-3.260715 3.192576-8.547434 3.19263-11.808215.000116-.000019-.000018-.000039-.000037-.000059-.000058l-107.74989297-105.496247c-3.26074695-3.192544-3.26074695-8.368682 0-11.561226l23.89563947-23.395823c3.260747-3.1925446 8.5474652-3.1925446 11.8082136 0l76.4733029 74.873809c.815188.798136 2.136866.798136 2.952054 0 .000012-.000012.000023-.000023.000035-.000032l76.469471-74.873777c3.260673-3.1926181 8.547392-3.1927378 11.808214-.000267.000046.000045.000091.00009.000135.000135l76.473203 74.873909c.815186.798135 2.136866.798135 2.952053 0l76.471967-74.872433c3.260748-3.1925458 8.547465-3.1925458 11.808213 0z",
  fill: "#3b99fc"
}, null, -1);
var _hoisted_3$2 = [
  _hoisted_2$2
];
function render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2, _hoisted_3$2);
}
var script$2 = {};
script$2.render = render$2;
script$2.__file = "src/components/logos/WalletConnect.vue";
var _hoisted_1$1 = {
  height: "355",
  viewBox: "0 0 397 355",
  width: "397",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2$1 = createStaticVNode('<g fill="none" fill-rule="evenodd" transform="translate(-1 -1)"><path d="m114.622644 327.195472 52.004717 13.810198v-18.05949l4.245283-4.249292h29.716982v21.246459 14.872523h-31.839624l-39.268868-16.997169z" fill="#cdbdb2"></path><path d="m199.528305 327.195472 50.943397 13.810198v-18.05949l4.245283-4.249292h29.716981v21.246459 14.872523h-31.839623l-39.268868-16.997169z" fill="#cdbdb2" transform="matrix(-1 0 0 1 483.96227 0)"></path><path d="m170.872644 287.889523-4.245283 35.056657 5.306604-4.249292h55.18868l6.367925 4.249292-4.245284-35.056657-8.490565-5.311615-42.452832 1.062323z" fill="#393939"></path><path d="m142.216984 50.9915022 25.471698 59.4900858 11.674528 173.158643h41.391511l12.735849-173.158643 23.349056-59.4900858z" fill="#f89c35"></path><path d="m30.7783023 181.657226-29.71698153 86.048161 74.29245393-4.249293h47.7594343v-37.181303l-2.122641-76.487253-10.613208 8.498583z" fill="#f89d35"></path><path d="m87.0283032 191.218134 87.0283028 2.124646-9.551886 44.617563-41.391511-10.623229z" fill="#d87c30"></path><path d="m87.0283032 192.280457 36.0849058 33.994334v33.994334z" fill="#ea8d3a"></path><path d="m123.113209 227.337114 42.452831 10.623229 13.79717 45.679888-9.551886 5.311615-46.698115-27.620398z" fill="#f89d35"></path><path d="m123.113209 261.331448-8.490565 65.864024 56.25-39.305949z" fill="#eb8f35"></path><path d="m174.056606 193.34278 5.306604 90.297451-15.919812-46.211049z" fill="#ea8e3a"></path><path d="m74.2924539 262.393771 48.8207551-1.062323-8.490565 65.864024z" fill="#d87c30"></path><path d="m24.4103777 355.878193 90.2122663-28.682721-40.3301901-64.801701-73.23113313 5.311616z" fill="#eb8f35"></path><path d="m167.688682 110.481588-45.636793 38.243627-35.0235858 42.492919 87.0283028 3.186969z" fill="#e8821e"></path><path d="m114.622644 327.195472 56.25-39.305949-4.245283 33.994334v19.121813l-38.207548-7.43626z" fill="#dfcec3"></path><path d="m229.245286 327.195472 55.18868-39.305949-4.245283 33.994334v19.121813l-38.207548-7.43626z" fill="#dfcec3" transform="matrix(-1 0 0 1 513.679252 0)"></path><path d="m132.665096 212.464593-11.674528 24.433427 41.39151-10.623229z" fill="#393939" transform="matrix(-1 0 0 1 283.372646 0)"></path><path d="m23.349057 1.06232296 144.339625 109.41926504-24.410378-59.4900858z" fill="#e88f35"></path><path d="m23.349057 1.06232296-19.10377392 58.42776294 10.61320772 63.7393781-7.42924541 4.249292 10.61320771 9.560906-8.49056617 7.436261 11.67452847 10.623229-7.4292454 6.373938 16.9811323 21.246459 79.5990577-24.433428c38.915096-31.161473 58.018869-47.096318 57.311322-47.804533-.707548-.708215-48.820756-37.1813036-144.339625-109.41926504z" fill="#8e5a30"></path><g transform="matrix(-1 0 0 1 399.056611 0)"><path d="m30.7783023 181.657226-29.71698153 86.048161 74.29245393-4.249293h47.7594343v-37.181303l-2.122641-76.487253-10.613208 8.498583z" fill="#f89d35"></path><path d="m87.0283032 191.218134 87.0283028 2.124646-9.551886 44.617563-41.391511-10.623229z" fill="#d87c30"></path><path d="m87.0283032 192.280457 36.0849058 33.994334v33.994334z" fill="#ea8d3a"></path><path d="m123.113209 227.337114 42.452831 10.623229 13.79717 45.679888-9.551886 5.311615-46.698115-27.620398z" fill="#f89d35"></path><path d="m123.113209 261.331448-8.490565 65.864024 55.18868-38.243626z" fill="#eb8f35"></path><path d="m174.056606 193.34278 5.306604 90.297451-15.919812-46.211049z" fill="#ea8e3a"></path><path d="m74.2924539 262.393771 48.8207551-1.062323-8.490565 65.864024z" fill="#d87c30"></path><path d="m24.4103777 355.878193 90.2122663-28.682721-40.3301901-64.801701-73.23113313 5.311616z" fill="#eb8f35"></path><path d="m167.688682 110.481588-45.636793 38.243627-35.0235858 42.492919 87.0283028 3.186969z" fill="#e8821e"></path><path d="m132.665096 212.464593-11.674528 24.433427 41.39151-10.623229z" fill="#393939" transform="matrix(-1 0 0 1 283.372646 0)"></path><path d="m23.349057 1.06232296 144.339625 109.41926504-24.410378-59.4900858z" fill="#e88f35"></path><path d="m23.349057 1.06232296-19.10377392 58.42776294 10.61320772 63.7393781-7.42924541 4.249292 10.61320771 9.560906-8.49056617 7.436261 11.67452847 10.623229-7.4292454 6.373938 16.9811323 21.246459 79.5990577-24.433428c38.915096-31.161473 58.018869-47.096318 57.311322-47.804533-.707548-.708215-48.820756-37.1813036-144.339625-109.41926504z" fill="#8e5a30"></path></g></g>', 1);
var _hoisted_3$1 = [
  _hoisted_2$1
];
function render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1, _hoisted_3$1);
}
var script$1 = {};
script$1.render = render$1;
script$1.__file = "src/components/logos/MetaMask.vue";
var script = defineComponent({
  components: {
    Modal: script$3,
    MetaMaskIcon: script$1,
    WalletConnectIcon: script$2
  },
  inject: ["infuraId"],
  setup() {
    const { boardOpen: boardOpen2, close } = useBoard();
    const { connect, status: status2 } = useWallet();
    const metamaskDisabled = ref(true);
    const walletconnectDisabled = ref(true);
    const infuraId = inject("infuraId");
    onMounted(async () => {
      if (await Metamask.check()) {
        metamaskDisabled.value = false;
      }
      if (infuraId && await Walletconnect.check()) {
        walletconnectDisabled.value = false;
      }
    });
    const loadingOpen = ref(false);
    const openLoading = () => {
      loadingOpen.value = true;
    };
    const closeLoading = () => {
      loadingOpen.value = false;
    };
    const connectWallet = async (wallet) => {
      try {
        switch (wallet) {
          case "metamask":
            await connectMetamask();
            break;
          case "walletconnect":
            await connectWalletconnect();
            break;
        }
      } catch (e) {
        console.error(e.message);
      } finally {
        closeLoading();
      }
    };
    const connectMetamask = async () => {
      if (metamaskDisabled.value)
        return;
      close();
      openLoading();
      await connect("metamask");
    };
    const connectWalletconnect = async () => {
      if (walletconnectDisabled.value)
        return;
      close();
      openLoading();
      await connect("walletconnect", infuraId);
    };
    return {
      status: status2,
      boardOpen: boardOpen2,
      metamaskDisabled,
      walletconnectDisabled,
      close,
      connectWallet,
      loadingOpen,
      openLoading,
      closeLoading
    };
  }
});
pushScopeId("data-v-e1ee1034");
var _hoisted_1 = { class: "item" };
var _hoisted_2 = createBaseVNode("div", null, "MetaMask", -1);
var _hoisted_3 = createBaseVNode("div", { class: "line" }, null, -1);
var _hoisted_4 = { class: "item" };
var _hoisted_5 = createBaseVNode("div", null, "WalletConnect", -1);
var _hoisted_6 = {
  key: 0,
  class: "loading-modal"
};
var _hoisted_7 = createBaseVNode("p", null, "Pending Call Request", -1);
var _hoisted_8 = createBaseVNode("p", null, "Approve or reject request using your wallet", -1);
var _hoisted_9 = [
  _hoisted_7,
  _hoisted_8
];
var _hoisted_10 = { key: 1 };
popScopeId();
function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MetaMaskIcon = resolveComponent("MetaMaskIcon");
  const _component_WalletConnectIcon = resolveComponent("WalletConnectIcon");
  const _component_Modal = resolveComponent("Modal");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_Modal, {
      modalOpen: _ctx.boardOpen,
      onClose: _ctx.close
    }, {
      default: withCtx(() => [
        withDirectives(createBaseVNode("div", null, [
          createBaseVNode("div", {
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.connectWallet("metamask")),
            class: normalizeClass(["wallet-item", _ctx.metamaskDisabled ? "wallet-disabled" : ""])
          }, [
            createBaseVNode("div", _hoisted_1, [
              createVNode(_component_MetaMaskIcon, { class: "logo" }),
              _hoisted_2
            ])
          ], 2),
          _hoisted_3,
          createBaseVNode("div", {
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.connectWallet("walletconnect")),
            class: normalizeClass(["wallet-item", _ctx.walletconnectDisabled ? "wallet-disabled" : ""])
          }, [
            createBaseVNode("div", _hoisted_4, [
              createVNode(_component_WalletConnectIcon, { class: "logo" }),
              _hoisted_5
            ])
          ], 2)
        ], 512), [
          [_directive_click_outside, _ctx.close]
        ])
      ]),
      _: 1
    }, 8, ["modalOpen", "onClose"]),
    createVNode(_component_Modal, { modalOpen: _ctx.loadingOpen }, {
      default: withCtx(() => [
        _ctx.status === "connecting" ? (openBlock(), createElementBlock("div", _hoisted_6, _hoisted_9)) : createCommentVNode("v-if", true),
        createCommentVNode(" loading between connected to isActivated "),
        _ctx.status === "connected" ? (openBlock(), createElementBlock("div", _hoisted_10)) : createCommentVNode("v-if", true)
      ]),
      _: 1
    }, 8, ["modalOpen"])
  ], 64);
}
var css_248z = "\n.wallet-item[data-v-e1ee1034] {\n  display: flex;\n  justify-content: center;\n  padding-top: 2rem;\n  padding-bottom: 2rem;\n  padding-left: 2.5rem;\n  padding-right: 2.5rem;\n  margin: 0.5rem;\n  border-radius: 0.75rem;\n  cursor: pointer;\n}\n.wallet-item[data-v-e1ee1034]:hover {\n  background-color: rgba(243, 244, 246, 0.664);\n}\n@media (min-width: 640px) {\n.wallet-item[data-v-e1ee1034] {\n    width: 24rem;\n}\n}\n.item[data-v-e1ee1034] {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  font-size: 1.5rem;\n  line-height: 2rem;\n}\n.item[data-v-e1ee1034] > :not([hidden]) ~ :not([hidden]) {\n  margin-top: 1rem;\n  margin-bottom: 1rem;\n}\n.line[data-v-e1ee1034] {\n  color: #e5e7eb;\n  border-width: 0px;\n  border-bottom-width: 1px;\n  border-style: solid;\n}\n.logo[data-v-e1ee1034] {\n  width: 50px;\n  height: 50px;\n}\n.wallet-disabled[data-v-e1ee1034] {\n  opacity: 0.5;\n}\n.wallet-disabled[data-v-e1ee1034]:hover {\n  background-color: rgba(255, 255, 255, 0.623);\n  cursor: default;\n}\n.loading-modal[data-v-e1ee1034] {\n  width: 20rem;\n  padding: 2.5rem;\n  text-align: center;\n}\n.loading-modal > p[data-v-e1ee1034]:first-child {\n  font-size: 1.25rem;\n  line-height: 1.75rem;\n}\n@media (min-width: 640px) {\n.loading-modal[data-v-e1ee1034] {\n    width: auto;\n}\n}\n";
styleInject(css_248z);
script.render = render;
script.__scopeId = "data-v-e1ee1034";
script.__file = "src/components/Board.vue";
var VueDapp = {
  install(app, options) {
    if (!options?.infuraId) {
      console.warn('For enabling WalletConnect, you should provide infura ID in plugin options like "app.use(VueDapp, { infuraId: "<your-id>" })"');
    }
    app.directive("click-outside", clickOutside);
    app.component("vdapp-board", script);
    app.component("vdapp-modal", script$3);
    app.provide("infuraId", options?.infuraId);
  }
};
export {
  CHAIN_NAMES,
  ChainId,
  ERC20,
  ERC20Interface,
  MULTICALL2_ABI,
  MULTICALL2_ADDRESS,
  VueDapp,
  checkChainId,
  checkInfuraId,
  displayChainName,
  displayEther,
  shortenAddress,
  useBoard,
  useEthers,
  useEthersHooks,
  useMulticall,
  useWallet
};
//# sourceMappingURL=vue-dapp.js.map

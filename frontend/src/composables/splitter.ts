import { computed, markRaw, reactive, ref } from 'vue'
import artifact from '@splitter/contracts/artifacts/contracts/Splitter.sol/Splitter.json'
import { Splitter } from '@splitter/contracts/typechain/Splitter'
import { SplitterFactory } from '@splitter/contracts/typechain/SplitterFactory'
import { BigNumber, ContractFactory, ethers, Signer } from 'ethers'
import useConfig from '@/config'
import { formatEther } from 'ethers/lib/utils'
import { ContractCall, displayEther, useMulticall } from 'vue-dapp'

const { rpcURL } = useConfig()



type Payee = {
  address: string
  share: number
  available: string
}

export default function useSplitter() {
  const state = reactive({
    splitter: <Splitter | null>null,
    address: '',
    balance: '',
    owner: '',
    totalReceived: '0',
    state: '',
    totalPayees: 0,
    totalShares: 1,
    payees: <Payee[]>[],
    withdrawableAmount: BigNumber.from(0),
  })

  function clearState() {
    state.splitter = null
    state.address = ''
    state.balance = ''
    state.owner = ''
    state.totalReceived = '0'
    state.state = ''
    state.totalPayees = 0
    state.totalShares = 1
    state.payees = <Payee[]>[]
    state.withdrawableAmount = BigNumber.from(0)
  }

  async function deploy(
    signer: Signer,
    owner: string,
    payees: string[],
    shares: number[],
  ): Promise<string> {
    const splitterFactory = new ContractFactory(
      artifact.abi,
      artifact.bytecode,
      signer,
    ) as SplitterFactory
    const splitter = (await splitterFactory.deploy(
      owner,
      payees,
      shares,
    )) as Splitter
    await splitter.deployed()
    return splitter.address
  }

  async function fetchWithdrawableAmount(signer: Signer, address: string) {
    const splitter = new ethers.Contract(
      address,
      artifact.abi,
      signer,
    ) as Splitter
    const balance = await signer.provider?.getBalance(address)
    const share = await splitter.shares(await signer.getAddress())
    const released = await splitter.released(await signer.getAddress())

    const totalReleased = await splitter.totalReleased()
    const totalReceived = balance?.add(totalReleased)
    const totalShares = await splitter.totalShares()
    const withdrawable = totalReceived
      ?.mul(share)
      .div(totalShares)
      .sub(released)

    state.withdrawableAmount = withdrawable || BigNumber.from(0)
  }

  async function fetch(address: string) {
    const provider = new ethers.providers.JsonRpcProvider(rpcURL.value)
    const splitter = new ethers.Contract(
      address,
      artifact.abi,
      provider,
    ) as Splitter

    await splitter.deployed()

    // multicall usecase
    const { multicall, call, results } = useMulticall(provider)

    const calls: ContractCall[] = [
      {
        interface: splitter.interface,
        address: address,
        method: 'owner',
      },
      {
        interface: splitter.interface,
        address: address,
        method: 'totalPayees',
      },
      {
        interface: splitter.interface,
        address: address,
        method: 'totalShares',
      },
      {
        interface: splitter.interface,
        address: address,
        method: 'state',
      },
      {
        interface: multicall.interface,
        address: multicall.address,
        method: 'getEthBalance',
        args: [address],
      },
      {
        interface: splitter.interface,
        address: address,
        method: 'totalReleased',
      },
    ]

    await call(calls)

    const [
      [owner],
      [totalPayees],
      [totalShares],
      [stateNum],
      { balance },
      [totalReleased],
    ] = results.value

    const totalReceived = balance.add(totalReleased)

    let payees = <Payee[]>[]
    for (let i = 0; i < totalPayees.toNumber(); i++) {
      const address = await splitter.payee(BigNumber.from(i))
      const share = await splitter.shares(address)
      const available = totalReceived.mul(share).div(totalShares)

      const payee: Payee = {
        address,
        share: share.toNumber(),
        available: (+formatEther(available)).toFixed(3),
      }

      payees.push(payee)
    }

    state.splitter = markRaw(splitter)
    state.payees = payees
    state.address = address
    state.balance = displayEther(balance)
    state.owner = owner
    state.totalPayees = totalPayees.toNumber()
    state.totalShares = totalShares.toNumber()
    state.totalReceived = displayEther(totalReceived)
    switch (stateNum) {
      case 0:
        state.state = 'Opening'
        break
      case 1:
        state.state = 'Finalized'
        break
    }
  }

  async function addPayees(
    signer: Signer,
    address: string,
    payees: string[],
    shares: number[],
  ) {
    const splitter = new ethers.Contract(
      address,
      artifact.abi,
      signer,
    ) as Splitter
    await splitter.addPayees(payees, shares)
  }

  async function withdraw(signer: Signer, address: string, recipient: string) {
    const splitter = new ethers.Contract(
      address,
      artifact.abi,
      signer,
    ) as Splitter
    const tx = await splitter.release(recipient)
    return tx
  }

  async function finalize(signer: Signer, address: string) {
    const splitter = new ethers.Contract(
      address,
      artifact.abi,
      signer,
    ) as Splitter
    const tx = await splitter.finalize()
    return tx
  }

  const withdrawable = computed(() => {
    return state.withdrawableAmount.gt(BigNumber.from(0))
  })

  return {
    state,
    withdrawable,

    fetch,
    clearState,
    deploy,
    addPayees,
    withdraw,
    finalize,
    fetchWithdrawableAmount,
  }
}
